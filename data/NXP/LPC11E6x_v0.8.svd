<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd"><addressUnitBits>0x8</addressUnitBits>
<cpu>
  <dcachePresent>
    <dcachePresen></dcachePresen>
  </dcachePresent>
  <deviceNumInterrupts>0x0</deviceNumInterrupts>
  <dtcmPresent>
    <dtcmPresen></dtcmPresen>
  </dtcmPresent>
  <endian>little</endian>
  <fpuPresent>0x0</fpuPresent>
  <icachePresent>
    <icachePresen></icachePresen>
  </icachePresent>
  <itcmPresent>
    <itcmPresen></itcmPresen>
  </itcmPresent>
  <mpuPresent>0x0</mpuPresent>
  <name>CM0PLUS</name>
  <nvicPrioBits>0x2</nvicPrioBits>
  <revision>r0p1</revision>
  <sauNumRegions>0x0</sauNumRegions>
  <vendorSystickConfig>0x0</vendorSystickConfig>
</cpu>
<description>LPC11E6x ARM cortex-m0+</description>
<name>LPC11E6x</name>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40000000</baseAddress>
    <description>I2C-bus controller</description>
    <groupName>I2C0</groupName>
    <interrupts>
      <interrupt>
        <name>I2C0</name>
        <value>0xF</value>
      </interrupt>
    </interrupts>
    <name>I2C0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.</description>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Assert acknowledge flag.</description>
            <name>AA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interrupt flag.</description>
            <name>SI</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP flag.</description>
            <name>STO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>START flag.</description>
            <name>STA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interface enable.</description>
            <name>I2EN</name>
          </field>
        </fields>
        <name>CONSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>These bits give the actual status information about the I2C interface.</description>
            <name>Status</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This register holds data values that have been received or are to be transmitted.</description>
            <name>Data</name>
          </field>
        </fields>
        <name>DAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Count for SCL HIGH time period selection.</description>
            <name>SCLH</name>
          </field>
        </fields>
        <name>SCLH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Count for SCL low time period selection.</description>
            <name>SCLL</name>
          </field>
        </fields>
        <name>SCLL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x18</addressOffset>
        <description>I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.</description>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Assert acknowledge Clear bit.</description>
            <name>AAC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interrupt Clear bit.</description>
            <name>SIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>START flag Clear bit.</description>
            <name>STAC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interface Disable bit.</description>
            <name>I2ENC</name>
          </field>
        </fields>
        <name>CONCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Monitor mode control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Monitor mode disabled.</description>
                <name>MONITOR_MODE_DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The I2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I 2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line.</description>
                <name>THE_I2C_MODULE_WILL_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MM_ENA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL output enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line.</description>
                <name>HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]</description>
                <name>NORMAL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA_SCL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select interrupt register match.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus.</description>
                <name>ANYADDRESS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MATCH_ALL</name>
          </field>
        </fields>
        <name>MMCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This register holds contents of the 8 MSBs of the DAT shift register.</description>
            <name>Data</name>
          </field>
        </fields>
        <name>DATA_BUFFER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40004000</baseAddress>
    <description>Windowed Watchdog Timer (WWDT)</description>
    <groupName>WWDT</groupName>
    <interrupts></interrupts>
    <name>WWDT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog timer is stopped.</description>
                <name>STOPPED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog timer is running.</description>
                <name>RUNNING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>A watchdog timeout will not cause a chip reset.</description>
                <name>INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDRESET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1.</description>
            <name>WDTOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software.</description>
            <name>WDINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog update mode. This bit can be set once by software and is only cleared by a reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog time-out value (TC) can be changed at any time.</description>
                <name>NOT_LOCKED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW.</description>
                <name>LOCKED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDPROTECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents disabling or powering down the clock source selected by bit 0 of the WDCLKSRC register and also prevents switching to a clock source that is disabled or powered down. This bit can be set once by software and is only cleared by any reset. If this bit is one and the WWDT clock source is the IRC when Deep-sleep or Power-down modes are entered, the IRC remains running thereby increasing power consumption in Deep-sleep mode and potentially preventing the part of entering Power-down mode correctly (see Section 15.7).</description>
            <name>LOCK</name>
          </field>
        </fields>
        <name>MOD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Watchdog timer constant register. This 24-bit register determines the time-out value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Watchdog time-out value.</description>
            <name>COUNT</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Feed value should be 0xAA followed by 0x55.</description>
            <name>FEED</name>
          </field>
        </fields>
        <name>FEED</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Counter timer value.</description>
            <name>COUNT</name>
          </field>
        </fields>
        <name>TV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Watchdog clock select register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects source of WDT clock</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC</description>
                <name>IRC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator (WDOSC)</description>
                <name>WATCHDOG_OSCILLATOR_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is set to one writing to this register does not affect bit 0. The clock source can only be changed by first clearing this bit, then writing the new value of bit 0.</description>
            <name>LOCK</name>
          </field>
        </fields>
        <name>CLKSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Watchdog Warning Interrupt compare value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Watchdog warning interrupt compare value.</description>
            <name>WARNINT</name>
          </field>
        </fields>
        <name>WARNINT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Watchdog Window compare value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Watchdog window value.</description>
            <name>WINDOW</name>
          </field>
        </fields>
        <name>WINDOW</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40008000</baseAddress>
    <description>USART0</description>
    <groupName>USART0</groupName>
    <interrupts>
      <interrupt>
        <name>USART</name>
        <value>0x15</value>
      </interrupt>
    </interrupts>
    <name>USART0</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>The USART Receiver Buffer Register contains the oldest received byte in the USART RX FIFO.</description>
            <name>RBR</name>
          </field>
        </fields>
        <name>RBR</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Writing to the USART Transmit Holding Register causes the data to be stored in the USART transmit FIFO. The byte will be sent when it is the oldest byte in the FIFO and the transmitter is available.</description>
            <name>THR</name>
          </field>
        </fields>
        <name>THR</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>The USART Divisor Latch LSB Register, along with the DLM register, determines the baud rate of the USART.</description>
            <name>DLLSB</name>
          </field>
        </fields>
        <name>DLL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>The USART Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the USART.</description>
            <name>DLMSB</name>
          </field>
        </fields>
        <name>DLM</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential USART interrupts. (DLAB=0)</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RBR Interrupt Enable. Enables the Receive Data Available interrupt. It also controls the Character Receive Time-out interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable the RDA interrupt.</description>
                <name>DISABLE_THE_RDA_INTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable the RDA interrupt.</description>
                <name>ENABLE_THE_RDA_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RBRINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>THRE Interrupt Enable. Enables the THRE interrupt. The status of this interrupt can be read from LSR[5].</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable the THRE interrupt.</description>
                <name>DISABLE_THE_THRE_INT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable the THRE interrupt.</description>
                <name>ENABLE_THE_THRE_INTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>THREINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the Receive Line Status interrupt. The status of this interrupt can be read from LSR[4:1].</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable the RLS interrupt.</description>
                <name>DISABLE_THE_RLS_INTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable the RLS interrupt.</description>
                <name>ENABLE_THE_RLS_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RLSINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the Modem Status interrupt. The components of this interrupt can be read from the MSR.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable the MS interrupt.</description>
                <name>DISABLE_THE_MS_INTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable the MS interrupt.</description>
                <name>ENABLE_THE_MS_INTERR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the end of auto-baud interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable end of auto-baud Interrupt.</description>
                <name>DISABLE_END_OF_AUTO_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable end of auto-baud Interrupt.</description>
                <name>ENABLE_END_OF_AUTO_B</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ABEOINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the auto-baud time-out interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable auto-baud time-out Interrupt.</description>
                <name>DISABLE_AUTO_BAUD_TI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable auto-baud time-out Interrupt.</description>
                <name>ENABLE_AUTO_BAUD_TIM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ABTOINTEN</name>
          </field>
        </fields>
        <name>IER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Interrupt ID Register. Identifies which interrupt(s) are pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt status. Note that IIR[0] is active low. The pending interrupt can be determined by evaluating IIR[3:1].</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>At least one interrupt is pending.</description>
                <name>AT_LEAST_ONE_INTERRU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt is pending.</description>
                <name>NO_INTERRUPT_IS_PEND</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTSTATUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Interrupt identification. IER[3:1] identifies an interrupt corresponding to the USART Rx FIFO. All other values of IER[3:1] not listed below are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1   - Receive Line Status (RLS).</description>
                <name>1_RECEIVE_LINE_S</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2a - Receive Data Available (RDA).</description>
                <name>2A__RECEIVE_DATA_AV</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2b - Character Time-out Indicator (CTI).</description>
                <name>2B__CHARACTER_TIME_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3   - THRE Interrupt.</description>
                <name>3_THRE_INTERRUPT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4   - Modem status</description>
                <name>4_MODEM_STATUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>These bits are equivalent to FCR[0].</description>
            <name>FIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled.</description>
            <name>ABEOINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled.</description>
            <name>ABTOINT</name>
          </field>
        </fields>
        <name>IIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>FIFO Control Register. Controls USART FIFO usage and modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FIFO enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>USART FIFOs are disabled. Must not be used in the application.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high enable for both USART Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper USART operation. Any transition on this bit will automatically clear the USART FIFOs.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX FIFO Reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No impact on either of USART FIFOs.</description>
                <name>NO_IMPACT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Writing a logic 1 to FCR[1] will clear all bytes in USART Rx FIFO, reset the pointer logic. This bit is self-clearing.</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXFIFORES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX FIFO Reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No impact on either of USART FIFOs.</description>
                <name>NO_IMPACT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Writing a logic 1 to FCR[2] will clear all bytes in USART TX FIFO, reset the pointer logic. This bit is self-clearing.</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXFIFORES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>RX Trigger Level. These two bits determine how many receiver USART FIFO characters must be written before an interrupt is activated.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Trigger level 0 (1 character or 0x01).</description>
                <name>TRIGGER_LEVEL_0_1_C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Trigger level 1 (4 characters or 0x04).</description>
                <name>TRIGGER_LEVEL_1_4_C</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Trigger level 2 (8 characters or 0x08).</description>
                <name>TRIGGER_LEVEL_2_8_C</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Trigger level 3 (14 characters or 0x0E).</description>
                <name>TRIGGER_LEVEL_3_14_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXTL</name>
          </field>
        </fields>
        <name>FCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Line Control Register. Contains controls for frame formatting and break generation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Word Length Select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>5-bit character length.</description>
                <name>5_BIT_CHARACTER_LENG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6-bit character length.</description>
                <name>6_BIT_CHARACTER_LENG</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7-bit character length.</description>
                <name>7_BIT_CHARACTER_LENG</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit character length.</description>
                <name>8_BIT_CHARACTER_LENG</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WLS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop Bit Select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits (1.5 if LCR[1:0]=00).</description>
                <name>2_STOP_BITS_1_5_IF_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SBS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable parity generation and checking.</description>
                <name>DISABLE_PARITY_GENER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable parity generation and checking.</description>
                <name>ENABLE_PARITY_GENERA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Parity Select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.</description>
                <name>ODD_PARITY_NUMBER_O</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.</description>
                <name>EVEN_PARITY_NUMBER_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Forced 1 stick parity.</description>
                <name>FORCED_1_STICK_PARIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Forced 0 stick parity.</description>
                <name>FORCED_0_STICK_PARIT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable break transmission.</description>
                <name>DISABLE_BREAK_TRANSM</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable break transmission. Output pin USART TXD is forced to logic 0 when LCR[6] is active high.</description>
                <name>ENABLE_BREAK_TRANSMI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divisor Latch Access Bit</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable access to Divisor Latches.</description>
                <name>DISABLE_ACCESS_TO_DI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable access to Divisor Latches.</description>
                <name>ENABLE_ACCESS_TO_DIV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DLAB</name>
          </field>
        </fields>
        <name>LCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Modem Control Register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source for modem output pin DTR. This bit reads as 0 when modem loopback mode is active.</description>
            <name>DTRCTRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active.</description>
            <name>RTSCTRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD, has no effect on loopback and output pin, TXD is held in marking state. The DSR, CTS, DCD, and RI pins are ignored. Externally, DTR and  RTS are set inactive. Internally, the upper four bits of the MSR are driven by the lower four bits of the MCR. This permits modem status interrupts to be generated in loopback mode by writing the lower four bits of MCR.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable modem loopback mode.</description>
                <name>DISABLE_MODEM_LOOPBA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable modem loopback mode.</description>
                <name>ENABLE_MODEM_LOOPBAC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LMS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable auto-rts flow control.</description>
                <name>DISABLE_AUTO_RTS_FLO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable auto-rts flow control.</description>
                <name>ENABLE_AUTO_RTS_FLOW</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable auto-cts flow control.</description>
                <name>DISABLE_AUTO_CTS_FLO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable auto-cts flow control.</description>
                <name>ENABLE_AUTO_CTS_FLOW</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Line Status Register. Contains flags for transmit and receive status, including line errors.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Data Ready:LSR[0] is set when the RBR holds an unread character and is cleared when the USART RBR FIFO is empty.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>RBR is empty.</description>
                <name>RBR_IS_EMPTY_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RBR contains valid data.</description>
                <name>RBR_CONTAINS_VALID_D</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error. The overrun error condition is set as soon as it occurs. A LSR read clears LSR[1]. LSR[1] is set when USART RSR has a new character assembled and the USART RBR FIFO is full. In this case, the USART RBR FIFO will not be overwritten and the character in the USART RSR will be lost.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Overrun error status is inactive.</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Overrun error status is active.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. A LSR read clears LSR[2]. Time of parity error detection is dependent on FCR[0]. Note: A parity error is associated with the character at the top of the USART RBR FIFO.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Parity error status is inactive.</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Parity error status is active.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. A LSR read clears LSR[3]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to re-synchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the USART RBR FIFO.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Framing error status is inactive.</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Framing error status is active.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Interrupt. When RXD1 is held in the spacing state (all zeros) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). A LSR read clears this status bit. The time of break detection is dependent on FCR[0]. Note: The break interrupt is associated with the character at the top of the USART RBR FIFO.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Break interrupt status is inactive.</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Break interrupt status is active.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BI</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty USART THR and is cleared on a THR write.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>THR contains valid data.</description>
                <name>THR_CONTAINS_VALID_D</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>THR is empty.</description>
                <name>THR_IS_EMPTY_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>THRE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>THR and/or the TSR contains valid data.</description>
                <name>VALID_D</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>THR and the TSR are empty.</description>
                <name>EMPTY</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TEMT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the USART FIFO.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>RBR contains no USART RX errors or FCR[0]=0.</description>
                <name>NO_ERROR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>USART RBR contains at least one USART RX error.</description>
                <name>ERRO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXFE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Error. In smart card T=0 operation, this bit is set when the smart card has NACKed a transmitted character, one more than the number of times indicated by the TXRETRY field.</description>
            <name>TXERR</name>
          </field>
        </fields>
        <name>LSR</name>
        <readAction>modify</readAction>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x60</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Modem Status Register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Delta CTS. Set upon state change of input CTS. Cleared on an MSR read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change detected on modem input, CTS.</description>
                <name>NO_CHANGE_DETECTED_O</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>State change detected on modem input, CTS.</description>
                <name>STATE_CHANGE_DETECTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DCTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Delta DSR. Set upon state change of input DSR. Cleared on an MSR read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change detected on modem input, DSR.</description>
                <name>NO_CHANGE_DETECTED_O</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>State change detected on modem input, DSR.</description>
                <name>STATE_CHANGE_DETECTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DDSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trailing Edge RI. Set upon low to high transition of input RI. Cleared on an MSR read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change detected on modem input, RI.</description>
                <name>NO_CHANGE_DETECTED_O</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low-to-high transition detected on RI.</description>
                <name>LOW_TO_HIGH_TRANSITI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TERI</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Delta DCD. Set upon state change of input DCD. Cleared on an MSR read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change detected on modem input, DCD.</description>
                <name>NO_CHANGE_DETECTED_O</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>State change detected on modem input, DCD.</description>
                <name>STATE_CHANGE_DETECTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DDCD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear To Send State. Complement of input signal CTS. This bit is connected to MCR[1] in modem loopback mode.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Set Ready State. Complement of input signal DSR. This bit is connected to MCR[0] in modem loopback mode.</description>
            <name>DSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ring Indicator State. Complement of input RI. This bit is connected to MCR[2] in modem loopback mode.</description>
            <name>RI</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Carrier Detect State. Complement of input DCD. This bit is connected to MCR[3] in modem loopback mode.</description>
            <name>DCD</name>
          </field>
        </fields>
        <name>MSR</name>
        <readAction>modify</readAction>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Scratch Pad Register. Eight-bit temporary storage for software.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>A readable, writable byte.</description>
            <name>PAD</name>
          </field>
        </fields>
        <name>SCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Auto-baud Control Register. Contains controls for the auto-baud feature.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is automatically cleared after auto-baud completion.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-baud stop (auto-baud is not running).</description>
                <name>AUTO_BAUD_STOP_AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.</description>
                <name>AUTO_BAUD_START_AUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud mode select bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mode 0.</description>
                <name>MODE_0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mode 1.</description>
                <name>MODE_1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No restart</description>
                <name>NO_RESTART</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Restart in case of time-out (counter restarts at next USART Rx falling edge)</description>
                <name>RESTART_IN_CASE_OF_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTORESTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of auto-baud interrupt clear bit (write only accessible).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Writing a 0 has no impact.</description>
                <name>NO_IMPACT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Writing a 1 will clear the corresponding interrupt in the IIR.</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ABEOINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud time-out interrupt clear bit (write only accessible).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Writing a 0 has no impact.</description>
                <name>NO_IMPACT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Writing a 1 will clear the corresponding interrupt in the IIR.</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ABTOINTCLR</name>
          </field>
        </fields>
        <name>ACR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>IrDA Control Register. Enables and configures the IrDA (remote control) mode.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IrDA mode enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA mode is disabled, USARTn acts as a standard USART.</description>
                <name>IRDA_MODE_IS_DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA mode is enabled.</description>
                <name>IRDA_MODE_IS_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRDAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Serial input inverter</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The serial input is not inverted.</description>
                <name>INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The serial input is inverted. This has no effect on the serial output.</description>
                <name>NOT_INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRDAINV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IrDA fixed pulse width mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA fixed pulse width mode disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA fixed pulse width mode enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FIXPULSEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Configures the pulse width when FixPulseEn = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 / (16 x baud rate)</description>
                <name>3_DIV_16_X_BAUD_RATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x TPCLK</description>
                <name>2_X_TPCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x TPCLK</description>
                <name>4_X_TPCLK</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 x TPCLK</description>
                <name>8_X_TPCLK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16 x TPCLK</description>
                <name>16_X_TPCLK</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32 x TPCLK</description>
                <name>32_X_TPCLK</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>64 x TPCLK</description>
                <name>64_X_TPCLK</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>128 x TPCLK</description>
                <name>128_X_TPCLK</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PULSEDIV</name>
          </field>
        </fields>
        <name>ICR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Fractional Divider Register. Generates a clock input for the baud rate divider.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the USART baud rate.</description>
            <name>DIVADDVAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for USART to operate properly, regardless of whether the fractional baud rate generator is used or not.</description>
            <name>MULVAL</name>
          </field>
        </fields>
        <name>FDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x10</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Oversampling Register. Controls the degree of oversampling during each bit time.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Fractional part of the oversampling ratio, in units of 1/8th of an input clock period. (001 = 0.125, ..., 111 = 0.875)</description>
            <name>OSFRAC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Integer part of the oversampling ratio, minus 1. The reset values equate to the normal operating mode of 16 input clocks per bit time.</description>
            <name>OSINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>In Smart Card mode, these bits act as a more-significant extension of the OSint field, allowing an oversampling ratio up to 2048 as required by ISO7816-3. In Smart Card mode, bits 14:4 should initially be set to 371, yielding an oversampling ratio of 372.</description>
            <name>FDINT</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Transmit Enable Register. Turns off USART transmitter for use with software flow control.</description>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character.</description>
            <name>TXEN</name>
          </field>
        </fields>
        <name>TER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Half duplex enable register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Half-duplex mode enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable half-duplex mode.</description>
                <name>DISABLE_HALF_DUPLEX_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable half-duplex mode.</description>
                <name>ENABLE_HALF_DUPLEX_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HDEN</name>
          </field>
        </fields>
        <name>HDEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Smart Card Interface Control register. Enables and configures the Smart Card Interface feature.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Smart Card Interface Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Smart card interface disabled.</description>
                <name>SMART_CARD_INTERFACE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous half duplex smart card interface is enabled.</description>
                <name>ASYNCHRONOUS_HALF_DU</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCIEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>NACK response disable. Only applicable in T=0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>A NACK response is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>A NACK response is inhibited.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NACKDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Protocol selection as defined in the ISO7816-3 standard.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>T = 0</description>
                <name>T_EQ_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>T = 1</description>
                <name>T_EQ_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>When the protocol selection T bit (above) is 0, the field controls the maximum number of retransmissions that the USART will attempt if the remote device signals NACK. When NACK has occurred this number of times plus one, the Tx Error bit in the LSR is set, an interrupt is requested if enabled, and the USART is locked until the FIFO is cleared.</description>
            <name>TXRETRY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>When the protocol selection T bit (above) is 0, this field indicates the number of bit times (ETUs) by which the guard time after a character transmitted by the USART should exceed the nominal 2 bit times. 0xFF in this field may indicate that there is just a single bit after a character and 11 bit times/character</description>
            <name>XTRAGUARD</name>
          </field>
        </fields>
        <name>SCICTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>NMM enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NMMEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The receiver is enabled.</description>
                <name>THE_RECEIVER_IS_ENAB</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The receiver is disabled.</description>
                <name>THE_RECEIVER_IS_DISA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>AAD enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto Address Detect (AAD) is disabled.</description>
                <name>AUTO_ADDRESS_DETECT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto Address Detect (AAD) is enabled.</description>
                <name>AUTO_ADDRESS_DETECT_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AADEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select direction control pin</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control.</description>
                <name>RTS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control.</description>
                <name>DTR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto direction control enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable Auto Direction Control.</description>
                <name>DISABLE_AUTO_DIRECTI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable Auto Direction Control.</description>
                <name>ENABLE_AUTO_DIRECTIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DCTRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity control. This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OINV</name>
          </field>
        </fields>
        <name>RS485CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Contains the address match value.</description>
            <name>ADRMATCH</name>
          </field>
        </fields>
        <name>RS485ADRMATCH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>RS-485/EIA-485 direction control delay.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter.</description>
            <name>DLY</name>
          </field>
        </fields>
        <name>RS485DLY</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Synchronous mode control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock source select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous slave mode (SCLK in)</description>
                <name>SYNCHRONOUS_SLAVE_MO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous master mode (SCLK out)</description>
                <name>SYNCHRONOUS_MASTER_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CSRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge sampling.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>RxD is sampled on the rising edge of SCLK </description>
                <name>RISING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RxD is sampled on the falling edge of SCLK</description>
                <name>FALLING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit synchronization bypass in synchronous slave mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The input clock is synchronized prior to being used in clock edge detection logic</description>
                <name>SYNC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability.</description>
                <name>NOSYNC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TSBYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous master clock enable (used only when CSRC is 1)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SCLK cycles only when characters are being sent on TxD</description>
                <name>SCLK_CYCLES_ONLY_WHE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)</description>
                <name>SCLK_RUNS_CONTINUOUS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CSCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start/stop bits</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Send start and stop bits as in other modes.</description>
                <name>SEND_START_AND_STOP_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do not send start/stop bits.</description>
                <name>DO_NOT_SEND_STARTSTOP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous clock clear</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CSCEN is under software control.</description>
                <name>CSCEN_IS_UNDER_SOFTW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Hardware clears CSCEN after each character is received.</description>
                <name>HARDWARE_CLEARS_CSCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CCCLR</name>
          </field>
        </fields>
        <name>SYNCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4000C000</baseAddress>
    <description>16-bit counter/timers CT16B0</description>
    <groupName>CT16B0</groupName>
    <interrupts>
      <interrupt>
        <name>CT16B0</name>
        <value>0x10</value>
      </interrupt>
    </interrupts>
    <name>CT16B0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and Prescale Counter are enabled for counting.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Prescale value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Prescale counter value.</description>
            <name>PC</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0:  a sequence of 0 then 1 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0:: a sequence of 1 then 0 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1:  a sequence of 0 then 1 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1:: a sequence of 1 then 0 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2:  a sequence of 0 then 1 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT[1:0] and CT16B1_MAT[1:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of match channel 2. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output.</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output.</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of External Match 0. Table 267 shows the encoding of these bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode.  Increments every rising PCLK edge</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Moderising edge. . TC is incremented on rising edges on the CAP input selected by bits 3:2.</description>
                <name>RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge: TC is incremented on falling edges on the CAP input selected by bits 3:2.</description>
                <name>FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge: TC is incremented on both edges on the CAP input selected by bits 3:2.</description>
                <name>DUAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin is sampled for clocking. Value 0x3 isreserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 0.</description>
                <name>CAPTURE_CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 1.</description>
                <name>CAPTURE_CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 2.</description>
                <name>CAPTURE_CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of thesignal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0RISING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of thesignal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0FALLING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of thesignal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1RISING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of thesignal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1FALLING</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of thesignal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP2RISING</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of thesignal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP1FALLING</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT[1:0] and CT16B1_MAT[1:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT0 is controlled by EM0.</description>
                <name>EM0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT01 is controlled by EM1.</description>
                <name>EM1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT2 is controlled by EM2.</description>
                <name>EM2</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT3 is controlled by EM3.</description>
                <name>EM3</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40010000</baseAddress>
    <derivedFrom>CT16B0</derivedFrom>
    <description>16-bit counter/timers CT16B1</description>
    <groupName>CT16B0</groupName>
    <interrupts>
      <interrupt>
        <name>CT16B1</name>
        <value>0x11</value>
      </interrupt>
    </interrupts>
    <name>CT16B1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and Prescale Counter are enabled for counting.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Prescale value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Prescale counter value.</description>
            <name>PC</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0:  a sequence of 0 then 1 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0:: a sequence of 1 then 0 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1:  a sequence of 0 then 1 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1:: a sequence of 1 then 0 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2:  a sequence of 0 then 1 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and the external match pins CT16B0_MAT[1:0] and CT16B1_MAT[1:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of match channel 2. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output.</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output.</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of External Match 0. Table 267 shows the encoding of these bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the
                corresponding External Match bit/output to 0 (CT16Bn_MAT0 pin is
                LOW if pinned out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match bit/output to 1
                (CT16Bn_MAT0 pin is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding
                External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode.  Increments every rising PCLK edge</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Moderising edge. . TC is incremented on rising edges on the CAP input selected by bits 3:2.</description>
                <name>RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge: TC is incremented on falling edges on the CAP input selected by bits 3:2.</description>
                <name>FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge: TC is incremented on both edges on the CAP input selected by bits 3:2.</description>
                <name>DUAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin is sampled for clocking. Value 0x3 isreserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 0.</description>
                <name>CAPTURE_CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 1.</description>
                <name>CAPTURE_CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 2.</description>
                <name>CAPTURE_CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of thesignal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0RISING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of thesignal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0FALLING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of thesignal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1RISING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of thesignal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1FALLING</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of thesignal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP2RISING</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of thesignal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP1FALLING</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external match pins CT16B0_MAT[1:0] and CT16B1_MAT[1:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT0 is controlled by EM0.</description>
                <name>EM0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT01 is controlled by EM1.</description>
                <name>EM1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT2 is controlled by EM2.</description>
                <name>EM2</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT16Bn_MAT3 is controlled by EM3.</description>
                <name>EM3</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT16Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40014000</baseAddress>
    <description>32-bit counter/timers CT32B0</description>
    <groupName>CT32B0</groupName>
    <interrupts>
      <interrupt>
        <name>CT32B0</name>
        <value>0x12</value>
      </interrupt>
    </interrupts>
    <name>CT32B0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and Prescale Counter are enabled for counting.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescaler value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PC</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0:  a sequence of 0 then 1 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0:: a sequence of 1 then 0 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1:  a sequence of 0 then 1 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1:: a sequence of 1 then 0 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2:  a sequence of 0 then 1 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT[3:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT32B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT32B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT32B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. This bit is driven to the CT32B3_MAT0/CT32B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of External Match 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode. This field selects which rising PCLK edges can increment the Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode.  Increments every rising PCLK edge</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode rising edge.  TC is incremented on rising edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge. TC is incremented on falling edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge. TC is incremented on both edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_DUAL_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin is sampled for clocking. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 0.</description>
                <name>CAPTURE_CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 1.</description>
                <name>CAPTURE_CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 2.</description>
                <name>CAPTURE_CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of the signal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0RISING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of the signal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0FALLING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of the signal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1RISING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of the signal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1FALLING</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of the signal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP2RISING</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of the signal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP2FALLING</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT[3:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT0 is controlled by EM0.</description>
                <name>EM0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT32Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT01 is controlled by EM1.</description>
                <name>EM1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT32Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT2 is controlled by EM2.</description>
                <name>EM2</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT32Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT3 is controlled by EM3.</description>
                <name>EM3</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT132Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40018000</baseAddress>
    <derivedFrom>CT32B0</derivedFrom>
    <description>32-bit counter/timers CT32B1</description>
    <groupName>CT32B0</groupName>
    <interrupts>
      <interrupt>
        <name>CT32B1</name>
        <value>0x13</value>
      </interrupt>
    </interrupts>
    <name>CT32B1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and Prescale Counter are enabled for counting.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescaler value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PC</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0:  a sequence of 0 then 1 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0:: a sequence of 1 then 0 causes CR0 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1:  a sequence of 0 then 1 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1:: a sequence of 1 then 0 causes CR1 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2:  a sequence of 0 then 1 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0 causes CR2 to be loaded with the contents of TC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load  generates an interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CAP2I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and the external match pins CT32Bn_MAT[3:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT32B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT32B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT32B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. This bit is driven to the CT32B3_MAT0/CT32B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of External Match 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>NOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the corresponding
                External Match bit/output to 0 (CT32Bi_MAT0 pin is LOW if pinned
                out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set
                the corresponding External Match bit/output to 1 (CT32Bi_MAT0 pin
                is HIGH if pinned out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle the corresponding External Match bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode. This field selects which rising PCLK edges can increment the Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). If Counter mode is selected in the CTCR, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode.  Increments every rising PCLK edge</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode rising edge.  TC is incremented on rising edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge. TC is incremented on falling edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge. TC is incremented on both edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_DUAL_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin is sampled for clocking. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 0.</description>
                <name>CAPTURE_CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 1.</description>
                <name>CAPTURE_CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture channel 2.</description>
                <name>CAPTURE_CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of the signal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0RISING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of the signal on capture channel 0 clears the timer (if bit 4 is set).</description>
                <name>CAP0FALLING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of the signal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1RISING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of the signal on capture channel 1 clears the timer (if bit 4 is set).</description>
                <name>CAP1FALLING</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising Edge of the signal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP2RISING</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling Edge of the signal on capture channel 2 clears the timer (if bit 4 is set).</description>
                <name>CAP2FALLING</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external match pins CT32Bn_MAT[3:0].</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT0 is controlled by EM0.</description>
                <name>EM0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT32Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT01 is controlled by EM1.</description>
                <name>EM1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT32Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT2 is controlled by EM2.</description>
                <name>EM2</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT32Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CT32Bn_MAT3 is controlled by EM3.</description>
                <name>EM3</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM mode is enabled for CT132Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register. CR is loaded with the value of TC when there is an event on the CAP input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4001C000</baseAddress>
    <description>12-bit Analog-to-Digital Converter (ADC)</description>
    <groupName>ADC</groupName>
    <interrupts>
      <interrupt>
        <name>ADC_A</name>
        <value>0x18</value>
      </interrupt>
    </interrupts>
    <name>ADC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>A/D Control Register. Contains the clock divide value, enable bits for each sequence and the A/D power-down bit.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>The system clock is divided by this value plus one to produce the clock for the A/D converter, which should be less than or equal to 50 MHz (up to 100 MHz in 10-bit mode).  Typically, software should program the smallest value in this field that yields this maximum clock rate or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable.</description>
            <name>CLKDIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select low-power ADC mode. The analog circuitry is automatically powered-down when no conversions are taking place. When any (hardware or software) triggering event is detected, the analog circuitry is enabled. After the required start-up time, the requested conversion will be launched. Once the conversion completes, the analog-circuitry will again be powered-down provided no further conversions are pending. Using this mode can save an appreciable amount of current (approximately 2.5 mA) when conversions are required relatively infrequently. The penalty for using this mode is an approximately 15 ADC clock delay (30 clocks in 10-bit mode), based on the frequency specified in the CLKDIV field, from the time the trigger event occurs until sampling of the A/D input commences. This mode will NOT power-up the A/D if the ADC_ENA bit is low.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The low-power ADC mode is disabled.  The analog circuitry remains activated even when no conversions are requested.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The low-power ADC mode is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LPWRMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit initiates a self-calibration cycle. This bit will be automatically cleared by hardware after the calibration cycle is complete. Other bits of this register may be written to concurrently with setting this bit, however once this bit has been set no further writes to this register are permitted until the full calibration cycle has ended.</description>
            <name>CAL_MODE</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>A/D Conversion Sequence-A control Register: Controls triggering and channel selection for conversion sequence-A. Also specifies interrupt mode for sequence-A.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Selects which one or more of the twelve channels will be sampled and converted when this sequence is launched. A 1 in any bit of this field will cause the corresponding channel to be included in the conversion sequence, where bit 0 corresponds to channel 0, bit 1 to channel 1 and so forth.  When this conversion sequence is triggered, either by a hardware trigger or via software command, A/D conversions will be performed on each enabled channel, in sequence, beginning with the lowest-ordered channel.  This field can ONLY be changed while the SEQA_ENA bit (bit 31) is LOW. It is allowed to change this field and set bit 31 in the same write.</description>
            <name>CHANNELS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects which of the available hardware trigger sources will cause this conversion sequence to be initiated. Program the trigger input number in this field.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select the polarity of the selected input trigger for this conversion sequence.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Negative edge. A negative edge launches the conversion sequence on the selected trigger input.</description>
                <name>NEGATIVE_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Positive edge. A positive edge launches the conversion sequence on the selected trigger input.</description>
                <name>POSITIVE_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit allows the hardware trigger input to bypass  synchronization flip-flops stages and therefore shorten the time between the trigger input signal and the start of a conversion. There are slightly different criteria for whether or not this bit can be set depending on the clock operating mode: Synchronous mode: Synchronization may be bypassed (this bit may be set) if the selected trigger source is already synchronous with the main system clock (eg. coming from an on-chip, system-clock-based timer). Whether this bit is set or not, a trigger pulse must be maintained for at least one system clock period. Asynchronous mode: Synchronization may be bypassed (this bit may be set) if it is certain that the duration of a trigger input pulse will be at least one cycle of the ADC clock (regardless of whether the trigger comes from and on-chip or off-chip source). If this bit is NOT set, the trigger pulse must at least be maintained for one system clock period.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable synchronization. The hardware trigger bypass is not enabled.</description>
                <name>ENABLE_SYNCHRONIZATI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass synchronization. The hardware trigger bypass is enabled.</description>
                <name>BYPASS_SYNCHRONIZATI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCBYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this field will launch one pass through this conversion sequence. The behavior will be identical to a sequence triggered by a hardware trigger. Do not write 1 to this bit if the BURST bit is set. This bit is only set to a 1 momentarily when written-to to launch a conversion sequence. It will consequently always read-back as a zero.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit will cause this conversion sequence to be continuously cycled through. Other sequence A triggers will be ignored while this bit is set. Repeated conversions can be halted by clearing this bit. The sequence currently in progress will be completed before conversions are terminated.</description>
            <name>BURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is set, a hardware trigger or a write to the START bit will launch a single conversion on the next channel in the sequence instead of the default response of launching an entire sequence of conversions. Once all of the channels comprising a sequence have been converted, a subsequent trigger will repeat the sequence beginning with the first enabled channel. Interrupt generation will still occur either after each individual conversion or at the end of the entire sequence, depending on the state of the MODE bit.</description>
            <name>SINGLESTEP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set priority for sequence A.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low priority. Any B trigger which occurs while an A conversion sequence is active will be ignored and lost.</description>
                <name>LOW_PRIORITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High priority.  Setting this bit to a 1 will permit any enabled B sequence trigger (including a B sequence software start) to immediately interrupt this sequence and launch a B sequence in it's place. The conversion currently in progress will be terminated.  The A sequence that was interrupted will automatically resume after the B sequence completes. The channel whose conversion was terminated will be re-sampled and the conversion sequence will resume from that point.</description>
                <name>HIGH_PRIORITY</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOWPRIO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the primary method for retrieving conversion results for this sequence will be accomplished via reading the global data register (SEQA_GDAT) at the end of each conversion, or the individual channel result registers at the end of the entire sequence.  Impacts when conversion-complete interrupt/DMA requests for sequence-A will be generated and which overrun conditions contribute to an overrun interrupt as described below:</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of conversion. The sequence A interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence A. This flag will mirror the DATAVALID bit in the SEQA_GDAT register. The OVERRUN bit in the SEQA_GDAT register will contribute to generation of an overrun interrupt/DMA request if enabled.</description>
                <name>END_OF_CONVERSION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of sequence. The sequence A interrupt/DMA flag will be set when the entire set of sequence-A conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode.  The OVERRUN bit in the SEQA_GDAT register will NOT contribute to generation of an overrun interrupt/DMA request since it is assumed this register may not be utilized in this mode.</description>
                <name>END_OF_SEQUENCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence Enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Sequence A is disabled. Sequence A triggers are ignored. If this bit is cleared while sequence A is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Sequence A is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQA_ENA</name>
          </field>
        </fields>
        <name>SEQA_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>A/D Conversion Sequence-B Control Register: Controls triggering and channel selection for conversion sequence-B. Also specifies interrupt mode for sequence-B.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Selects which one or more of the twelve channels will be sampled and converted when this sequence is launched. A 1 in any bit of this field will cause the corresponding channel to be included in the conversion sequence, where bit 0 corresponds to channel 0, bit 1 to channel 1 and so forth.  When this conversion sequence is triggered, either by a hardware trigger or via software command, A/D conversions will be performed on each enabled channel, in sequence, beginning with the lowest-ordered channel. This field can ONLY be changed while the SEQB_ENA bit (bit 31) is LOW. It is permissible to change this field and set bit 31 in the same write.</description>
            <name>CHANNELS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects which of the available hardware trigger sources will cause this conversion sequence to be initiated. Program the trigger input number in this field.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select the polarity of the selected input trigger for this conversion sequence.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Negative edge. A negative edge launches the conversion sequence on the selected trigger input.</description>
                <name>NEGATIVE_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Positive edge. A positive edge launches the conversion sequence on the selected trigger input.</description>
                <name>POSITIVE_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit allows the hardware trigger input to bypass  synchronization flip-flops stages and therefore shorten the time between the trigger input signal and the start of a conversion. There are slightly different criteria for whether or not this bit can be set depending on the clock operating mode: Synchronous mode: Synchronization may be bypassed (this bit may be set) if the selected trigger source is already synchronous with the main system clock (eg. coming from an on-chip, system-clock-based timer). Whether this bit is set or not, a trigger pulse must be maintained for at least one system clock period. Asynchronous mode: Synchronization may be bypassed (this bit may be set) if it is certain that the duration of a trigger input pulse will be at least one cycle of the ADC clock (regardless of whether the trigger comes from and on-chip or off-chip source). If this bit is NOT set, the trigger pulse must at least be maintained for one system clock period.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable synchronization. The hardware trigger bypass is not enabled.</description>
                <name>ENABLE_SYNCHRONIZATI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass synchronization. The hardware trigger bypass is enabled.</description>
                <name>BYPASS_SYNCHRONIZATI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCBYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this field will launch one pass through this conversion sequence. The behavior will be identical to a sequence triggered by a hardware trigger. Do not write a 1 to this bit if the BURST bit is set.   This bit is only set to a 1 momentarily when written-to to launch a conversion sequence. It will consequently always read-back as a zero.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit will cause this conversion sequence to be continuously cycled through. Other B triggers will be ignored while this bit is set.  Repeated conversions can be halted by clearing this bit. The sequence currently in progress will be completed before conversions are terminated.</description>
            <name>BURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is set, a hardware trigger or a write to the START bit will launch a single conversion on the next channel in the sequence instead of the default response of launching an entire sequence of conversions. Once all of the channels comprising a sequence have been converted, a subsequent trigger will repeat the sequence beginning with the first enabled channel.  Interrupt generation will still occur either after each individual conversion or at the end of the entire sequence, depending on the state of the MODE bit.</description>
            <name>SINGLESTEP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the primary method for retrieving conversion results for this sequence will be accomplished via reading the global data register (SEQB_GDAT) at the end of each conversion, or the individual channel result registers at the end of the entire sequence.   Impacts when conversion-complete interrupt/DMA requests for sequence-B will be generated and which overrun conditions contribute to an overrun interrupt as described below:</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of conversion. The sequence B interrupt/DMA flag will be set at the end of each individual A/D conversion performed under sequence B. This flag will mirror the DATAVALID bit in the SEQB_GDAT register.  The OVERRUN bit in the SEQB_GDAT register will contribute to generation of an overrun interrupt/DMA request if enabled.</description>
                <name>END_OF_CONVERSION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of sequence. The sequence B interrupt/DMA flag will be set when the entire set of sequence B conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode.   The OVERRUN bit in the SEQB_GDAT register will NOT contribute to generation of an overrun interrupt/DMA request since it is assumed this register will not be utilized in this mode.</description>
                <name>END_OF_SEQUENCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence Enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Sequence B is disabled. Sequence B triggers are ignored. If this bit is cleared while sequence B is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Sequence B is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQB_ENA</name>
          </field>
        </fields>
        <name>SEQB_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>A/D Sequence-A Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-A</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the most recent conversion performed under conversion sequence associated with this register.   The result is the  a binary fraction representing the voltage on the currently-selected input channel as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.  DATAVALID = 1 indicates that this result has not yet been read.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion performed was above, below or within the range established by the designated threshold comparison registers (THRn_LOW and THRn_HIGH).</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion performed represented a crossing of the threshold level established by the designated LOW threshold comparison register (THRn_LOW) and, if so, in what direction the crossing occurred.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits contain the channel from which the RESULT bits were converted (e.g. 0000 identifies channel 0, 0001 channel 1...).</description>
            <name>CHN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read.  This bit will contribute to an overrun interrupt request if the MODE bit (in SEQA_CTRL) for the corresponding sequence is set to '0' (and if the overrun interrupt is enabled).</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to '1' at the end of each conversion when a new result is loaded into the RESULT field. It is cleared whenever this register is read.  This bit will cause a conversion-complete interrupt for the corresponding sequence if the MODE bit (in SEQA_CTRL) for that sequence is set to 0 (and if the interrupt is enabled).</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>SEQA_GDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>A/D Sequence-B Global Data Register. This register contains the result of the most recent A/D conversion performed under sequence-B</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the most recent conversion performed under conversion sequence associated with this register.   This will be a binary fraction representing the voltage on the currently-selected input channel as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on V REFP.  DATAVALID = 1 indicates that this result has not yet been read.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion performed was above, below or within the range established by the designated threshold comparison registers (THRn_LOW and THRn_HIGH).  Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion performed represented a crossing of the threshold level established by the designated LOW threshold comparison register (THRn_LOW) and, if so, in what direction the crossing occurred. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits contain the channel from which the RESULT bits were converted (e.g. 0b0000 identifies channel 0, 0b0001 channel 1...).</description>
            <name>CHN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read.  This bit will contribute to an overrun interrupt request if the MODE bit (in SEQB_CTRL) for the corresponding sequence is set to 0 (and if the overrun interrupt is enabled).</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 at the end of each conversion when a new result is loaded into the RESULT field. It is cleared whenever this register is read.  This bit will cause a conversion-complete interrupt for the corresponding sequence if the MODE bit (in SEQB_CTRL) for that sequence is set to 0 (and if the interrupt is enabled).</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>SEQB_GDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>A/D Low Compare Threshold Register 0 : Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Low threshold value against which A/D results will be compared</description>
            <name>THRLOW</name>
          </field>
        </fields>
        <name>THR0_LOW</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>A/D Low Compare Threshold Register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Low threshold value against which A/D results will be compared</description>
            <name>THRLOW</name>
          </field>
        </fields>
        <name>THR1_LOW</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>A/D High Compare Threshold Register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>High threshold value against which A/D results will be compared</description>
            <name>THRHIGH</name>
          </field>
        </fields>
        <name>THR0_HIGH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>A/D High Compare Threshold Register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>High threshold value against which A/D results will be compared</description>
            <name>THRHIGH</name>
          </field>
        </fields>
        <name>THR1_HIGH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x60</addressOffset>
        <description>A/D Channel-Threshold Select Register. Specifies which set of threshold compare registers are to be used for each channel</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 0 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 0 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH0_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 1 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 1 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH1_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 2 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 2 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH2_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 3 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 3 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH3_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 4 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 4 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH4_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 5 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 5 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH5_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 6 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 6 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH6_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 7 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 7 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH7_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 8 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 8 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH8_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 9 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 9 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH9_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 10 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 10 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH10_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select by channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Channel 11 results will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers</description>
                <name>THRESHOLD_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Channel 11 results will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers</description>
                <name>THRESHOLD_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH11_THRSEL</name>
          </field>
        </fields>
        <name>CHAN_THRSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x64</addressOffset>
        <description>A/D Interrupt Enable Register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence A interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The sequence A interrupt/DMA request is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The sequence A interrupt/DMA request is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence A, or upon completion of the entire A sequence of conversions, depending on the MODE bit in the SEQA_CTRL register.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQA_INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence B interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The sequence B interrupt/DMA request is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The sequence B interrupt/DMA request is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence B, or upon completion of the entire B sequence of conversions, depending on the MODE bit in the SEQB_CTRL register.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQB_INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The overrun interrupt is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The overrun interrupt is enabled. Detection of an overrun condition on any of the 12 channel data registers will cause an overrun interrupt request. In addition, if the MODE bit for a particular sequence is 0, then an overrun in the global data register for that sequence will also cause this interrupt request to be asserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OVR_INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN11</name>
          </field>
        </fields>
        <name>INTEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>A/D Flags Register. Contains the four interrupt request flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers).</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 0. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 1. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 2. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 3. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 4. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 5. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 6. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 7. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 8. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 9. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 10. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 11. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
            <name>THCMP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 0</description>
            <name>OVERRUN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 1</description>
            <name>OVERRUN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 2</description>
            <name>OVERRUN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 3</description>
            <name>OVERRUN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 4</description>
            <name>OVERRUN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 5</description>
            <name>OVERRUN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 6</description>
            <name>OVERRUN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 7</description>
            <name>OVERRUN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 8</description>
            <name>OVERRUN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 9</description>
            <name>OVERRUN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 10</description>
            <name>OVERRUN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register for A/D channel 11</description>
            <name>OVERRUN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the global OVERRUN status flag in the SEQA_GDAT register</description>
            <name>SEQA_OVR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the global OVERRUN status flag in the SEQB_GDAT register</description>
            <name>SEQB_OVR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence A interrupt/DMA flag. If the MODE bit in the SEQA_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQA_GDAT), which is set at the end of every A/D conversion performed as part of sequence A. It will be cleared automatically when the SEQA_GDAT register is read. If the MODE bit in the SEQA_CTRL register is 1, this flag will be set upon completion of an entire A sequence. In this case it must be cleared by writing a 1 to this SEQA_INT bit.  This interrupt must be enabled in the INTEN register.</description>
            <name>SEQA_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence A interrupt/DMA flag. If the MODE bit in the SEQB_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQB_GDAT), which is set at the end of every A/D conversion performed as part of sequence B. It will be cleared automatically when the SEQB_GDAT register is read. If the MODE bit in the SEQB_CTRL register is 1, this flag will be set upon completion of an entire B sequence. In this case it must be cleared by writing a 1 to this SEQB_INT bit.  This interrupt must be enabled in the INTEN register.</description>
            <name>SEQB_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold Comparison Interrupt/DMA flag. This bit will be set if any of the 12 THCMP flags in the lower bits of this register are set to 1 (due to an enabled out-of-range or threshold-crossing event on any channel). Each type of threshold comparison interrupt on each channel must be individually enabled in the INTEN register to cause this interrupt. This bit will be cleared when all of the component flags in bits 11:0 are cleared via writing 1s to those bits.</description>
            <name>THCMP_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Interrupt flag. Any overrun bit in any of the individual channel data registers will cause this interrupt. In addition, if the MODE bit in either of the SEQn_CTRL registers is 0 then the OVERRUN bit in the corresponding SEQn_GDAT register will also cause this interrupt.  This interrupt must be enabled in the INTEN register. This bit will be cleared when all of the individual overrun bits have been cleared via reading the corresponding data registers.</description>
            <name>OVR_INT</name>
          </field>
        </fields>
        <name>FLAGS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>ADC trim register.</description>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>High voltage. VDDA = 2.7 V to 3.6 V.</description>
                <name>HIGH_VOLTAGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low voltage. VDDA = 1.8 V to 2.7 V.</description>
                <name>LOW_VOLTAGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VRANGE</name>
          </field>
        </fields>
        <name>TRM</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF00</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[3]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[4]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[5]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[6]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3C</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[7]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x40</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[8]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x44</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[9]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[10]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.</description>
        <displayName>DAT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit A/D conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt request to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an A/D conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT[11]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40020000</baseAddress>
    <derivedFrom>I2C0</derivedFrom>
    <description>I2C1</description>
    <groupName>I2C0</groupName>
    <interrupts>
      <interrupt>
        <name>I2C1</name>
        <value>0xA</value>
      </interrupt>
    </interrupts>
    <name>I2C1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.</description>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Assert acknowledge flag.</description>
            <name>AA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interrupt flag.</description>
            <name>SI</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP flag.</description>
            <name>STO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>START flag.</description>
            <name>STA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interface enable.</description>
            <name>I2EN</name>
          </field>
        </fields>
        <name>CONSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>These bits give the actual status information about the I2C interface.</description>
            <name>Status</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This register holds data values that have been received or are to be transmitted.</description>
            <name>Data</name>
          </field>
        </fields>
        <name>DAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Count for SCL HIGH time period selection.</description>
            <name>SCLH</name>
          </field>
        </fields>
        <name>SCLH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Count for SCL low time period selection.</description>
            <name>SCLL</name>
          </field>
        </fields>
        <name>SCLL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x18</addressOffset>
        <description>I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.</description>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Assert acknowledge Clear bit.</description>
            <name>AAC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interrupt Clear bit.</description>
            <name>SIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>START flag Clear bit.</description>
            <name>STAC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C interface Disable bit.</description>
            <name>I2ENC</name>
          </field>
        </fields>
        <name>CONCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Monitor mode control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Monitor mode disabled.</description>
                <name>MONITOR_MODE_DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The I2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I 2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line.</description>
                <name>THE_I2C_MODULE_WILL_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MM_ENA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL output enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line.</description>
                <name>HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]</description>
                <name>NORMAL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA_SCL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select interrupt register match.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus.</description>
                <name>ANYADDRESS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MATCH_ALL</name>
          </field>
        </fields>
        <name>MMCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This register holds contents of the 8 MSBs of the DAT shift register.</description>
            <name>Data</name>
          </field>
        </fields>
        <name>DATA_BUFFER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call enable bit.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>The I2C device address for slave mode.</description>
            <name>Address</name>
          </field>
        </fields>
        <name>ADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>I2C Slave address mask register. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Mask bits.</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>MASK3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40024000</baseAddress>
    <description>Real-Time Clock (RTC)</description>
    <groupName>RTC</groupName>
    <interrupts>
      <interrupt>
        <name>RTC</name>
        <value>0x19</value>
      </interrupt>
    </interrupts>
    <name>RTC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>RTC control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not in reset. The RTC is not held in reset. This bit must be cleared prior to configuring or initiating any operation of the RTC.</description>
                <name>NOT_IN_RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>In reset. The RTC is held in reset.     All register bits within the RTC will be forced to their reset value except the OFD bit. This bit must be cleared before writing to any register in the RTC - including writes to set any of the other bits within this register.   Do not attempt to write to any bits of this register at the same time that the reset bit is being cleared. This bit may also serve as a Power Fail Detect flag for the always-on voltage domain.</description>
                <name>IN_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWRESET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Oscillator fail detect status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Run. The RTC oscillator is running properly. Writing a 0 has no effect.</description>
                <name>RUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fail. RTC oscillator fail detected. Clear this flag after the following power-up. Writing a 1 clears this bit.</description>
                <name>FAIL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OFD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 Hz timer alarm flag status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No match. No match has occurred on the 1 Hz RTC timer. Writing a 0 has no effect.</description>
                <name>NO_MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. A match condition has occurred on the 1 Hz RTC timer. This flag generates an RTC alarm interrupt request RTC_ALARM which can also wake up the part from any low power mode. Writing a 1 clears this bit.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ALARM1HZ</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 kHz timer wake-up flag status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Run. The RTC 1 kHz timer is running. Writing a 0 has no effect.</description>
                <name>RUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Time-out. The 1 kHz high-resolution/wake-up timer has timed out. This flag generates an RTC wake-up interrupt request RTC-WAKE which can also wake up the part from any low power mode. Writing a 1 clears this bit.</description>
                <name>TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKE1KHZ</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 Hz timer alarm enable for Deep power-down.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. A match on the 1 Hz RTC timer will not bring the part out of Deep power-down mode.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. A match on the 1 Hz RTC timer bring the part out of Deep power-down mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ALARMDPD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 kHz timer wake-up enable for Deep power-down.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. A match on the 1 kHz RTC timer will not bring the part out of Deep power-down mode.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. A match on the 1 kHz RTC timer bring the part out of Deep power-down mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKEDPD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 kHz clock enable.  This bit can be set to 0 to conserve power if the 1 kHz timer is not used. This bit has no effect when the RTC is disabled (bit 7 of this register is 0).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. A match on the 1 kHz RTC timer will not bring the part out of Deep power-down mode.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. The 1 kHz RTC timer is enabled.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTC1KHZ_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. The RTC 1 Hz and 1 kHz clocks are shut down and the RTC operation is disabled. This bit should be 0 when writing to load a value in the RTC counter register.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. The 1 Hz RTC clock is running and RTC operation is enabled. You must set this bit to initiate operation of the RTC. The first clock to the RTC counter occurs 1 s after this bit is set. To also enable the high-resolution, 1 kHz clock, set bit 6 in this register.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTC_EN</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>RTC match register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Contains the match value against which the 1 Hz RTC timer will be compared to generate set the alarm flag RTC_ALARM and generate an alarm interrupt/wake-up if enabled.</description>
            <name>MATVAL</name>
          </field>
        </fields>
        <name>MATCH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>RTC counter register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>A read reflects the current value of the main, 1 Hz RTC timer. A write loads a new initial value into the timer.  The RTC counter will count up continuously at a 1 Hz rate once the RTC Software Reset is removed (by clearing bit 0 of the CTRL register). Only write to this register when the RTC1HZ_EN bit in the RTC CTRL Register is 0. The counter increments one second after the RTC1HZ_EN bit is set.</description>
            <name>VAL</name>
          </field>
        </fields>
        <name>COUNT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>RTC high-resolution/wake-up timer control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A read reflects the current value of the high-resolution/wake-up timer. A write pre-loads a start count value into the wake-up timer and initializes a count-down sequence.   Do not write to this register while counting is in progress.</description>
            <name>VAL</name>
          </field>
        </fields>
        <name>WAKE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40028000</baseAddress>
    <description>DMA controller</description>
    <groupName>DMATRIGMUX</groupName>
    <interrupts></interrupts>
    <name>DMATRIGMUX</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[8]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[9]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[10]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[11]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[12]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[13]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[14]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>Trigger input select register for DMA channel 0.</description>
        <displayName>DMA_ITRIG_PINMUX[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) to DMA channel n. All other values are reserved.  0	 = ADC0_SEQA_IRQ 1 = 	ADC0_SEQB_IRQ 2	 = CT16B0_MAT0 3 = 	CT16B1_MAT0 4	 = CT32B0_MAT0 5	 = CT16B1_MAT0 6	 = PINT0 ( pin interrupt 0) 7 = 	PINT1 (pin interrupt1 ) 8 = 	SCT0_DMA0 9 = 	SCT0_DMA1 10	 = SCT1_DMA0 11	 = SCT1_DMA1</description>
            <name>INP_N</name>
          </field>
        </fields>
        <name>DMA_ITRIG_PINMUX[15]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40038000</baseAddress>
    <description>Power Management Unit (PMU)</description>
    <groupName>PMU</groupName>
    <interrupts></interrupts>
    <name>PMU</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Power control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Power mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Default. The part is in active or sleep mode.</description>
                <name>DEFAULT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deep-sleep. ARM WFI will enter Deep-sleep mode.</description>
                <name>DEEP_SLEEP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power-down. ARM WFI will enter Power-down mode.</description>
                <name>POWER_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deep power-down. ARM WFI will enter Deep-power down mode (ARM Cortex-M0+ core powered-down).</description>
                <name>DEEP_POWER_DOWN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed.   This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked.</description>
            <name>NODPD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sleep mode flag</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active mode. Read: No power-down mode entered. Part is in Active mode. Write: No effect.</description>
                <name>ACTIVE_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low power mode. Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0.</description>
                <name>LOW_POWER_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEEPFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Deep power-down flag</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not Deep power-down. Read: Deep power-down mode not entered. Write: No effect.</description>
                <name>NOT_DEEP_POWER_DOWN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deep power-down. Read: Deep power-down mode entered. Write: Clear the Deep power-down flag.</description>
                <name>DEEP_POWER_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DPDFLAG</name>
          </field>
        </fields>
        <name>PCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Deep power down control register</description>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>WAKEUP pin hysteresis enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable Hysteresis for WAKUP pin disabled.</description>
                <name>DISABLE_HYSTERESIS_F</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Hysteresis for WAKEUP pin enabled.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKEUPHYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>WAKEUP pin disable. Setting this bit disables the wake-up pin, so it can be used for other purposes. Never set this bit if you intend to use a pin to wake up the part from Deep power-down mode. You can only disable the wake-up pin if the RTC wake-up timer is enabled and configured. Setting this bit is not necessary if Deep power-down mode is not used.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. The wake-up function is enabled on pin PIO0_16.</description>
                <name>ENABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. Setting this bit disables the wake-up function on pin PIO0_16.</description>
                <name>DISABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKEPAD_DISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x14</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4003C000</baseAddress>
    <description> Flash controller </description>
    <groupName>FLASHCTRL</groupName>
    <interrupts>
      <interrupt>
        <name>FLASH</name>
        <value>0x1B</value>
      </interrupt>
    </interrupts>
    <name>FLASHCTRL</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Flash configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 system clock flash access time (for system clock frequencies of up to 20 MHz).</description>
                <name>1_SYSTEM_CLOCK_FLASH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 system clocks flash access time (for system clock frequencies of up to 30 MHz).</description>
                <name>2_SYSTEM_CLOCKS_FLAS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASHTIM</name>
          </field>
        </fields>
        <name>FLASHCFG</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Signature start address register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x11</bitWidth>
            <description>Signature generation start address (corresponds to AHB byte address bits[20:4]).</description>
            <name>START</name>
          </field>
        </fields>
        <name>FMSSTART</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Signature stop-address register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x11</bitWidth>
            <description>Stop address for signature generation (the word specified by STOPA is included in the address range). The address is in units of memory words, not bytes.  If the option bistprotection=1, bits 2:0 cannot be written and are forced to 111.</description>
            <name>STOPA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is written to 1, signature generation starts. At the end of signature generation, this bit is automatically cleared.</description>
            <name>STRTBIST</name>
          </field>
        </fields>
        <name>FMSSTOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Signature Word </description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>32-bit signature.</description>
            <name>SIG</name>
          </field>
        </fields>
        <name>FMSW0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40040000</baseAddress>
    <description>SSP/SPI </description>
    <groupName>SSP0</groupName>
    <interrupts>
      <interrupt>
        <name>SSP0</name>
        <value>0x14</value>
      </interrupt>
    </interrupts>
    <name>SSP0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control Register 0. Selects the serial clock rate, bus type, and data size.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>4-bit transfer</description>
                <name>4_BIT_TRANSFER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5-bit transfer</description>
                <name>5_BIT_TRANSFER</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6-bit transfer</description>
                <name>6_BIT_TRANSFER</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7-bit transfer</description>
                <name>7_BIT_TRANSFER</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfer</description>
                <name>8_BIT_TRANSFER</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9-bit transfer</description>
                <name>9_BIT_TRANSFER</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>10-bit transfer</description>
                <name>10_BIT_TRANSFER</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>11-bit transfer</description>
                <name>11_BIT_TRANSFER</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>12-bit transfer</description>
                <name>12_BIT_TRANSFER</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>13-bit transfer</description>
                <name>13_BIT_TRANSFER</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>14-bit transfer</description>
                <name>14_BIT_TRANSFER</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>15-bit transfer</description>
                <name>15_BIT_TRANSFER</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfer</description>
                <name>16_BIT_TRANSFER</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Frame Format.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI</description>
                <name>SPI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TI</description>
                <name>TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Microwire</description>
                <name>MICROWIRE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>This combination is not supported and should not be used.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FRF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Out Polarity. This bit is only used in SPI mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller maintains the bus clock low between frames.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller maintains the bus clock high between frames.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Out Phase. This bit is only used in SPI mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line.</description>
                <name>FIRSTCLOCK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line.</description>
                <name>SECONDCLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Serial Clock Rate. The number of prescaler output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>SCR</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Control Register 1. Selects master/slave and other modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loop Back Mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>During normal operation.</description>
                <name>DURING_NORMAL_OPERAT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively).</description>
                <name>SERIAL_INPUT_IS_TAKE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LBM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP/SPI registers and interrupt controller registers, before setting this bit.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master/Slave Mode.This bit can only be written when the SSE bit is 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line.</description>
                <name>MASTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines.</description>
                <name>SLAVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SPI controller from driving the transmit data line (MISO).</description>
            <name>SOD</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SPI controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bit, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SPI controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bit, the data is right-justified in this field with higher order bits filled with 0s.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DR</name>
        <readAction>modify</readAction>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Status Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not.</description>
            <name>TFE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not.</description>
            <name>TNF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not.</description>
            <name>RNE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not.</description>
            <name>RFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Busy. This bit is 0 if the SPI controller is idle, 1 if it is currently sending/receiving a frame and/or the Tx FIFO is not empty.</description>
            <name>BSY</name>
          </field>
        </fields>
        <name>SR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x3</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Clock Prescale Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This even value between 2 and 254, by which SPI_PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0.</description>
            <name>CPSDVSR</name>
          </field>
        </fields>
        <name>CPSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Interrupt Mask Set and Clear Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.</description>
            <name>RORIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when the Rx FIFO is at least half full.</description>
            <name>RXIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when the Tx FIFO is at least half empty.</description>
            <name>TXIM</name>
          </field>
        </fields>
        <name>IMSC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Raw Interrupt Status Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if another frame was completely received while the RxFIFO was full. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.</description>
            <name>RORRIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTRIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is at least half full.</description>
            <name>RXRIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Tx FIFO is at least half empty.</description>
            <name>TXRIS</name>
          </field>
        </fields>
        <name>RIS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>Masked Interrupt Status Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if another frame was completely received while the RxFIFO was full, and this interrupt is enabled.</description>
            <name>RORMIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out period, and this interrupt is enabled. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTMIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is at least half full, and this interrupt is enabled.</description>
            <name>RXMIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is enabled.</description>
            <name>TXMIS</name>
          </field>
        </fields>
        <name>MIS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>SSPICR Interrupt Clear Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the frame was received when RxFIFO was full interrupt.</description>
            <name>RORIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read for a timeout period interrupt. The timeout period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTIC</name>
          </field>
        </fields>
        <name>ICR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40044000</baseAddress>
    <description>I/O control (IOCON) </description>
    <groupName>IOCON</groupName>
    <interrupts></interrupts>
    <name>IOCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>I/O configuration for open-drain pin PIO0_4</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function. </description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects I2C mode (see  Section 7.3.8).  Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode/ Fast-mode I2C.</description>
                <name>STANDARD_MODE_FAST</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard I/O functionality</description>
                <name>STANDARD_IO_FUNCTIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast-mode Plus I2C</description>
                <name>FAST_MODE_PLUS_I2C</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CMODE</name>
          </field>
        </fields>
        <name>PIO0_4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>I/O configuration for open-drain pin PIO0_5</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function. </description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects I2C mode (see  Section 7.3.8).  Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode/ Fast-mode I2C.</description>
                <name>STANDARD_MODE_FAST</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard I/O functionality</description>
                <name>STANDARD_IO_FUNCTIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast-mode Plus I2C</description>
                <name>FAST_MODE_PLUS_I2C</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CMODE</name>
          </field>
        </fields>
        <name>PIO0_5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_16</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_17</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_18</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_19</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_20</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_21</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_22</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>I/O configuration for  port PIO0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO0_23</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x64</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x88</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_16</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_17</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA8</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_18</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAC</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_19</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB0</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_20</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB4</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_21</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB8</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_22</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBC</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_23</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC0</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_24</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC4</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_25</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC8</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_26</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCC</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_27</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD0</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_28</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD4</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_29</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD8</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_30</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDC</addressOffset>
        <description>I/O configuration for port PIO1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO1_31</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x114</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x118</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11C</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x120</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x124</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x128</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x12C</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x130</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x134</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_16</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x138</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_17</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x13C</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_18</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x140</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_19</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x144</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_20</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x148</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_21</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14C</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_22</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x150</addressOffset>
        <description>I/O configuration for port PIO2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock IOCONCLKDIV. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV0. Use IOCON clock divider 0.</description>
                <name>IOCONCLKDIV0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV1. Use IOCON clock divider 1.</description>
                <name>IOCONCLKDIV1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV2 Use IOCON clock divider 2.</description>
                <name>IOCONCLKDIV2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV3. Use IOCON clock divider 3.</description>
                <name>IOCONCLKDIV3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV4. Use IOCON clock divider 4.</description>
                <name>IOCONCLKDIV4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV5. Use IOCON clock divider 5.</description>
                <name>IOCONCLKDIV5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONCLKDIV6. Use IOCON clock divider 6.</description>
                <name>IOCONCLKDIV6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKDIV</name>
          </field>
        </fields>
        <name>PIO2_23</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40048000</baseAddress>
    <description>System configuration (SYSCON)</description>
    <groupName>SYSCON</groupName>
    <interrupts>
      <interrupt>
        <name>BOD_WDT</name>
        <value>0x1A</value>
      </interrupt>
    </interrupts>
    <name>SYSCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>System memory remap</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System memory remap. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM.</description>
                <name>BOOT_LOADER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>User RAM Mode. Interrupt vectors are re-mapped to Static RAM.</description>
                <name>USER_RAM_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash.</description>
                <name>USER_FLASH_MODE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MAP</name>
          </field>
        </fields>
        <name>SYSMEMREMAP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Peripheral reset control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSP0 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the SSP0 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. SSP0 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSP0_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C0 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the I2C0 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. I2C0 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2C0_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSP1 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the SSP1 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. SSP1 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSP1_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C1 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the I2C1 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. I2C1 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2C1_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FRG reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the FRG peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. FRG reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FRG_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART1 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the USART1 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. USART1 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART1_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART2 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the USART2 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. USART2 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART2_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART3 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the USART3 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. USART3 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART3_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART4 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the USART4 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. USART4 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART4_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT0 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the SCT0 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. SCT0 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCT0_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT1 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. Resets the SCT1 peripheral.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear reset. SCT1 reset de-asserted.</description>
                <name>CLEAR_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCT1_RST_N</name>
          </field>
        </fields>
        <name>PRESETCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>System PLL control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32</description>
            <name>MSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Post divider ratio P. The division ratio is 2 x P.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 1</description>
                <name>P_EQ_1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 2</description>
                <name>P_EQ_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 4</description>
                <name>P_EQ_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 8</description>
                <name>P_EQ_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PSEL</name>
          </field>
        </fields>
        <name>SYSPLLCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>System PLL status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL lock status</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No lock. PLL not locked</description>
                <name>NO_LOCK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Lock. PLL locked</description>
                <name>LOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOCK</name>
          </field>
        </fields>
        <name>SYSPLLSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>RTC oscillator 32 kHz output control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the RTC 32 kHz output.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. 32 kHz output disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. 32 kHz output enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTCOSCEN</name>
          </field>
        </fields>
        <name>RTCOSCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>System oscillator control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bypass system oscillator</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Oscillator is not bypassed.</description>
                <name>OSCILLATOR_IS_NOT_BY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator.</description>
                <name>BYPASS_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines frequency range for Low-power oscillator.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. 1 - 20 MHz frequency range.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. 15 - 25 MHz frequency range.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FREQRANGE</name>
          </field>
        </fields>
        <name>SYSOSCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Watchdog oscillator control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Select divider for Fclkana.  wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64</description>
            <name>DIVSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select watchdog oscillator analog output frequency (Fclkana).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>0.6 MHz</description>
                <name>0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1.05 MHz</description>
                <name>1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1.4 MHz</description>
                <name>1</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1.75 MHz</description>
                <name>1</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2.1 MHz</description>
                <name>2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2.4 MHz</description>
                <name>2</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2.7 MHz</description>
                <name>2</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.0 MHz</description>
                <name>3</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.25 MHz</description>
                <name>3</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.5 MHz</description>
                <name>3</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.75 MHz</description>
                <name>3</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.0 MHz</description>
                <name>4</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.2 MHz</description>
                <name>4</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.4 MHz</description>
                <name>4</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.6 MHz</description>
                <name>4</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FREQSEL</name>
          </field>
        </fields>
        <name>WDTOSCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>IRC control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trim value</description>
            <name>TRIM</name>
          </field>
        </fields>
        <name>IRCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>System reset status register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>POR reset status</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No POR detected</description>
                <name>NO_POR_DETECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>POR detected</description>
                <name>POR_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the external RESET pin</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No reset event detected</description>
                <name>NO_RESET_EVENT_DETEC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset detected</description>
                <name>RESET_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EXTRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the Watchdog reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No WDT reset detected</description>
                <name>NO_WDT_RESET_DETECTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WDT reset detected</description>
                <name>WDT_RESET_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the Brown-out detect reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No BOD reset detected</description>
                <name>NO_BOD_RESET_DETECTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>BOD reset detected</description>
                <name>BOD_RESET_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the software system reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No System reset detected</description>
                <name>NO_SYSTEM_RESET_DETE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System reset detected</description>
                <name>SYSTEM_RESET_DETECTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSRST</name>
          </field>
        </fields>
        <name>SYSRSTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>System PLL clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System PLL clock source</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC</description>
                <name>IRC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System oscillator. Crystal Oscillator (SYSOSC)</description>
                <name>SYSTEM_OSCILLATOR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32 kHz clock.Select this option when the 32 kHz clock is the clock source for the main clock and select the pll input in the MAINCLKSEL register. Do not use the 32 kHz clock with the PLL.</description>
                <name>32_KHZ_CLOCK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>SYSPLLCLKSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>System PLL clock source update enable</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable system PLL clock source update</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Update clock source</description>
                <name>UPDATE_CLOCK_SOURCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA</name>
          </field>
        </fields>
        <name>SYSPLLCLKUEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Main clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock source for main clock</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC Oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PLL input</description>
                <name>PLL_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PLL output</description>
                <name>PLL_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>MAINCLKSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>Main clock source update enable</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable main clock source update</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Update clock source</description>
                <name>UPDATE_CLOCK_SOURCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA</name>
          </field>
        </fields>
        <name>MAINCLKUEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>System clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System AHB clock divider values  0: System clock disabled.  1: Divide by 1.  to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>SYSAHBCLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>System clock control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is read-only and always reads as 1. It configures the  always-on clock for the AHB, the APB bridges, the Cortex-M0 core clocks, SYSCON, reset control, SRAM0, and the PMU. Writes to this bit are ignored.</description>
            <name>SYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for ROM.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for Main SRAM0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RAM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for flash register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASHREG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for flash access.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASHARRAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for I2C.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2C0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for GPIO port registers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GPIO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for 16-bit counter/timer 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CT16B0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for 16-bit counter/timer 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CT16B1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for 32-bit counter/timer 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CT32B0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for 32-bit counter/timer 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CT32B1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for SSP0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for USART0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for ADC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for WWDT.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WWDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for I/O configuration block.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCON</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for SSP1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock to GPIO Pin interrupt register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock to USART1 register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock to USART2 register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock to USART3 and USART4 register interfaces.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART3_4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock to GPIO GROUP0 interrupt register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GROUP0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock to GPIO GROUP1 interrupt register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GROUP1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for I2C1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2C1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for SRAM1 located at 0x2000 0000 to 0x2000 0800.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RAM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables USB SRAM/SRAM2 block located at 0x2000 4000 to 0x2000 4800.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USBSRAM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for CRC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for DMA.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DMA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for RTC register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for SCT0 and SCT1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCT0_1</name>
          </field>
        </fields>
        <name>SYSAHBCLKCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x3F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>SSP0 clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI0_PCLK clock divider values.  0: System clock disabled.  1: Divide by 1.  to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>SSP0CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98</addressOffset>
        <description>USART0 clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>UART_PCLK clock divider values  0: Disable UART_PCLK.  1: Divide by 1.  to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>USART0CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C</addressOffset>
        <description>SSP1 clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SSP1_PCLK clock divider values  0: Disable SSP1_PCLK.  1: Divide by 1.  to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>SSP1CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>Clock divider for the common fractional baud rate generator of USART1, USART2, USART3, USART4</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>USART fractional baud rate generator clock divider values.  0: Clock disabled.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>FRGCLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE0</addressOffset>
        <description>CLKOUT clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CLKOUT clock source</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crystal oscillator (SYSOSC)</description>
                <name>CRYSTAL_OSCILLATOR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Main clock</description>
                <name>MAIN_CLOCK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>CLKOUTSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE4</addressOffset>
        <description>CLKOUT clock source update enable</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable CLKOUT clock source update</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Update clock source</description>
                <name>UPDATE_CLOCK_SOURCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA</name>
          </field>
        </fields>
        <name>CLKOUTUEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE8</addressOffset>
        <description>CLKOUT clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CLKOUT clock divider values  0: Disable CLKOUT clock divider.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>CLKOUTDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>USART fractional generator divider value</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>UARTFRGDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>USART fractional generator multiplier value</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Numerator of the fractional divider. MULT is equal to the programmed value.</description>
            <name>MULT</name>
          </field>
        </fields>
        <name>UARTFRGMULT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>External trace buffer command register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trace start command. Writing a one to this bit sets the TSTART signal to the MTB to HIGH and starts tracing if the TSTARTEN bit in the MTB master register is set to one as well.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trace stop command. Writing a one to this bit sets the TSTOP signal in the MTB to HIGH and stops tracing if the TSTOPEN bit in the MTB master register is set to one as well.</description>
            <name>STOP</name>
          </field>
        </fields>
        <name>EXTTRACECMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x100</addressOffset>
        <description>POR captured PIO status 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>State of PIO0_23 through PIO0_0 at power-on reset</description>
            <name>PIOSTAT</name>
          </field>
        </fields>
        <name>PIOPORCAP0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x104</addressOffset>
        <description>POR captured PIO status 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>State of PIO1_31 through PIO1_0 at power-on reset</description>
            <name>PIOSTAT</name>
          </field>
        </fields>
        <name>PIOPORCAP1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x108</addressOffset>
        <description>POR captured PIO status 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>State of PIO2_23 through PIO2_0 at power-on reset</description>
            <name>PIOSTAT</name>
          </field>
        </fields>
        <name>PIOPORCAP2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x134</addressOffset>
        <description>Peripheral clock  to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x138</addressOffset>
        <description>Peripheral clock  to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x13C</addressOffset>
        <description>Peripheral clock  to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x140</addressOffset>
        <description>Peripheral clock  to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x144</addressOffset>
        <description>Peripheral clock  to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x148</addressOffset>
        <description>Peripheral clock  to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14C</addressOffset>
        <description>Peripheral clock  to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x150</addressOffset>
        <description>Brown-Out Detect</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD reset level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 0.</description>
                <name>LEVEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 1.</description>
                <name>LEVEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2.</description>
                <name>LEVEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3.</description>
                <name>LEVEL_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTLEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD interrupt level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2.</description>
                <name>LEVEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3.</description>
                <name>LEVEL_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODINTVAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD reset enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable reset function.</description>
                <name>DISABLE_RESET_FUNCTI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable reset function.</description>
                <name>ENABLE_RESET_FUNCTIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTENA</name>
          </field>
        </fields>
        <name>BODCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x154</addressOffset>
        <description>System tick counter calibration</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1A</bitWidth>
            <description>System tick timer calibration value</description>
            <name>CAL</name>
          </field>
        </fields>
        <name>SYSTCKCAL</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x170</addressOffset>
        <description>IRQ delay. Allows trade-off between interrupt latency and determinism.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit latency value</description>
            <name>LATENCY</name>
          </field>
        </fields>
        <name>IRQLATENCY</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x10</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x174</addressOffset>
        <description>NMI Source Control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 6 for the list of interrupt sources and their IRQ numbers.</description>
            <name>IRQN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0.</description>
            <name>NMIEN</name>
          </field>
        </fields>
        <name>NMISRC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Start logic 0 interrupt wake-up enable register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 0 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 1 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 2 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 3 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 4 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 5 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 6 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt 7 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT7</name>
          </field>
        </fields>
        <name>STARTERP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Start logic 1 interrupt wake-up enable register 1</description>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTCINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Combined WWDT interrupt or Brown Out Detect (BOD) interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WWDT_BODINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO GROUP0 interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GROUP0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO GROUP1 interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GROUP1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Combined USART1 and USART4 interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART1_4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Combined USART2 and USART3 interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART2_3</name>
          </field>
        </fields>
        <name>STARTERP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x230</addressOffset>
        <description>Power-down states in deep-sleep mode</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD power-down control for Deep-sleep and Power-down mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog oscillator power-down control for Deep-sleep and Power-down mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDTOSC_PD</name>
          </field>
        </fields>
        <name>PDSLEEPCFG</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x234</addressOffset>
        <description>Power-down states for wake-up from deep-sleep</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator output wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRCOUT_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator power-down wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASH_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Crystal oscillator wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog oscillator wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDTOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>System PLL wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSPLL_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Temperature sensor wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TEMPSENSE_PD</name>
          </field>
        </fields>
        <name>PDAWAKECFG</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x238</addressOffset>
        <description>Power configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator output power-down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRCOUT_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator power-down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash power-down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASH_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD power-down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC power-down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Crystal oscillator power-down. After power-up, add a software delay of approximately 500 us before using.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog oscillator power-down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDTOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>System PLL power-down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSPLL_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Temperature sensor wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TEMPSENSE_PD</name>
          </field>
        </fields>
        <name>PDRUNCFG</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3F4</addressOffset>
        <description>Device ID</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PARTID</description>
            <name>DEVICEID</name>
          </field>
        </fields>
        <name>DEVICE_ID</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x178</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x17C</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x184</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x188</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18C</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x190</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x194</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number. PIO0_0 = 0, ..., PIO0_23 = 23, PIO1_0 = 24, ..., PIO1_31 = 55, PIO2_0 = 56, ..., PIO2_7 = 63.</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4004C000</baseAddress>
    <description>USART4 </description>
    <groupName>USART4</groupName>
    <interrupts>
      <interrupt>
        <name>USART1_4</name>
        <value>0xB</value>
      </interrupt>
    </interrupts>
    <name>USART4</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt (if  enabled in the INTENSET register) or a DMA transfer request because the transmitter has been reset and is therefore available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses standard clocking.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses the 32 kHz clock from the RTC oscillator as the clock source to the BRG, and uses a special bit clocking scheme.</description>
                <name>32KHZ</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 11.8.4 for more information.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses  the CTS input (or RTS output in loopback mode) for flow control purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode is selected.</description>
                <name>ASYNCHRONOUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode is selected.</description>
                <name>SYNCHRONOUS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485 operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deasserted. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission.</description>
                <name>DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. If selected by OESEL, the Output Enable signal remains asserted for 1 character time after then end the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted.</description>
                <name>ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control. The RTS signal is used as the standard flow control function.</description>
                <name>FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output enable. The RTS signal is taken over in order to provide an output enable signal to control an RS-485 transceiver.</description>
                <name>OUTPUT_ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being used by the UART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the UART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK_IS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. UART is in normal operating mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. UART is in autobaud mode. This bit should only be set when the UART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR. This bit can be cleared by software when set, but only when the UART receiver is idle.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT. Set when  the data is moved from the transmit buffer to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error. An auto-baud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an auto-baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received character available to be read from the RXDAT register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto-baud error occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXDISINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will be set when a parity error is detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RXNOISEINT bit in Table 133.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available and any conditions for transmitting data are met: CTS low (if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error flag.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 peripheral clocks are used to transmit and receive each data bit. 0x5 = 6 peripheral clocks are used to transmit and receive each data bit.  ... 0xF= 16 peripheral clocks are used to transmit and receive each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40058000</baseAddress>
    <derivedFrom>SSP0</derivedFrom>
    <description>SSP1</description>
    <groupName>SSP0</groupName>
    <interrupts>
      <interrupt>
        <name>SSP1</name>
        <value>0xE</value>
      </interrupt>
    </interrupts>
    <name>SSP1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control Register 0. Selects the serial clock rate, bus type, and data size.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>4-bit transfer</description>
                <name>4_BIT_TRANSFER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5-bit transfer</description>
                <name>5_BIT_TRANSFER</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6-bit transfer</description>
                <name>6_BIT_TRANSFER</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7-bit transfer</description>
                <name>7_BIT_TRANSFER</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfer</description>
                <name>8_BIT_TRANSFER</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9-bit transfer</description>
                <name>9_BIT_TRANSFER</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>10-bit transfer</description>
                <name>10_BIT_TRANSFER</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>11-bit transfer</description>
                <name>11_BIT_TRANSFER</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>12-bit transfer</description>
                <name>12_BIT_TRANSFER</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>13-bit transfer</description>
                <name>13_BIT_TRANSFER</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>14-bit transfer</description>
                <name>14_BIT_TRANSFER</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>15-bit transfer</description>
                <name>15_BIT_TRANSFER</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfer</description>
                <name>16_BIT_TRANSFER</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Frame Format.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI</description>
                <name>SPI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TI</description>
                <name>TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Microwire</description>
                <name>MICROWIRE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>This combination is not supported and should not be used.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FRF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Out Polarity. This bit is only used in SPI mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller maintains the bus clock low between frames.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller maintains the bus clock high between frames.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Out Phase. This bit is only used in SPI mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line.</description>
                <name>FIRSTCLOCK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line.</description>
                <name>SECONDCLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Serial Clock Rate. The number of prescaler output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>SCR</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Control Register 1. Selects master/slave and other modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loop Back Mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>During normal operation.</description>
                <name>DURING_NORMAL_OPERAT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively).</description>
                <name>SERIAL_INPUT_IS_TAKE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LBM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP/SPI registers and interrupt controller registers, before setting this bit.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master/Slave Mode.This bit can only be written when the SSE bit is 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line.</description>
                <name>MASTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SPI controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines.</description>
                <name>SLAVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SPI controller from driving the transmit data line (MISO).</description>
            <name>SOD</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SPI controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bit, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SPI controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bit, the data is right-justified in this field with higher order bits filled with 0s.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DR</name>
        <readAction>modify</readAction>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Status Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not.</description>
            <name>TFE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not.</description>
            <name>TNF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not.</description>
            <name>RNE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not.</description>
            <name>RFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Busy. This bit is 0 if the SPI controller is idle, 1 if it is currently sending/receiving a frame and/or the Tx FIFO is not empty.</description>
            <name>BSY</name>
          </field>
        </fields>
        <name>SR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x3</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Clock Prescale Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This even value between 2 and 254, by which SPI_PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0.</description>
            <name>CPSDVSR</name>
          </field>
        </fields>
        <name>CPSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Interrupt Mask Set and Clear Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.</description>
            <name>RORIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when the Rx FIFO is at least half full.</description>
            <name>RXIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software should set this bit to enable interrupt when the Tx FIFO is at least half empty.</description>
            <name>TXIM</name>
          </field>
        </fields>
        <name>IMSC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Raw Interrupt Status Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if another frame was completely received while the RxFIFO was full. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.</description>
            <name>RORRIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTRIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is at least half full.</description>
            <name>RXRIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Tx FIFO is at least half empty.</description>
            <name>TXRIS</name>
          </field>
        </fields>
        <name>RIS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>Masked Interrupt Status Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if another frame was completely received while the RxFIFO was full, and this interrupt is enabled.</description>
            <name>RORMIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out period, and this interrupt is enabled. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTMIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Rx FIFO is at least half full, and this interrupt is enabled.</description>
            <name>RXMIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is enabled.</description>
            <name>TXMIS</name>
          </field>
        </fields>
        <name>MIS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>SSPICR Interrupt Clear Register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the frame was received when RxFIFO was full interrupt.</description>
            <name>RORIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read for a timeout period interrupt. The timeout period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).</description>
            <name>RTIC</name>
          </field>
        </fields>
        <name>ICR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4005C000</baseAddress>
    <description>GPIO group interrupt 0</description>
    <groupName>GINT0</groupName>
    <interrupts>
      <interrupt>
        <name>GINT0</name>
        <value>0x8</value>
      </interrupt>
    </interrupts>
    <name>GINT0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO grouped interrupt control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt status. This bit is cleared by writing a one to it. Writing zero has no effect.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt request is pending.</description>
                <name>NO_INTERRUPT_REQUEST</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Interrupt request is active.</description>
                <name>INTERRUPT_REQUEST_IS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Combine enabled inputs for group interrupt</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity).</description>
                <name>OR_FUNCTIONALITY_A_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity).</description>
                <name>AND_FUNCTIONALITY_A</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt trigger</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge-triggered</description>
                <name>EDGE_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level-triggered</description>
                <name>LEVEL_TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40060000</baseAddress>
    <derivedFrom>GINT0</derivedFrom>
    <description>GINT1</description>
    <groupName>GINT0</groupName>
    <interrupts>
      <interrupt>
        <name>GINT1</name>
        <value>0x9</value>
      </interrupt>
    </interrupts>
    <name>GINT1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO grouped interrupt control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt status. This bit is cleared by writing a one to it. Writing zero has no effect.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt request is pending.</description>
                <name>NO_INTERRUPT_REQUEST</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Interrupt request is active.</description>
                <name>INTERRUPT_REQUEST_IS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Combine enabled inputs for group interrupt</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity).</description>
                <name>OR_FUNCTIONALITY_A_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity).</description>
                <name>AND_FUNCTIONALITY_A</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt trigger</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge-triggered</description>
                <name>EDGE_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level-triggered</description>
                <name>LEVEL_TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <displayName>PORT_POL[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.</description>
            <name>POL31</name>
          </field>
        </fields>
        <name>PORT_POL[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>GPIO grouped interrupt port  enable register</description>
        <displayName>PORT_ENA[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.</description>
            <name>ENA31</name>
          </field>
        </fields>
        <name>PORT_ENA[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4006C000</baseAddress>
    <derivedFrom>USART4</derivedFrom>
    <description>USART1</description>
    <groupName>USART4</groupName>
    <interrupts>
      <interrupt>
        <name>USART1_4</name>
        <value>0xB</value>
      </interrupt>
    </interrupts>
    <name>USART1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt (if  enabled in the INTENSET register) or a DMA transfer request because the transmitter has been reset and is therefore available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses standard clocking.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses the 32 kHz clock from the RTC oscillator as the clock source to the BRG, and uses a special bit clocking scheme.</description>
                <name>32KHZ</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 11.8.4 for more information.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses  the CTS input (or RTS output in loopback mode) for flow control purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode is selected.</description>
                <name>ASYNCHRONOUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode is selected.</description>
                <name>SYNCHRONOUS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485 operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deasserted. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission.</description>
                <name>DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. If selected by OESEL, the Output Enable signal remains asserted for 1 character time after then end the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted.</description>
                <name>ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control. The RTS signal is used as the standard flow control function.</description>
                <name>FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output enable. The RTS signal is taken over in order to provide an output enable signal to control an RS-485 transceiver.</description>
                <name>OUTPUT_ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being used by the UART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the UART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK_IS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. UART is in normal operating mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. UART is in autobaud mode. This bit should only be set when the UART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR. This bit can be cleared by software when set, but only when the UART receiver is idle.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT. Set when  the data is moved from the transmit buffer to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error. An auto-baud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an auto-baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received character available to be read from the RXDAT register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto-baud error occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXDISINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will be set when a parity error is detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RXNOISEINT bit in Table 133.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available and any conditions for transmitting data are met: CTS low (if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error flag.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 peripheral clocks are used to transmit and receive each data bit. 0x5 = 6 peripheral clocks are used to transmit and receive each data bit.  ... 0xF= 16 peripheral clocks are used to transmit and receive each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40070000</baseAddress>
    <derivedFrom>USART4</derivedFrom>
    <description>USART2</description>
    <groupName>USART4</groupName>
    <interrupts>
      <interrupt>
        <name>USART2_3</name>
        <value>0xC</value>
      </interrupt>
    </interrupts>
    <name>USART2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt (if  enabled in the INTENSET register) or a DMA transfer request because the transmitter has been reset and is therefore available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses standard clocking.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses the 32 kHz clock from the RTC oscillator as the clock source to the BRG, and uses a special bit clocking scheme.</description>
                <name>32KHZ</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 11.8.4 for more information.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses  the CTS input (or RTS output in loopback mode) for flow control purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode is selected.</description>
                <name>ASYNCHRONOUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode is selected.</description>
                <name>SYNCHRONOUS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485 operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deasserted. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission.</description>
                <name>DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. If selected by OESEL, the Output Enable signal remains asserted for 1 character time after then end the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted.</description>
                <name>ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control. The RTS signal is used as the standard flow control function.</description>
                <name>FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output enable. The RTS signal is taken over in order to provide an output enable signal to control an RS-485 transceiver.</description>
                <name>OUTPUT_ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being used by the UART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the UART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK_IS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. UART is in normal operating mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. UART is in autobaud mode. This bit should only be set when the UART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR. This bit can be cleared by software when set, but only when the UART receiver is idle.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT. Set when  the data is moved from the transmit buffer to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error. An auto-baud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an auto-baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received character available to be read from the RXDAT register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto-baud error occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXDISINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will be set when a parity error is detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RXNOISEINT bit in Table 133.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available and any conditions for transmitting data are met: CTS low (if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error flag.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 peripheral clocks are used to transmit and receive each data bit. 0x5 = 6 peripheral clocks are used to transmit and receive each data bit.  ... 0xF= 16 peripheral clocks are used to transmit and receive each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40074000</baseAddress>
    <derivedFrom>USART4</derivedFrom>
    <description>USART3</description>
    <groupName>USART4</groupName>
    <interrupts>
      <interrupt>
        <name>USART1_4</name>
        <value>0xB</value>
      </interrupt>
    </interrupts>
    <name>USART3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt (if  enabled in the INTENSET register) or a DMA transfer request because the transmitter has been reset and is therefore available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses standard clocking.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>UART uses the 32 kHz clock from the RTC oscillator as the clock source to the BRG, and uses a special bit clocking scheme.</description>
                <name>32KHZ</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 11.8.4 for more information.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses  the CTS input (or RTS output in loopback mode) for flow control purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode is selected.</description>
                <name>ASYNCHRONOUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode is selected.</description>
                <name>SYNCHRONOUS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485 operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deasserted. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission.</description>
                <name>DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. If selected by OESEL, the Output Enable signal remains asserted for 1 character time after then end the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted.</description>
                <name>ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control. The RTS signal is used as the standard flow control function.</description>
                <name>FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output enable. The RTS signal is taken over in order to provide an output enable signal to control an RS-485 transceiver.</description>
                <name>OUTPUT_ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being used by the UART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not changed. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.</description>
                <name>NOT_CHANGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the UART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK_IS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. UART is in normal operating mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. UART is in autobaud mode. This bit should only be set when the UART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR. This bit can be cleared by software when set, but only when the UART receiver is idle.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT. Set when  the data is moved from the transmit buffer to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error. An auto-baud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an auto-baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received character available to be read from the RXDAT register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto-baud error occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXDISINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a character to be read in the RXDAT register and reflects the status of that character. This bit will be set when a parity error is detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RXNOISEINT bit in Table 133.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available and any conditions for transmitting data are met: CTS low (if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-baud Error flag.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 peripheral clocks are used to transmit and receive each data bit. 0x5 = 6 peripheral clocks are used to transmit and receive each data bit.  ... 0xF= 16 peripheral clocks are used to transmit and receive each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000000</baseAddress>
    <description>Cyclic Redundancy Check (CRC) engine</description>
    <groupName>CRC</groupName>
    <interrupts></interrupts>
    <name>CRC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>CRC mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CRC polynom: 1X= CRC-32 polynomial 01= CRC-16 polynomial 00= CRC-CCITT polynomial</description>
            <name>CRC_POLY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data bit order: 1= Bit order reverse for CRC_WR_DATA (per byte) 0= No bit order reverse for CRC_WR_DATA (per byte)</description>
            <name>BIT_RVS_WR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data complement: 1= 1's complement for CRC_WR_DATA 0= No 1's complement for CRC_WR_DATA</description>
            <name>CMPL_WR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRC sum bit order: 1= Bit order reverse for CRC_SUM 0= No bit order reverse for CRC_SUM</description>
            <name>BIT_RVS_SUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRC sum complement: 1= 1's complement for CRC_SUM 0=No 1's complement for CRC_SUM</description>
            <name>CMPL_SUM</name>
          </field>
        </fields>
        <name>MODE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>CRC seed register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1's complement pre-processes. A write access to this register will overrule the CRC calculation in progresses.</description>
            <name>CRC_SEED</name>
          </field>
        </fields>
        <name>SEED</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>CRC checksum register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>The most recent CRC sum can be read through this register with selected bit order and 1's complement post-processes.</description>
            <name>CRC_SUM</name>
          </field>
        </fields>
        <name>SUM</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>CRC data register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data written to this register will be taken to perform CRC calculation with selected bit order and 1's complement pre-process. Any write size 8, 16 or 32-bit are allowed and accept back-to-back transactions.</description>
            <name>CRC_WR_DATA</name>
          </field>
        </fields>
        <name>WR_DATA</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004000</baseAddress>
    <description>DMA controller</description>
    <groupName>DMA</groupName>
    <interrupts>
      <interrupt>
        <name>DMA</name>
        <value>0x1C</value>
      </interrupt>
    </interrupts>
    <name>DMA</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>DMA control.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DMA controller master enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The DMA controller is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Interrupt status.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Summarizes whether any enabled interrupts are pending.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not pending. No enabled interrupts are pending.</description>
                <name>NOT_PENDING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. At least one enabled interrupt is pending.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACTIVEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Summarizes whether any error interrupts are pending.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not pending. No error interrupts are pending.</description>
                <name>NOT_PENDING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. At least one error interrupt is pending.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACTIVEERRINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SRAM address of the channel configuration table.</description>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Address of the beginning of the DMA descriptor table. The table must begin on a 1 kB boundary. Boundary needed for 18 channel DMA configuration: 512 bytes (bottom 9 bits = 0)</description>
            <name>OFFSET</name>
          </field>
        </fields>
        <name>SRAMBASE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Channel Enable read and Set for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Enable for DMA channels 15:0. Bit n enables or disables DMA channel n.  0 = disabled. 1 = enabled.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>ENABLESET0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x28</addressOffset>
        <description>Channel Enable Clear for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Writing ones to this register clears the corresponding bits in ENABLESET0. Bit n clears the channel enable bit n.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>ENABLECLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Channel Active status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Active flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = not active. 1 = active.</description>
            <name>ACT</name>
          </field>
        </fields>
        <name>ACTIVE0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Channel Busy status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Busy flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = not busy. 1 = busy.</description>
            <name>BSY</name>
          </field>
        </fields>
        <name>BUSY0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Error Interrupt status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Error Interrupt flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = error interrupt is not active. 1 = error interrupt is active.</description>
            <name>ERR</name>
          </field>
        </fields>
        <name>ERRINT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Interrupt Enable read and Set for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Interrupt Enable read and set for DMA channel n. Bit n corresponds to DMA channel n. 0 = interrupt for DMA channel is disabled. 1 = interrupt for DMA channel is enabled.</description>
            <name>INTEN</name>
          </field>
        </fields>
        <name>INTENSET0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x50</addressOffset>
        <description>Interrupt Enable Clear for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Writing ones to this register clears corresponding bits in the INTENSET0. Bit n corresponds to DMA channel n.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>INTENCLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Interrupt A status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Interrupt A status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt A is not active. 1 = the DMA channel interrupt A is active.</description>
            <name>IA</name>
          </field>
        </fields>
        <name>INTA0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>Interrupt B status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Interrupt B status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt B is not active. 1 = the DMA channel interrupt B is active.</description>
            <name>IB</name>
          </field>
        </fields>
        <name>INTB0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x68</addressOffset>
        <description>Set ValidPending control bits for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SETVALID control for DMA channel n. Bit n corresponds to DMA channel n. 0 = no effect. 1 = sets the VALIDPENDING control bit for DMA channel n.</description>
            <name>SV</name>
          </field>
        </fields>
        <name>SETVALID0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x70</addressOffset>
        <description>Set Trigger control bits for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Set Trigger control bit for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA channel n.</description>
            <name>TRIG</name>
          </field>
        </fields>
        <name>SETTRIG0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x78</addressOffset>
        <description>Channel Abort control for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Abort control for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = aborts DMA operations on channel n.</description>
            <name>AORTCTRL</name>
          </field>
        </fields>
        <name>ABORT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x410</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x420</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x430</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x440</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x450</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x460</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x470</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x480</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x490</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4A0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4B0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4D0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4E0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4F0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the address wrap size when SrcBurstWrap and/or DstBurstWrap is modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of this channel when multiple DMA requests are pending. This description reflects a 2-bit priority field providing 4 priority levels. 0x0 = highest priority. 0x3 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x404</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x414</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x424</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x434</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x444</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x454</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x464</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x474</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x484</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x494</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4A4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4B4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4D4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4E4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4F4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect on DMA operation.</description>
                <name>NO_EFFECT_ON_DMA_OPE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x408</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x418</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x428</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x438</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x448</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x458</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x468</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x478</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x488</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x498</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4A8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4B8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4D8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4E8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4F8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The current channel descriptor is not considered valid.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <name>WHEN_WRITTEN_BY_SOFT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit transfers are performed (8-bit source reads and destination writes).</description>
                <name>8_BIT_TRANSFERS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit transfers are performed (16-bit source reads and destination writes).</description>
                <name>16_BIT_TRANSFERS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit transfers are performed (32-bit source reads and destination writes).</description>
                <name>32_BIT_TRANSFERS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved setting, do not use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x5000C000</baseAddress>
    <description>State Configurable Timers (SCTimer/PWM)</description>
    <groupName>SCT0</groupName>
    <interrupts>
      <interrupt>
        <name>SCT0_1</name>
        <value>0xD</value>
      </interrupt>
    </interrupts>
    <name>SCT0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SCT configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT operation</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT operates as two 16-bit counters named L and H.</description>
                <name>THE_SCT_OPERATES_AS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT operates as a unified 32-bit counter.</description>
                <name>THE_SCT_OPERATES_AS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UNIFY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>SCT clock mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The bus clock clocks the SCT and prescalers.</description>
                <name>THE_BUS_CLOCK_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT clock is the bus clock, but the prescalers are  enabled to count only when sampling of the input selected by  the CKSEL field finds the selected edge. The minimum pulse  width on the clock input is 1 bus clock period. This mode is the high-performance  sampled-clock mode.</description>
                <name>THE_SCT_CLOCK_IS_THE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The input selected by  CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted.  The minimum pulse width on the clock input is 1 bus clock  period. This mode is the low-power sampled-clock mode.</description>
                <name>THE_INPUT_SELECTED_B</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Prescaled SCT input. The SCT and prescalers are clocked by the input edge  selected by the CKSEL field. In this mode, most of the SCT is clocked by the (selected polarity of the)  input. The outputs are switched synchronously to the input clock. The input clock rate must be at least half the system clock rate and  can the same or faster than the system clock.</description>
                <name>PRESCALED_SCT_INPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>SCT clock select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 0.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 0.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 1.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 1.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 2.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 2.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 3.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 3.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the lower match registers from being  reloaded from their respective reload registers. Software can  write to set or clear this bit at any time. This bit applies to both the  higher and lower registers when the UNIFY bit is set.</description>
            <name>NORELAOD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the higher match registers from being  reloaded from their respective reload registers. Software can  write to set or clear this bit at any time. This bit is not used when  the UNIFY bit is set.</description>
            <name>NORELOAD_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Synchronization for input N (bit 9 = input 0, bit 10 = input 1,..., bit 12 = input 3); all other bits are reserved. A 1 in one of these bits subjects the corresponding input to  synchronization to the SCT clock, before it is used to create an  event. If an input is synchronous to the SCT clock, keep its bit 0 for  faster response. When the CKMODE field is 1x, the bit in this field, corresponding  to the input selected by the CKSEL field, is not used.</description>
            <name>INSYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit causes a match on match register 0 to be treated  as a de-facto LIMIT condition without the need to define an  associated event. As with any LIMIT event, this automatic limit causes the  counter to be cleared to zero in uni-directional mode or to change  the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit  applies to both the higher and lower registers when the UNIFY bit  is set.</description>
            <name>AUTOLIMIT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit will cause a match on match register 0 to be treated  as a de-facto LIMIT condition without the need to define an  associated event. As with any LIMIT event, this automatic limit causes the  counter to be cleared to zero in uni-directional mode or to change  the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is  not used when the UNIFY bit is set.</description>
            <name>AUTOLIMIT_H</name>
          </field>
        </fields>
        <name>CONFIG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7E00</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SCT control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the L or unified counter is counting down. Hardware sets this bit   when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.</description>
            <name>DOWN_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O  events related to the counter can occur. If such an event matches  the mask in the Start register, this bit is cleared and counting  resumes.</description>
            <name>STOP_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the L or unified counter does not run and no events can occur.  A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, only software can clear this bit to restore counter operation.</description>
            <name>HALT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0.</description>
            <name>CLRCTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>L or unified counter direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counter counts up to its limit condition, then is cleared to zero.</description>
                <name>THE_COUNTER_COUNTS_U</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counter counts up to its limit, then counts down to a limit condition or to 0.</description>
                <name>THE_COUNTER_COUNTS_U</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to produce the  L or unified counter clock. The counter clock is clocked at the rate of the SCT  clock divided by PRE_L+1. Clear the counter (by writing a 1  to the CLRCTR bit) whenever changing the PRE value.</description>
            <name>PRE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the H counter is counting down. Hardware sets this bit   when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.</description>
            <name>DOWN_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the H counter does not, run but I/O  events related to the counter can occur. If such an event matches  the mask in the Start register, this bit is cleared and counting  resumes.</description>
            <name>STOP_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the H counter does not run and no events can occur.  A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, this bit can only be cleared by software to restore counter operation.</description>
            <name>HALT_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the H counter. This bit always reads as 0.</description>
            <name>CLRCTR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The H counter counts up to its limit condition, then is cleared to zero.</description>
                <name>THE_H_COUNTER_COUNTS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The H counter counts up to its limit, then counts down to a limit condition or to 0.</description>
                <name>THE_H_COUNTER_COUNTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to produce the  H counter clock. The counter clock is clocked at the rate of the SCT  clock divided by PRELH+1. Clear the counter (by writing a 1  to the CLRCTR bit) whenever changing the PRE value.</description>
            <name>PRE_H</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x40004</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SCT limit register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>LIMMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>LIMMSK_H</name>
          </field>
        </fields>
        <name>LIMIT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SCT halt condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>HALTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>HALTMSK_H</name>
          </field>
        </fields>
        <name>HALT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SCT stop condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>STOPMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>STOPMSK_H</name>
          </field>
        </fields>
        <name>STOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SCT start condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>STARTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>STARTMSK_H</name>
          </field>
        </fields>
        <name>START</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>SCT counter register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter.</description>
            <name>CTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter.</description>
            <name>CTR_H</name>
          </field>
        </fields>
        <name>COUNT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>SCT state register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_H</name>
          </field>
        </fields>
        <name>STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>SCT input register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 0.</description>
            <name>AIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 1.</description>
            <name>AIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 2.</description>
            <name>AIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 3.</description>
            <name>AIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 0 state synchronized to the SCT clock.</description>
            <name>SIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 1 state synchronized to the SCT clock.</description>
            <name>SIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 2 state synchronized to the SCT clock.</description>
            <name>SIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 3 state synchronized to the SCT clock.</description>
            <name>SIN3</name>
          </field>
        </fields>
        <name>INPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>SCT match/capture registers mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Each bit controls one pair of match/capture registers (register 0 = bit 0, register 1 = bit 1,..., register 4 = bit 4).  0 = registers operate as match registers. 1 = registers operate as capture registers.</description>
            <name>REGMOD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Each bit controls one pair of match/capture registers (register 0 = bit 16, register 1 = bit 17,..., register 4 = bit 20). 0 = registers operate as match registers. 1 = registers operate as capture registers.</description>
            <name>REGMOD_H</name>
          </field>
        </fields>
        <name>REGMODE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>SCT output register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Writing a 1 to bit n makes the corresponding output HIGH. 0 makes the corresponding output LOW (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>OUT</name>
          </field>
        </fields>
        <name>OUTPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>SCT output counter direction control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR3</name>
          </field>
        </fields>
        <name>OUTPUTDIRCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>SCT conflict resolution register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR0 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR0 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O0RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR1 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR1 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O1RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR2 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output n (or set based on the SETCLR2 field).</description>
                <name>CLEAR_OUTPUT_N_OR_S</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O2RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR3 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR3 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O3RES</name>
          </field>
        </fields>
        <name>RES</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>SCT DMA request 0 register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets DMA request 0 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>DEV_0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit makes the SCT set DMA request 0 when it loads the  Match_L/Unified registers from the Reload_L/Unified registers.</description>
            <name>DRL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This read-only bit indicates the state of DMA Request 0</description>
            <name>DRQ0</name>
          </field>
        </fields>
        <name>DMAREQ0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>SCT DMA request 1 register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets DMA request 1 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>DEV_1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit makes the SCT set DMA request 1 when it loads the  Match L/Unified registers from the Reload L/Unified registers.</description>
            <name>DRL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This read-only bit indicates the state of DMA Request 1.</description>
            <name>DRQ1</name>
          </field>
        </fields>
        <name>DMAREQ1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>SCT event enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>The SCT requests interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>IEN</name>
          </field>
        </fields>
        <name>EVEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>SCT event flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>FLAG</name>
          </field>
        </fields>
        <name>EVFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>SCT conflict enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>The SCT requests interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>NCEN</name>
          </field>
        </fields>
        <name>CONEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>SCT conflict flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Bit n is one if a no-change conflict event occurred on output n since  reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>NCFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing CTR  L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the  L/U counter was not halted. A word write to certain L  and H registers can be half successful and half unsuccessful.</description>
            <name>BUSERRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing CTR H,  STATE H, MATCH H, or the Output register when the H  counter was not halted.</description>
            <name>BUSERRH</name>
          </field>
        </fields>
        <name>CONFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV0_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV1_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV2_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x318</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV3_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV4_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x328</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV5_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV0_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV1_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV2_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV3_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x324</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV4_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x32C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV5_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT0_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x508</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT1_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x510</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT2_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x518</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT3_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x504</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT0_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT1_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x514</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT2_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x51C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT3_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x5000E000</baseAddress>
    <derivedFrom>SCT0</derivedFrom>
    <description>SCT1</description>
    <groupName>SCT0</groupName>
    <interrupts>
      <interrupt>
        <name>SCT0_1</name>
        <value>0xD</value>
      </interrupt>
    </interrupts>
    <name>SCT1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SCT configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT operation</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT operates as two 16-bit counters named L and H.</description>
                <name>THE_SCT_OPERATES_AS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT operates as a unified 32-bit counter.</description>
                <name>THE_SCT_OPERATES_AS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UNIFY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>SCT clock mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The bus clock clocks the SCT and prescalers.</description>
                <name>THE_BUS_CLOCK_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT clock is the bus clock, but the prescalers are  enabled to count only when sampling of the input selected by  the CKSEL field finds the selected edge. The minimum pulse  width on the clock input is 1 bus clock period. This mode is the high-performance  sampled-clock mode.</description>
                <name>THE_SCT_CLOCK_IS_THE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The input selected by  CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted.  The minimum pulse width on the clock input is 1 bus clock  period. This mode is the low-power sampled-clock mode.</description>
                <name>THE_INPUT_SELECTED_B</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Prescaled SCT input. The SCT and prescalers are clocked by the input edge  selected by the CKSEL field. In this mode, most of the SCT is clocked by the (selected polarity of the)  input. The outputs are switched synchronously to the input clock. The input clock rate must be at least half the system clock rate and  can the same or faster than the system clock.</description>
                <name>PRESCALED_SCT_INPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>SCT clock select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 0.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 0.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 1.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 1.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 2.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 2.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 3.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 3.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the lower match registers from being  reloaded from their respective reload registers. Software can  write to set or clear this bit at any time. This bit applies to both the  higher and lower registers when the UNIFY bit is set.</description>
            <name>NORELAOD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the higher match registers from being  reloaded from their respective reload registers. Software can  write to set or clear this bit at any time. This bit is not used when  the UNIFY bit is set.</description>
            <name>NORELOAD_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Synchronization for input N (bit 9 = input 0, bit 10 = input 1,..., bit 12 = input 3); all other bits are reserved. A 1 in one of these bits subjects the corresponding input to  synchronization to the SCT clock, before it is used to create an  event. If an input is synchronous to the SCT clock, keep its bit 0 for  faster response. When the CKMODE field is 1x, the bit in this field, corresponding  to the input selected by the CKSEL field, is not used.</description>
            <name>INSYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit causes a match on match register 0 to be treated  as a de-facto LIMIT condition without the need to define an  associated event. As with any LIMIT event, this automatic limit causes the  counter to be cleared to zero in uni-directional mode or to change  the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit  applies to both the higher and lower registers when the UNIFY bit  is set.</description>
            <name>AUTOLIMIT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit will cause a match on match register 0 to be treated  as a de-facto LIMIT condition without the need to define an  associated event. As with any LIMIT event, this automatic limit causes the  counter to be cleared to zero in uni-directional mode or to change  the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is  not used when the UNIFY bit is set.</description>
            <name>AUTOLIMIT_H</name>
          </field>
        </fields>
        <name>CONFIG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7E00</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SCT control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the L or unified counter is counting down. Hardware sets this bit   when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.</description>
            <name>DOWN_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O  events related to the counter can occur. If such an event matches  the mask in the Start register, this bit is cleared and counting  resumes.</description>
            <name>STOP_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the L or unified counter does not run and no events can occur.  A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, only software can clear this bit to restore counter operation.</description>
            <name>HALT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0.</description>
            <name>CLRCTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>L or unified counter direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counter counts up to its limit condition, then is cleared to zero.</description>
                <name>THE_COUNTER_COUNTS_U</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counter counts up to its limit, then counts down to a limit condition or to 0.</description>
                <name>THE_COUNTER_COUNTS_U</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to produce the  L or unified counter clock. The counter clock is clocked at the rate of the SCT  clock divided by PRE_L+1. Clear the counter (by writing a 1  to the CLRCTR bit) whenever changing the PRE value.</description>
            <name>PRE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the H counter is counting down. Hardware sets this bit   when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.</description>
            <name>DOWN_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the H counter does not, run but I/O  events related to the counter can occur. If such an event matches  the mask in the Start register, this bit is cleared and counting  resumes.</description>
            <name>STOP_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the H counter does not run and no events can occur.  A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, this bit can only be cleared by software to restore counter operation.</description>
            <name>HALT_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the H counter. This bit always reads as 0.</description>
            <name>CLRCTR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The H counter counts up to its limit condition, then is cleared to zero.</description>
                <name>THE_H_COUNTER_COUNTS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The H counter counts up to its limit, then counts down to a limit condition or to 0.</description>
                <name>THE_H_COUNTER_COUNTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to produce the  H counter clock. The counter clock is clocked at the rate of the SCT  clock divided by PRELH+1. Clear the counter (by writing a 1  to the CLRCTR bit) whenever changing the PRE value.</description>
            <name>PRE_H</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x40004</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SCT limit register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>LIMMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>LIMMSK_H</name>
          </field>
        </fields>
        <name>LIMIT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SCT halt condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>HALTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>HALTMSK_H</name>
          </field>
        </fields>
        <name>HALT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SCT stop condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>STOPMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>STOPMSK_H</name>
          </field>
        </fields>
        <name>STOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SCT start condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>STARTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 21).</description>
            <name>STARTMSK_H</name>
          </field>
        </fields>
        <name>START</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>SCT counter register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter.</description>
            <name>CTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter.</description>
            <name>CTR_H</name>
          </field>
        </fields>
        <name>COUNT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>SCT state register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_H</name>
          </field>
        </fields>
        <name>STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>SCT input register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 0.</description>
            <name>AIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 1.</description>
            <name>AIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 2.</description>
            <name>AIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 3.</description>
            <name>AIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 0 state synchronized to the SCT clock.</description>
            <name>SIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 1 state synchronized to the SCT clock.</description>
            <name>SIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 2 state synchronized to the SCT clock.</description>
            <name>SIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 3 state synchronized to the SCT clock.</description>
            <name>SIN3</name>
          </field>
        </fields>
        <name>INPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>SCT match/capture registers mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Each bit controls one pair of match/capture registers (register 0 = bit 0, register 1 = bit 1,..., register 4 = bit 4).  0 = registers operate as match registers. 1 = registers operate as capture registers.</description>
            <name>REGMOD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Each bit controls one pair of match/capture registers (register 0 = bit 16, register 1 = bit 17,..., register 4 = bit 20). 0 = registers operate as match registers. 1 = registers operate as capture registers.</description>
            <name>REGMOD_H</name>
          </field>
        </fields>
        <name>REGMODE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>SCT output register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Writing a 1 to bit n makes the corresponding output HIGH. 0 makes the corresponding output LOW (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>OUT</name>
          </field>
        </fields>
        <name>OUTPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>SCT output counter direction control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR3</name>
          </field>
        </fields>
        <name>OUTPUTDIRCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>SCT conflict resolution register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR0 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR0 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O0RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR1 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR1 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O1RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR2 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output n (or set based on the SETCLR2 field).</description>
                <name>CLEAR_OUTPUT_N_OR_S</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O2RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR3 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR3 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O3RES</name>
          </field>
        </fields>
        <name>RES</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>SCT DMA request 0 register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets DMA request 0 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>DEV_0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit makes the SCT set DMA request 0 when it loads the  Match_L/Unified registers from the Reload_L/Unified registers.</description>
            <name>DRL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This read-only bit indicates the state of DMA Request 0</description>
            <name>DRQ0</name>
          </field>
        </fields>
        <name>DMAREQ0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>SCT DMA request 1 register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets DMA request 1 (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>DEV_1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit makes the SCT set DMA request 1 when it loads the  Match L/Unified registers from the Reload L/Unified registers.</description>
            <name>DRL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This read-only bit indicates the state of DMA Request 1.</description>
            <name>DRQ1</name>
          </field>
        </fields>
        <name>DMAREQ1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>SCT event enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>The SCT requests interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>IEN</name>
          </field>
        </fields>
        <name>EVEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>SCT event flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>FLAG</name>
          </field>
        </fields>
        <name>EVFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>SCT conflict enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>The SCT requests interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>NCEN</name>
          </field>
        </fields>
        <name>CONEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>SCT conflict flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Bit n is one if a no-change conflict event occurred on output n since  reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>NCFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing CTR  L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the  L/U counter was not halted. A word write to certain L  and H registers can be half successful and half unsuccessful.</description>
            <name>BUSERRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing CTR H,  STATE H, MATCH H, or the Output register when the H  counter was not halted.</description>
            <name>BUSERRH</name>
          </field>
        </fields>
        <name>CONFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV0_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV1_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV2_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x318</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV3_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV4_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x328</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV5_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV0_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV1_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV2_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV3_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x324</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV4_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x32C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV5_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT0_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x508</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT1_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x510</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT2_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x518</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT3_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x504</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT0_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT1_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x514</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT2_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x51C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT3_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT match reload value register 0 to 4; REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 21).</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV0_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV1_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV2_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x318</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV3_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV4_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x328</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1,..., state 7 = bit 7).</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV5_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV0_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV1_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV2_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV3_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x324</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV4_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x32C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal number (0 to 3) associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV5_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT0_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x508</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT1_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x510</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT2_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x518</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT3_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x504</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT0_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT1_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x514</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT2_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x51C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT3_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x3FFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0xA0000000</baseAddress>
    <description>General Purpose I/O (GPIO) </description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GPIO_PORT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[3]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[4]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[5]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[6]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[7]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[8]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[9]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[10]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[11]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[12]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[13]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[14]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[15]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[16]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[17]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x12</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[18]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x13</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[19]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[20]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x15</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[21]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x16</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[22]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x17</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[23]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[24]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x19</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[25]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1A</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[26]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1B</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[27]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[28]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1D</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[29]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1E</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[30]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1F</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[31]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[32]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[33]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x22</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[34]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x23</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[35]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[36]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x25</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[37]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x26</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[38]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x27</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[39]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[40]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x29</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[41]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2A</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[42]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2B</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[43]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[44]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2D</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[45]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2E</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[46]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2F</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[47]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[48]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[49]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x32</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[50]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x33</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[51]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[52]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x35</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[53]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x36</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[54]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x37</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[55]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[56]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x39</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[57]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3A</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[58]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3B</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[59]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[60]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3D</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[61]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3E</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[62]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3F</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[63]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[64]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x41</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[65]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x42</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[66]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x43</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[67]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[68]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x45</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[69]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x46</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[70]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x47</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[71]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[72]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x49</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[73]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4A</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[74]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4B</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[75]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[76]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4D</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[77]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4E</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[78]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4F</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[79]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[80]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x51</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[81]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x52</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[82]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x53</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[83]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[84]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x55</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[85]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x56</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[86]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x57</addressOffset>
        <description>Byte pin registers</description>
        <displayName>B[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port 2. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B[87]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1000</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1004</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1008</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[3]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1010</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[4]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1014</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[5]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1018</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[6]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x101C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[7]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1020</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[8]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1024</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[9]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1028</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[10]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x102C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[11]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1030</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[12]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1034</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[13]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1038</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[14]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x103C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[15]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1040</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[16]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1044</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[17]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1048</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[18]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[19]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1050</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[20]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1054</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[21]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1058</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[22]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x105C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[23]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1060</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[24]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1064</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[25]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1068</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[26]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x106C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[27]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1070</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[28]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1074</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[29]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1078</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[30]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x107C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[31]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1080</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[32]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1084</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[33]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1088</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[34]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[35]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1090</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[36]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1094</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[37]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1098</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[38]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x109C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[39]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A0</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[40]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A4</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[41]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A8</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[42]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10AC</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[43]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B0</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[44]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B4</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[45]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B8</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[46]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10BC</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[47]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C0</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[48]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C4</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[49]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C8</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[50]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10CC</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[51]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10D0</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[52]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10D4</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[53]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10D8</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[54]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10DC</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[55]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10E0</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[56]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10E4</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[57]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10E8</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[58]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10EC</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[59]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10F0</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[60]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10F4</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[61]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10F8</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[62]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10FC</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[63]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1100</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[64]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1104</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[65]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1108</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[66]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[67]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1110</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[68]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1114</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[69]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1118</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[70]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x111C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[71]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1120</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[72]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1124</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[73]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1128</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[74]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x112C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[75]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1130</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[76]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1134</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[77]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1138</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[78]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x113C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[79]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1140</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[80]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1144</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[81]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1148</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[82]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x114C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[83]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1150</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[84]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1154</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[85]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1158</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[86]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x115C</addressOffset>
        <description>Word pin registers </description>
        <displayName>W[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin PIOm_n is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit. One register for each port pin: m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W[87]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2000</addressOffset>
        <description>Port Direction registers </description>
        <displayName>DIR[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP31</name>
          </field>
        </fields>
        <name>DIR[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2004</addressOffset>
        <description>Port Direction registers </description>
        <displayName>DIR[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP31</name>
          </field>
        </fields>
        <name>DIR[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2008</addressOffset>
        <description>Port Direction registers </description>
        <displayName>DIR[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects pin direction for pin PIOm_n (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = input. 1 = output.</description>
            <name>DIRP31</name>
          </field>
        </fields>
        <name>DIR[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2080</addressOffset>
        <description>Port Mask register </description>
        <displayName>MASK[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP31</name>
          </field>
        </fields>
        <name>MASK[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2084</addressOffset>
        <description>Port Mask register </description>
        <displayName>MASK[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP31</name>
          </field>
        </fields>
        <name>MASK[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2088</addressOffset>
        <description>Port Mask register </description>
        <displayName>MASK[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP31</name>
          </field>
        </fields>
        <name>MASK[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2100</addressOffset>
        <description>Port pin register </description>
        <displayName>PIN[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT31</name>
          </field>
        </fields>
        <name>PIN[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2104</addressOffset>
        <description>Port pin register </description>
        <displayName>PIN[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT31</name>
          </field>
        </fields>
        <name>PIN[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2108</addressOffset>
        <description>Port pin register </description>
        <displayName>PIN[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = PIOm_0, bit 1 = PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT31</name>
          </field>
        </fields>
        <name>PIN[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2180</addressOffset>
        <description>Masked port register </description>
        <displayName>MPIN[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP31</name>
          </field>
        </fields>
        <name>MPIN[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2184</addressOffset>
        <description>Masked port register </description>
        <displayName>MPIN[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP31</name>
          </field>
        </fields>
        <name>MPIN[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2188</addressOffset>
        <description>Masked port register </description>
        <displayName>MPIN[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP16</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP17</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP18</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP19</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP20</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP21</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP22</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP24</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP25</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP26</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP27</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP28</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP29</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP30</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Masked port register (bit 0 = PIOm_0, bit 1 =PIOm_1, ..., bit 31 = PIOm_31). m = port 0 to 2; n = pin 0 to 31 for port 0 and 1 and pin 0 to 11 for port2.  0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP31</name>
          </field>
        </fields>
        <name>MPIN[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2200</addressOffset>
        <description>Write: Set port  register Read: port output bits </description>
        <displayName>SET[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP031</name>
          </field>
        </fields>
        <name>SET[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2204</addressOffset>
        <description>Write: Set port  register Read: port output bits </description>
        <displayName>SET[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP031</name>
          </field>
        </fields>
        <name>SET[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2208</addressOffset>
        <description>Write: Set port  register Read: port output bits </description>
        <displayName>SET[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP031</name>
          </field>
        </fields>
        <name>SET[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2280</addressOffset>
        <description>Clear port</description>
        <displayName>CLR[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP031</name>
          </field>
        </fields>
        <name>CLR[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2284</addressOffset>
        <description>Clear port</description>
        <displayName>CLR[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP031</name>
          </field>
        </fields>
        <name>CLR[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2288</addressOffset>
        <description>Clear port</description>
        <displayName>CLR[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP031</name>
          </field>
        </fields>
        <name>CLR[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2300</addressOffset>
        <description>Toggle port </description>
        <displayName>NOT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP031</name>
          </field>
        </fields>
        <name>NOT[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2304</addressOffset>
        <description>Toggle port </description>
        <displayName>NOT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP031</name>
          </field>
        </fields>
        <name>NOT[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2308</addressOffset>
        <description>Toggle port </description>
        <displayName>NOT[%s]</displayName>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP00</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP02</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP03</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP04</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP05</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP06</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP07</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP08</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP09</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP010</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP011</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP012</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP013</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP014</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP015</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP016</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP017</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP018</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP019</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP020</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP021</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP022</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP023</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP024</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP025</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP026</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP027</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP028</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP029</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP030</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP031</name>
          </field>
        </fields>
        <name>NOT[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0xA0004000</baseAddress>
    <description> Pin interrupt
    and pattern match (PINT) </description>
    <groupName>PINT</groupName>
    <interrupts>
      <interrupt>
        <name>PIN_INT0</name>
        <value>0x0</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT1</name>
        <value>0x1</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT2</name>
        <value>0x2</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT3</name>
        <value>0x3</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT4</name>
        <value>0x4</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT5</name>
        <value>0x5</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT6</name>
        <value>0x6</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT7</name>
        <value>0x7</value>
      </interrupt>
    </interrupts>
    <name>PINT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Pin Interrupt Mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE7</name>
          </field>
        </fields>
        <name>ISEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Pin interrupt level or rising edge  interrupt enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL7</name>
          </field>
        </fields>
        <name>IENR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Pin interrupt level or rising edge  interrupt set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL7</name>
          </field>
        </fields>
        <name>SIENR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Pin interrupt level (rising edge interrupt) clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL7</name>
          </field>
        </fields>
        <name>CIENR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin interrupt active level or falling edge  interrupt enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF7</name>
          </field>
        </fields>
        <name>IENF</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Pin interrupt active level or falling edge  interrupt set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF7</name>
          </field>
        </fields>
        <name>SIENF</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Pin interrupt active level or falling edge  interrupt clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF7</name>
          </field>
        </fields>
        <name>CIENF</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Pin interrupt rising edge register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET7</name>
          </field>
        </fields>
        <name>RISE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Pin interrupt falling edge register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET7</name>
          </field>
        </fields>
        <name>FALL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Pin interrupt status register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT7</name>
          </field>
        </fields>
        <name>IST</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Pattern match interrupt control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pin interrupt. Interrupts are driven in response to the standard pin interrupt function</description>
                <name>PIN_INTERRUPT_INTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pattern match. Interrupts are driven in response to pattern matches.</description>
                <name>PATTERN_MATCH_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL_PMATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the RXEV output to the ARM cpu and/or to a GPIO output when the specified boolean expression evaluates to true.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. RXEV output to the cpu is disabled.</description>
                <name>DISABLED_RXEV_OUTPU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. RXEV output to the cpu is enabled.</description>
                <name>ENABLED_RXEV_OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA_RXEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs.</description>
            <name>PMAT</name>
          </field>
        </fields>
        <name>PMCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Pattern match interrupt bit-slice source register</description>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 0</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the output of pin interrupt select register 0 as the source to bit slice 0.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the output of pin interrupt select register 1 as the source to bit slice 0.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the output of pin interrupt select register 2 as the source to bit slice 0.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the output of pin interrupt select register 3 as the source to bit slice 0.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the output of pin interrupt select register 4 as the source to bit slice 0.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the output of pin interrupt select register 5 as the source to bit slice 0.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the output of pin interrupt select register 6 as the source to bit slice 0.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the output of pin interrupt select register 7 as the source to bit slice 0.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 1.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 1.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 1.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 1.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 1.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 1.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 1.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 1.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 2</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 2.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 2.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 2.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 2.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 2.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 2.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 2.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 2.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 3</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 3.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 3.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 3.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 3.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 3.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 3.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 3.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 3.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 4</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 4.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 4.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 4.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 4.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 4.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 4.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 4.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 4.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 5</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 5.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 5.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 5.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 5.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 5.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 5.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 5.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 5.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 6</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 6.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 6.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 6.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 6.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 6.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 6.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 6.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 6.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 7</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 7.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 7.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 7.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 7.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 7.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 7.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 7.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 7.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC7</name>
          </field>
        </fields>
        <name>PMSRC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Pattern match interrupt bit slice configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>A 1 in any bit of this field causes the corresponding bit slice to be the final component of a product term in the boolean expression. This has two effects: 1. The interrupt request associated with this bit-slice will be asserted whenever a match to that product term is detected. 2. The next bit slice will start a new, independent product term in the boolean expression (i.e. an OR will be inserted in the boolean expression following the element controlled by this bit slice).</description>
            <name>PROD_ENDPTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 4.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 5.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 6.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice 7.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_HIGH_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edgeMatch occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_EDGEMA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_FALLING_EDGE_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3) . This bit is cleared after one clock cycle.</description>
                <name>EVENT_NON_STICKY_RI</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG7</name>
          </field>
        </fields>
        <name>PMCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<size>0x20</size>
<version>0.8</version>
<width>0x20</width></device>
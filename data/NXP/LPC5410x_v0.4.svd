<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd"><addressUnitBits>0x8</addressUnitBits>
<cpu>
  <dcachePresent>
    <dcachePresen></dcachePresen>
  </dcachePresent>
  <deviceNumInterrupts>0x0</deviceNumInterrupts>
  <dtcmPresent>
    <dtcmPresen></dtcmPresen>
  </dtcmPresent>
  <endian>little</endian>
  <fpuPresent>0x1</fpuPresent>
  <icachePresent>
    <icachePresen></icachePresen>
  </icachePresent>
  <itcmPresent>
    <itcmPresen></itcmPresen>
  </itcmPresent>
  <mpuPresent>0x1</mpuPresent>
  <name>CM4</name>
  <nvicPrioBits>0x3</nvicPrioBits>
  <revision>r0p0</revision>
  <sauNumRegions>0x0</sauNumRegions>
  <vendorSystickConfig>0x0</vendorSystickConfig>
</cpu>
<description>LPC5410x Cortex-M4 MCU; Cortex-M0+ coprocessor</description>
<name>LPC5410x</name>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x2304</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x1C000000</baseAddress>
    <description>General Purpose I/O </description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GPIO</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B16</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B17</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x12</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B18</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x13</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B19</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B20</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x15</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B21</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x16</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B22</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x17</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B23</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B24</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x19</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B25</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1A</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B26</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1B</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B27</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B28</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1D</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B29</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1E</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B30</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1F</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B31</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B32</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B33</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x22</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B34</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x23</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B35</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B36</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x25</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B37</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x26</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B38</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x27</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B39</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B40</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x29</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B41</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2A</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B42</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2B</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B43</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B44</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2D</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B45</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2E</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B46</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2F</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B47</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B48</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31</addressOffset>
        <description>Byte pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin PIOm_n, regardless of direction,
            								masking, or alternate function, except that pins configured as
            								analog I/O always read as 0. One register for each port pin.
            								Supported pins depends on the specific device and package. Write:
            								loads the pins output bit. One register for each port pin. Supported
            								pins depends on the specific device and package.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B49</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x1</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1000</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1004</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1008</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1010</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1014</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1018</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x101C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1020</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1024</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1028</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x102C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1030</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1034</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1038</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x103C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1040</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W16</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1044</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W17</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1048</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W18</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W19</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1050</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W20</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1054</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W21</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1058</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W22</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x105C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W23</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1060</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W24</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1064</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W25</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1068</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W26</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x106C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W27</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1070</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W28</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1074</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W29</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1078</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W30</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x107C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W31</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1080</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W32</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1084</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W33</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1088</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W34</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W35</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1090</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W36</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1094</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W37</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1098</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W38</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x109C</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W39</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A0</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W40</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A4</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W41</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A8</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W42</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10AC</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W43</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B0</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W44</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B4</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W45</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B8</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W46</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10BC</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W47</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C0</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W48</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C4</addressOffset>
        <description>Word pin registers port 0/1; pins PIO0_0 to PIO1_8</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin PIOm_n is LOW. Write 0: clear output bit. Read
            								0xFFFF FFFF: pin PIOm_n is HIGH. Write any value 0x0000 0001 to
            								0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read.
            								Writing any value other than 0 will set the output bit. One register
            								for each port pin. Supported pins depends on the specific device and
            								package.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W49</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2000</addressOffset>
        <description>Direction registers port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Selects pin direction for pin PIOm_n. Supported pins
            								depends on the specific device and package. 0 = input. 1 =
            								output.</description>
            <name>DIRP</name>
          </field>
        </fields>
        <name>DIR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2004</addressOffset>
        <description>Direction registers port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Selects pin direction for pin PIOm_n. Supported pins
            								depends on the specific device and package. 0 = input. 1 =
            								output.</description>
            <name>DIRP</name>
          </field>
        </fields>
        <name>DIR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2080</addressOffset>
        <description>Mask register port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in
            								the MPORT register. Supported pins depends on the specific device
            								and package. 0 = Read MPORT: pin state; write MPORT: load output
            								bit. 1 = Read MPORT: 0; write MPORT: output bit not
            								affected.</description>
            <name>MASKP</name>
          </field>
        </fields>
        <name>MASK0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2084</addressOffset>
        <description>Mask register port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Controls which bits corresponding to PIOm_n are active in
            								the MPORT register. Supported pins depends on the specific device
            								and package. 0 = Read MPORT: pin state; write MPORT: load output
            								bit. 1 = Read MPORT: 0; write MPORT: output bit not
            								affected.</description>
            <name>MASKP</name>
          </field>
        </fields>
        <name>MASK1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2100</addressOffset>
        <description>Port pin register port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Reads pin states or loads output bits. Supported pins
            								depends on the specific device and package. 0 = Read: pin is low;
            								write: clear output bit. 1 = Read: pin is high; write: set output
            								bit.</description>
            <name>PORT</name>
          </field>
        </fields>
        <name>PIN0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2104</addressOffset>
        <description>Port pin register port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Reads pin states or loads output bits. Supported pins
            								depends on the specific device and package. 0 = Read: pin is low;
            								write: clear output bit. 1 = Read: pin is high; write: set output
            								bit.</description>
            <name>PORT</name>
          </field>
        </fields>
        <name>PIN1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2180</addressOffset>
        <description>Masked port register port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Masked port register. Supported pins depends on the
            								specific device and package. 0 = Read: pin is LOW and/or the
            								corresponding bit in the MASK register is 1; write: clear output bit
            								if the corresponding bit in the MASK register is 0. 1 = Read: pin is
            								HIGH and the corresponding bit in the MASK register is 0; write: set
            								output bit if the corresponding bit in the MASK register is
            								0.</description>
            <name>MPORTP</name>
          </field>
        </fields>
        <name>MPIN0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2184</addressOffset>
        <description>Masked port register port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Masked port register. Supported pins depends on the
            								specific device and package. 0 = Read: pin is LOW and/or the
            								corresponding bit in the MASK register is 1; write: clear output bit
            								if the corresponding bit in the MASK register is 0. 1 = Read: pin is
            								HIGH and the corresponding bit in the MASK register is 0; write: set
            								output bit if the corresponding bit in the MASK register is
            								0.</description>
            <name>MPORTP</name>
          </field>
        </fields>
        <name>MPIN1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2200</addressOffset>
        <description>Write: Set register for port 0/1 Read: output bits for port
        						0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read or set output bits. Supported pins depends on the
            								specific device and package. 0 = Read: output bit: write: no
            								operation. 1 = Read: output bit; write: set output
            								bit.</description>
            <name>SETP</name>
          </field>
        </fields>
        <name>SET0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2204</addressOffset>
        <description>Write: Set register for port 0/1 Read: output bits for port
        						0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read or set output bits. Supported pins depends on the
            								specific device and package. 0 = Read: output bit: write: no
            								operation. 1 = Read: output bit; write: set output
            								bit.</description>
            <name>SETP</name>
          </field>
        </fields>
        <name>SET1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2280</addressOffset>
        <description>Clear port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Clear output bits. Supported pins depends on the specific
            								device and package. 0 = No operation. 1 = Clear output
            								bit.</description>
            <name>CLRP</name>
          </field>
        </fields>
        <name>CLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2284</addressOffset>
        <description>Clear port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Clear output bits. Supported pins depends on the specific
            								device and package. 0 = No operation. 1 = Clear output
            								bit.</description>
            <name>CLRP</name>
          </field>
        </fields>
        <name>CLR1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2300</addressOffset>
        <description>Toggle port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Toggle output bits. Supported pins depends on the specific
            								device and package. 0 = no operation. 1 = Toggle output
            								bit.</description>
            <name>NOTP</name>
          </field>
        </fields>
        <name>NOT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2304</addressOffset>
        <description>Toggle port 0/1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Toggle output bits. Supported pins depends on the specific
            								device and package. 0 = no operation. 1 = Toggle output
            								bit.</description>
            <name>NOTP</name>
          </field>
        </fields>
        <name>NOT1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x1C004000</baseAddress>
    <description>DMA controller</description>
    <groupName>DMA</groupName>
    <interrupts>
      <interrupt>
        <name>DMA</name>
        <value>0x3</value>
      </interrupt>
    </interrupts>
    <name>DMA</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>DMA control.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DMA controller master enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The DMA controller is disabled. This
                										clears any triggers that were asserted at the point when
                										disabled, but does not prevent re-triggering when the DMA
                										controller is re-enabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The DMA controller is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Interrupt status.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Summarizes whether any enabled interrupts (other than error
            								interrupts) are pending.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not pending. No enabled interrupts are
                										pending.</description>
                <name>NOT_PENDING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. At least one enabled interrupt is
                										pending.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACTIVEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Summarizes whether any error interrupts are
            								pending.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not pending. No error interrupts are
                										pending.</description>
                <name>NOT_PENDING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. At least one error interrupt is
                										pending.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACTIVEERRINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SRAM address of the channel configuration table.</description>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x17</bitWidth>
            <description>Address bits 31:9 of the beginning of the DMA descriptor
            								table. For 18 channels, the table must begin on a 512 byte
            								boundary.</description>
            <name>OFFSET</name>
          </field>
        </fields>
        <name>SRAMBASE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Channel Enable read and Set for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Enable for DMA channels. Bit n enables or disables DMA
            								channel n. 0 = disabled. 1 = enabled.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>ENABLESET0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x28</addressOffset>
        <description>Channel Enable Clear for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Writing ones to this register clears the corresponding bits
            								in ENABLESET0. Bit n clears the channel enable bit n.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>ENABLECLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Channel Active status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Active flag for DMA channel n. Bit n corresponds to DMA
            								channel n. 0 = not active. 1 = active.</description>
            <name>ACT</name>
          </field>
        </fields>
        <name>ACTIVE0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Channel Busy status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Busy flag for DMA channel n. Bit n corresponds to DMA
            								channel n. 0 = not busy. 1 = busy.</description>
            <name>BSY</name>
          </field>
        </fields>
        <name>BUSY0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Error Interrupt status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Error Interrupt flag for DMA channel n. Bit n corresponds
            								to DMA channel n. 0 = error interrupt is not active. 1 = error
            								interrupt is active.</description>
            <name>ERR</name>
          </field>
        </fields>
        <name>ERRINT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Interrupt Enable read and Set for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Interrupt Enable read and set for DMA channel n. Bit n
            								corresponds to DMA channel n. 0 = interrupt for DMA channel is
            								disabled. 1 = interrupt for DMA channel is enabled.</description>
            <name>INTEN</name>
          </field>
        </fields>
        <name>INTENSET0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x50</addressOffset>
        <description>Interrupt Enable Clear for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Writing ones to this register clears corresponding bits in
            								the INTENSET0. Bit n corresponds to DMA channel n.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>INTENCLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Interrupt A status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Interrupt A status for DMA channel n. Bit n corresponds to
            								DMA channel n. 0 = the DMA channel interrupt A is not active. 1 =
            								the DMA channel interrupt A is active.</description>
            <name>IA</name>
          </field>
        </fields>
        <name>INTA0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>Interrupt B status for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Interrupt B status for DMA channel n. Bit n corresponds to
            								DMA channel n. 0 = the DMA channel interrupt B is not active. 1 =
            								the DMA channel interrupt B is active.</description>
            <name>IB</name>
          </field>
        </fields>
        <name>INTB0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x68</addressOffset>
        <description>Set ValidPending control bits for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>SETVALID control for DMA channel n. Bit n corresponds to
            								DMA channel n. 0 = no effect. 1 = sets the VALIDPENDING control bit
            								for DMA channel n.</description>
            <name>SV</name>
          </field>
        </fields>
        <name>SETVALID0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x70</addressOffset>
        <description>Set Trigger control bits for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Set Trigger control bit for DMA channel 0. Bit n
            								corresponds to DMA channel n. 0 = no effect. 1 = sets the TRIG bit
            								for DMA channel n.</description>
            <name>TRIG</name>
          </field>
        </fields>
        <name>SETTRIG0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x78</addressOffset>
        <description>Channel Abort control for all DMA channels.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Abort control for DMA channel 0. Bit n corresponds to DMA
            								channel n. 0 = no effect. 1 = aborts DMA operations on channel
            								n.</description>
            <name>ABORTCTRL</name>
          </field>
        </fields>
        <name>ABORT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x410</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x420</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x430</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x440</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x450</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x460</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x470</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x480</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x490</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4A0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4B0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4D0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4E0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4F0</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG16</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x510</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG17</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x520</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG18</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x530</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG19</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x540</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG20</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x550</addressOffset>
        <description>Configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Peripheral request Enable. If a DMA channel is used to
            								perform a memory-to-memory move, any peripheral DMA request
            								associated with that channel can be disabled to prevent any
            								interaction between the peripheral and the DMA
            								controller.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Peripheral DMA requests are
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Peripheral DMA requests are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PERIPHREQEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware Triggering Enable for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hardware triggering is not
                										used.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Use hardware triggering.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HWTRIGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Polarity. Selects the polarity of a hardware
            								trigger for this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active low - falling edge. Hardware trigger is
                										active low or falling edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_LOW__FALLING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active high - rising edge. Hardware trigger is
                										active high or rising edge triggered, based on
                										TRIGTYPE.</description>
                <name>ACTIVE_HIGH__RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Type. Selects hardware trigger as edge triggered or
            								level triggered.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge. Hardware trigger is edge triggered. Transfers
                										will be initiated and completed, as specified for a single
                										trigger.</description>
                <name>EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level. Hardware trigger is level triggered. Note
                										that when level triggering without burst (BURSTPOWER = 0) is
                										selected, only hardware triggers should be used on that
                										channel. Transfers continue as long as the trigger level is
                										asserted. Once the trigger is de-asserted, the transfer will
                										be paused until the trigger is, again, asserted. However,
                										the transfer will not be paused until any remaining
                										transfers within the current BURSTPOWER length are
                										completed.</description>
                <name>LEVEL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGTYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger Burst. Selects whether hardware triggers cause a
            								single or burst transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Single transfer. Hardware trigger causes a single
                										transfer.</description>
                <name>SINGLE_TRANSFER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Burst transfer. When the trigger for this channel
                										is set to edge triggered, a hardware trigger causes a burst
                										transfer, as defined by BURSTPOWER. When the trigger for
                										this channel is set to level triggered, a hardware trigger
                										causes transfers to continue as long as the trigger is
                										asserted, unless the transfer is complete.</description>
                <name>BURST_TRANSFER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGBURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Burst Power is used in two ways. It always selects the
            								address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are
            								selected (see descriptions elsewhere in this register). When the
            								TRIGBURST field elsewhere in this register = 1, Burst Power selects
            								how many transfers are performed for each DMA trigger. This can be
            								used, for example, with peripherals that contain a FIFO that can
            								initiate a DMA operation when the FIFO reaches a certain level.
            								0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst
            								size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds
            								to the maximum supported transfer count. others: not supported. The
            								total transfer length as defined in the XFERCOUNT bits in the
            								XFERCFG register must be an even multiple of the burst
            								size.</description>
            <name>BURSTPOWER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Source Burst Wrap. When enabled, the source data address
            								for the DMA is wrapped, meaning that the source address range for
            								each burst will be the same. As an example, this could be used to
            								read several sequential registers from a peripheral for each DMA
            								burst, reading the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Source burst wrapping is not enabled for
                										this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Source burst wrapping is enabled for this
                										DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Destination Burst Wrap. When enabled, the destination data
            								address for the DMA is wrapped, meaning that the destination address
            								range for each burst will be the same. As an example, this could be
            								used to write several sequential registers to a peripheral for each
            								DMA burst, writing the same registers again for each
            								burst.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Destination burst wrapping is not enabled
                										for this DMA channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Destination burst wrapping is enabled for
                										this DMA channel.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTBURSTWRAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Priority of this channel when multiple DMA requests are
            								pending. Eight priority levels are supported. 0x0 = highest
            								priority. 0x7 = lowest priority.</description>
            <name>CHPRIORITY</name>
          </field>
        </fields>
        <name>CFG21</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x404</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x414</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x424</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x434</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x444</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x454</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x464</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x474</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x484</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x494</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4A4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4B4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4D4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4E4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4F4</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x504</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT16</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x514</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT17</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x524</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT18</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x534</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT19</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x544</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT20</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x554</addressOffset>
        <description>Control and status register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid pending flag for this channel. This bit is set when a
            								1 is written to the corresponding bit in the related SETVALID
            								register when CFGVALID = 1 for the same channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on DMA
                										operation.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid pending.</description>
                <name>VALID_PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VALIDPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger flag. Indicates that the trigger for this channel
            								is currently set. This bit is cleared at the end of an entire
            								transfer or upon reload when CLRTRIG = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not triggered. The trigger for this DMA channel is
                										not set. DMA operations will not be carried
                										out.</description>
                <name>NOT_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Triggered. The trigger for this DMA channel is set.
                										DMA operations will be carried out.</description>
                <name>TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTLSTAT21</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x408</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x418</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x428</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x438</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x448</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x458</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x468</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x478</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x488</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x498</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4A8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4B8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4D8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4E8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4F8</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x508</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG16</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x518</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG17</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x528</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG18</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x538</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG19</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x548</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG20</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x558</addressOffset>
        <description>Transfer configuration register for DMA channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Valid flag. This bit indicates whether the
            								current channel descriptor is valid and can potentially be acted
            								upon, if all other activation criteria are fulfilled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not valid. The channel descriptor is not considered
                										valid until validated by an associated SETVALID0
                										setting.</description>
                <name>NOT_VALID</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Valid. The current channel descriptor is considered
                										valid.</description>
                <name>VALID</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFGVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the channel's control structure will be
            								reloaded when the current descriptor is exhausted. Reloading allows
            								ping-pong and linked transfers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do not reload the channels' control
                										structure when the current descriptor is
                										exhausted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Reload the channels' control structure
                										when the current descriptor is exhausted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RELOAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not set. When written by software, the trigger for
                										this channel is not set. A new trigger, as defined by the
                										HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                										channel.</description>
                <name>NOT_SET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set, When written by software, the trigger for this
                										channel is set immediately. This feature should not be used
                										with level triggering when TRIGBURST = 0.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Trigger.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not cleared. The trigger is not cleared when this
                										descriptor is exhausted. If there is a reload, the next
                										descriptor will be started.</description>
                <name>NOT_CLEARED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Cleared. The trigger is cleared when this
                										descriptor is exhausted.</description>
                <name>CLEARED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag A for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTA flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set Interrupt flag B for this channel. There is no hardware
            								distinction between interrupt A and B. They can be used by software
            								to assist with more complex descriptor usage. By convention,
            								interrupt A may be used when only one interrupt flag is
            								needed.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. The INTB flag for this channel will be set
                										when the current descriptor is exhausted.</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETINTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer width used for this DMA channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit. 8-bit transfers are performed (8-bit source
                										reads and destination writes).</description>
                <name>8_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit. 6-bit transfers are performed (16-bit
                										source reads and destination writes).</description>
                <name>16_BIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit. 32-bit transfers are performed (32-bit
                										source reads and destination writes).</description>
                <name>32_BIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved. Reserved setting, do not
                										use.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the source address is incremented for
            								each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The source address is not incremented
                										for each transfer. This is the usual case when the source is
                										a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The source address is incremented by the
                										amount specified by Width for each transfer. This is the
                										usual case when the source is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The source address is incremented by 2
                										times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The source address is incremented by 4
                										times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRCINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Determines whether the destination address is incremented
            								for each DMA transfer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No increment. The destination address is not
                										incremented for each transfer. This is the usual case when
                										the destination is a peripheral device.</description>
                <name>NO_INCREMENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 x width. The destination address is incremented
                										by the amount specified by Width for each transfer. This is
                										the usual case when the destination is memory.</description>
                <name>1_X_WIDTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 x width. The destination address is incremented
                										by 2 times the amount specified by Width for each
                										transfer.</description>
                <name>2_X_WIDTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 x width. The destination address is incremented
                										by 4 times the amount specified by Width for each
                										transfer.</description>
                <name>4_X_WIDTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSTINC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Total number of transfers to be performed, minus 1 encoded.
            								The number of bytes transferred is: (XFERCOUNT + 1) x data width (as
            								defined by the WIDTH field). The DMA controller uses this bit field
            								during transfer to count down. Hence, it cannot be used by software
            								to read back the size of the transfer, for instance, in an interrupt
            								handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a
            								total of 2 transfers will be performed. ... 0x3FF = a total of 1,024
            								transfers will be performed.</description>
            <name>XFERCOUNT</name>
          </field>
        </fields>
        <name>XFERCFG21</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x1C010000</baseAddress>
    <description>CRC engine</description>
    <groupName>CRC</groupName>
    <interrupts></interrupts>
    <name>CRC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>CRC mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CRC polynom: 1X= CRC-32 polynomial 01= CRC-16 polynomial
            								00= CRC-CCITT polynomial</description>
            <name>CRC_POLY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data bit order: 1= Bit order reverse for CRC_WR_DATA (per
            								byte) 0= No bit order reverse for CRC_WR_DATA (per
            								byte)</description>
            <name>BIT_RVS_WR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data complement: 1= 1s complement for CRC_WR_DATA 0= No 1s
            								complement for CRC_WR_DATA</description>
            <name>CMPL_WR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRC sum bit order: 1= Bit order reverse for CRC_SUM 0= No
            								bit order reverse for CRC_SUM</description>
            <name>BIT_RVS_SUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRC sum complement: 1= 1s complement for CRC_SUM 0=No 1s
            								complement for CRC_SUM</description>
            <name>CMPL_SUM</name>
          </field>
        </fields>
        <name>MODE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>CRC seed register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>A write access to this register will load CRC seed value to
            								CRC_SUM register with selected bit order and 1s complement
            								pre-processes. A write access to this register will overrule the CRC
            								calculation in progresses.</description>
            <name>CRC_SEED</name>
          </field>
        </fields>
        <name>SEED</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>CRC checksum register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>The most recent CRC sum can be read through this register
            								with selected bit order and 1s complement
            								post-processes.</description>
            <name>CRC_SUM</name>
          </field>
        </fields>
        <name>SUM</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>CRC data register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data written to this register will be taken to perform CRC
            								calculation with selected bit order and 1s complement pre-process.
            								Any write size 8, 16 or 32-bit are allowed and accept back-to-back
            								transactions.</description>
            <name>CRC_WR_DATA</name>
          </field>
        </fields>
        <name>WR_DATA</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x1C018000</baseAddress>
    <description>State Configurable Timer/PWM 0 </description>
    <groupName>SCT0</groupName>
    <interrupts>
      <interrupt>
        <name>SCT0</name>
        <value>0x10</value>
      </interrupt>
    </interrupts>
    <name>SCT0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SCT configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT operation</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Dual counter. The SCT operates as two 16-bit
                										counters named L and H.</description>
                <name>DUAL_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Unified counter. The SCT operates as a unified
                										32-bit counter.</description>
                <name>UNIFIED_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UNIFY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>SCT clock mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>System clock. The system clock clocks the SCT and
                										prescalers.</description>
                <name>SYSTEM_CLOCK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Prescaled system clock. The SCT clock is the system
                										clock, but the prescalers are enabled to count only when
                										sampling of the input selected by the CKSEL field finds the
                										selected edge. The minimum pulse width on the clock input is
                										1 bus clock period. This mode is the high-performance
                										sampled-clock mode.</description>
                <name>PRESCALED_SYSTEM_CLO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SCT input. The input selected by CKSEL clocks the
                										SCT and prescalers. The input is synchronized to the system
                										clock and possibly inverted. The minimum pulse width on the
                										clock input is 1 bus clock period. This mode is the
                										low-power sampled-clock mode.</description>
                <name>SCT_INPUT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Prescaled SCT input. The SCT and prescalers are
                										clocked by the input edge selected by the CKSEL field. In
                										this mode, most of the SCT is clocked by the (selected
                										polarity of the) input. The outputs are switched
                										synchronously to the input clock. The input clock rate must
                										be at least half the system clock rate and can be the same
                										or faster than the system clock.</description>
                <name>PRESCALED_SCT_INPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>SCT clock select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0 rising edges.</description>
                <name>INPUT_0_RISING_EDGES</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0 falling edges.</description>
                <name>INPUT_0_FALLING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1 rising edges.</description>
                <name>INPUT_1_RISING_EDGES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1 falling edges.</description>
                <name>INPUT_1_FALLING_EDGE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2 rising edges.</description>
                <name>INPUT_2_RISING_EDGES</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2 falling edges.</description>
                <name>INPUT_2_FALLING_EDGE</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3 rising edges.</description>
                <name>INPUT_3_RISING_EDGES</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3 falling edges.</description>
                <name>INPUT_3_FALLING_EDGE</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4 rising edges.</description>
                <name>INPUT_4_RISING_EDGES</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4 falling edges.</description>
                <name>INPUT_4_FALLING_EDGE</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5 rising edges.</description>
                <name>INPUT_5_RISING_EDGES</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5 falling edges.</description>
                <name>INPUT_5_FALLING_EDGE</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6 rising edges.</description>
                <name>INPUT_6_RISING_EDGES</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6 falling edges.</description>
                <name>INPUT_6_FALLING_EDGE</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7 rising edges.</description>
                <name>INPUT_7_RISING_EDGES</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7 falling edges.</description>
                <name>INPUT_7_FALLING_EDGE</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the lower match registers from
            								being reloaded from their respective reload registers. Software can
            								write to set or clear this bit at any time. This bit applies to both
            								the higher and lower registers when the UNIFY bit is
            								set.</description>
            <name>NORELOAD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the higher match registers from
            								being reloaded from their respective reload registers. Software can
            								write to set or clear this bit at any time. This bit is not used
            								when the UNIFY bit is set.</description>
            <name>NORELOAD_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Synchronization for input n (bit 9 = input 0, bit 10 =
            								input 1,..., bit 14 = input 5). A 1 in one of these bits subjects
            								the corresponding input to synchronization to the SCT clock, before
            								it is used to create an event. If an input is synchronous to the SCT
            								clock, keep its bit 0 for faster response. When the CLKMODE field is
            								1x, the bit in this field, corresponding to the input selected by
            								the CKSEL field, is not used.</description>
            <name>INSYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit causes a match on match register 0 to be
            								treated as a de-facto LIMIT condition without the need to define an
            								associated event. As with any LIMIT event, this automatic limit
            								causes the counter to be cleared to zero in uni-directional mode or
            								to change the direction of count in bi-directional mode. Software
            								can write to set or clear this bit at any time. This bit applies to
            								both the higher and lower registers when the UNIFY bit is
            								set.</description>
            <name>AUTOLIMIT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit will cause a match on match register 0 to
            								be treated as a de-facto LIMIT condition without the need to define
            								an associated event. As with any LIMIT event, this automatic limit
            								causes the counter to be cleared to zero in uni-directional mode or
            								to change the direction of count in bi-directional mode. Software
            								can write to set or clear this bit at any time. This bit is not used
            								when the UNIFY bit is set.</description>
            <name>AUTOLIMIT_H</name>
          </field>
        </fields>
        <name>CONFIG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7E00</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SCT control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the L or unified counter is counting
            								down. Hardware sets this bit when the counter limit is reached and
            								BIDIR is 1. Hardware clears this bit when the counter reaches 0 or
            								when the counter is counting down and a limit condition
            								occurs.</description>
            <name>DOWN_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the L or unified counter
            								does not run but I/O events related to the counter can occur. If
            								such an event matches the mask in the Start register, this bit is
            								cleared and counting resumes.</description>
            <name>STOP_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the L or unified counter does not run
            								and no events can occur. A reset sets this bit. When the HALT_L bit
            								is one, the STOP_L bit is cleared. In order to remove the halt
            								condition and keep the SCT in the stop condition (not running), the
            								halt and stop condition can be changed with one single write to this
            								register. Once set, only software can clear this bit to restore
            								counter operation.</description>
            <name>HALT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the L or unified counter.
            								This bit always reads as 0.</description>
            <name>CLRCTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>L or unified counter direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Unidirectional. The counter counts up to its limit
                										condition, then is cleared to zero.</description>
                <name>UNIDIRECTIONAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bidirectional. The counter counts up to its limit,
                										then counts down to a limit condition or to 0.</description>
                <name>BIDIRECTIONAL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to
            								produce the L or unified counter clock. The counter clock is clocked
            								at the rate of the SCT clock divided by PRE_L+1. Clear the counter
            								(by writing a 1 to the CLRCTR bit) whenever changing the PRE
            								value.</description>
            <name>PRE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the H counter is counting down. Hardware
            								sets this bit when the counter limit is reached and BIDIR is 1.
            								Hardware clears this bit when the counter reaches 0 or when the
            								counter is counting down and a limit condition occurs.</description>
            <name>DOWN_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the H counter does not
            								run but I/O events related to the counter can occur. If such an
            								event matches the mask in the Start register, this bit is cleared
            								and counting resumes.</description>
            <name>STOP_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the H counter does not run and no
            								events can occur. A reset sets this bit. When the HALT_H bit is one,
            								the STOP_H bit is cleared. In order to remove the halt condition and
            								keep the SCT in the stop condition (not running), the halt and stop
            								condition can be changed with one single write to this register.
            								Once set, this bit can only be cleared by software to restore
            								counter operation.</description>
            <name>HALT_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the H counter. This bit
            								always reads as 0.</description>
            <name>CLRCTR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Unidirectional. The H counter counts up to its
                										limit condition, then is cleared to zero.</description>
                <name>UNIDIRECTIONAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bidirectional. The H counter counts up to its
                										limit, then counts down to a limit condition or to
                										0.</description>
                <name>BIDIRECTIONAL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to
            								produce the H counter clock. The counter clock is clocked at the
            								rate of the SCT clock divided by PRELH+1. Clear the counter (by
            								writing a 1 to the CLRCTR bit) whenever changing the PRE
            								value.</description>
            <name>PRE_H</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x40004</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SCT limit register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n is used as a counter limit event
            								for the L or unified counter (event 0 = bit 0, event 1 = bit 1, etc.
            								The number of bits = number of events in this SCT.</description>
            <name>LIMMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n is used as a counter limit event
            								for the H counter (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>LIMMSK_H</name>
          </field>
        </fields>
        <name>LIMIT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SCT halt condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n sets the HALT_L bit in the CTRL
            								register (event 0 = bit 0, event 1 = bit 1, etc. The number of bits
            								= number of events in this SCT.</description>
            <name>HALTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n sets the HALT_H bit in the CTRL
            								register (event 0 = bit 16, event 1 = bit 17, etc. The number of
            								bits = number of events in this SCT.</description>
            <name>HALTMSK_H</name>
          </field>
        </fields>
        <name>HALT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SCT stop condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n sets the STOP_L bit in the CTRL
            								register (event 0 = bit 0, event 1 = bit 1, etc. The number of bits
            								= number of events in this SCT.</description>
            <name>STOPMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n sets the STOP_H bit in the CTRL
            								register (event 0 = bit 16, event 1 = bit 17, etc. The number of
            								bits = number of events in this SCT.</description>
            <name>STOPMSK_H</name>
          </field>
        </fields>
        <name>STOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SCT start condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n clears the STOP_L bit in the CTRL
            								register (event 0 = bit 0, event 1 = bit 1, etc. The number of bits
            								= number of events in this SCT.</description>
            <name>STARTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n clears the STOP_H bit in the CTRL
            								register (event 0 = bit 16, event 1 = bit 17, etc. The number of
            								bits = number of events in this SCT.</description>
            <name>STARTMSK_H</name>
          </field>
        </fields>
        <name>START</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>SCT counter register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit L counter value.
            								When UNIFY = 1, read or write the lower 16 bits of the 32-bit
            								unified counter.</description>
            <name>CTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit H counter value.
            								When UNIFY = 1, read or write the upper 16 bits of the 32-bit
            								unified counter.</description>
            <name>CTR_H</name>
          </field>
        </fields>
        <name>COUNT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>SCT state register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_H</name>
          </field>
        </fields>
        <name>STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>SCT input register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 0 state.Direct read.</description>
            <name>AIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 1 state. Direct read.</description>
            <name>AIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 2 state. Direct read.</description>
            <name>AIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 3 state. Direct read.</description>
            <name>AIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 4 state. Direct read.</description>
            <name>AIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 5 state. Direct read.</description>
            <name>AIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 0 state.</description>
            <name>SIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 1 state.</description>
            <name>SIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 2 state.</description>
            <name>SIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 3 state.</description>
            <name>SIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 4 state.</description>
            <name>SIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 5 state.</description>
            <name>SIN5</name>
          </field>
        </fields>
        <name>INPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>SCT match/capture registers mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Each bit controls one pair of match/capture registers
            								(register 0 = bit 0, register 1 = bit 1,..., etc. 0 = registers
            								operate as match registers. 1 = registers operate as capture
            								registers.</description>
            <name>REGMOD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Each bit controls one pair of match/capture registers
            								(register 0 = bit 16, register 1 = bit 17, etc. 0 = registers
            								operate as match registers. 1 = registers operate as capture
            								registers.</description>
            <name>REGMOD_H</name>
          </field>
        </fields>
        <name>REGMODE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>SCT output register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Writing a 1 to bit n makes the corresponding output HIGH. 0
            								makes the corresponding output LOW (output 0 = bit 0, output 1 = bit
            								1, etc.</description>
            <name>OUT</name>
          </field>
        </fields>
        <name>OUTPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>SCT output counter direction control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 0. Value 0x3 is reserved. Do
            								not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Independent. Set and clear do not depend on any
                										counter.</description>
                <name>INDEPENDENT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>L-Reversed. Set and clear are reversed when counter
                										L or the unified counter is counting down.</description>
                <name>L_REVERSED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H-Reversed. Set and clear are reversed when counter
                										H is counting down. Do not use if UNIFY = 1.</description>
                <name>H_REVERSED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 1. See description of bit
            								0.</description>
            <name>SETCLR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 2. See description of bit
            								0.</description>
            <name>SETCLR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 3. See description of bit
            								0.</description>
            <name>SETCLR3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 4. See description of bit
            								0.</description>
            <name>SETCLR4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 5. See description of bit
            								0.</description>
            <name>SETCLR5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 6. See description of bit
            								0.</description>
            <name>SETCLR6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 7. See description of bit
            								0.</description>
            <name>SETCLR7</name>
          </field>
        </fields>
        <name>OUTPUTDIRCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>SCT conflict resolution register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR0
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR0
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O0RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR1
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR1
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O1RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR2
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR2
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O2RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR3
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR3
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O3RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								4.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR4
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR4
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O4RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								5.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR5
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR5
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O5RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								6.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR6
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR6
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O6RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output
            								7.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set output (or clear based on the SETCLR7
                										field).</description>
                <name>SET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear output (or set based on the SETCLR7
                										field).</description>
                <name>CLEAR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O7RES</name>
          </field>
        </fields>
        <name>RES</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>SCT DMA request 0 register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n sets DMA request 0 (event 0 = bit
            								0, event 1 = bit 1, etc. The number of bits = number of events in
            								this SCT.</description>
            <name>DEV_0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit makes the SCT set DMA request 0 when it
            								loads the Match_L/Unified registers from the Reload_L/Unified
            								registers.</description>
            <name>DRL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This read-only bit indicates the state of DMA Request
            								0</description>
            <name>DRQ0</name>
          </field>
        </fields>
        <name>DMAREQ0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>SCT DMA request 1 register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit n is one, event n sets DMA request 1 (event 0 = bit
            								0, event 1 = bit 1, etc. The number of bits = number of events in
            								this SCT.</description>
            <name>DEV_1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit makes the SCT set DMA request 1 when it
            								loads the Match L/Unified registers from the Reload L/Unified
            								registers.</description>
            <name>DRL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This read-only bit indicates the state of DMA Request
            								1.</description>
            <name>DRQ1</name>
          </field>
        </fields>
        <name>DMAREQ1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>SCT event enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>The SCT requests interrupt when bit n of this register and
            								the event flag register are both one (event 0 = bit 0, event 1 = bit
            								1, etc.</description>
            <name>IEN</name>
          </field>
        </fields>
        <name>EVEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>SCT event flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Bit n is one if event n has occurred since reset or a 1 was
            								last written to this bit (event 0 = bit 0, event 1 = bit 1,etc. The
            								number of bits = number of events in this SCT.</description>
            <name>FLAG</name>
          </field>
        </fields>
        <name>EVFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>SCT conflict enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>The SCT requests an interrupt when bit n of this register
            								and the SCT conflict flag register are both one (output 0 = bit 0,
            								output 1 = bit 1, etc.</description>
            <name>NCEN</name>
          </field>
        </fields>
        <name>CONEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>SCT conflict flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Bit n is one if a no-change conflict event occurred on
            								output n since reset or a 1 was last written to this bit (output 0 =
            								bit 0, output 1 = bit 1, etc.</description>
            <name>NCFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing
            								CTR L/Unified, STATE L/Unified, MATCH L/Unified, or the Output
            								register when the L/U counter was not halted. A word write to
            								certain L and H registers can be half successful and half
            								unsuccessful.</description>
            <name>BUSERRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing
            								CTR H, STATE H, MATCH H, or the Output register when the H counter
            								was not halted.</description>
            <name>BUSERRH</name>
          </field>
        </fields>
        <name>CONFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x114</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x118</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11C</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x120</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x124</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x128</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x12C</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x130</addressOffset>
        <description>SCT match value register of match channels 0 to 12; REGMOD0 to
        						REGMODE12 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the L counter. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be
            								compared to the H counter. When UNIFY = 1, read or write the upper
            								16 bits of the 32-bit value to be compared to the unified
            								counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x114</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x118</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x11C</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x120</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x124</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x128</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x12C</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x130</addressOffset>
        <description>SCT capture register of capture channel 0 to 12; REGMOD0 to
        						REGMODE12 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the lower 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this
            								register was last captured. When UNIFY = 1, read the upper 16 bits
            								of the 32-bit value at which this register was last
            								captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x220</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x224</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x228</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x22C</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x230</addressOffset>
        <description>SCT match reload value register 0 to 12; REGMOD0 = 0 to REGMODE12 =
        						0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded
            								into the MATCHn_L register. When UNIFY = 1, read or write the lower
            								16 bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into
            								the MATCHn_H register. When UNIFY = 1, read or write the upper 16
            								bits of the 32-bit value to be loaded into the MATCHn
            								register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x220</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x224</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x228</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x22C</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x230</addressOffset>
        <description>SCT capture control register 0 to 12; REGMOD0 = 1 to REGMODE12 =
        						1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or
            								the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1
            								= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>CAPCONn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0)
            								register to be loaded (event 0 = bit 16, event 1 = bit 17, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CAPCONn_H</name>
          </field>
        </fields>
        <name>CAPCTRL12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV0_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV1_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV2_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x318</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV3_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV4_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x328</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV5_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x330</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV6_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x338</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV7_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x340</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV8_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x348</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV9_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x350</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV10_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x358</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV11_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x360</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>If bit m is one, event n happens in state m of the counter
            								selected by the HEVENT bit (m = state number; state 0 = bit 0, state
            								1= bit 1, etc. The number of bits = number of events in this
            								SCT.</description>
            <name>STATEMSKn</name>
          </field>
        </fields>
        <name>EV12_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV0_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV1_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV2_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV3_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x324</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV4_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x32C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV5_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x334</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV6_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x33C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV7_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x344</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV8_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV9_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x354</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV10_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x35C</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV11_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x364</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if
            								any). A match can occur only when the counter selected by the HEVENT
            								bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY =
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>L counter. Selects the L state and the L match
                										register selected by MATCHSEL.</description>
                <name>L_COUNTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>H counter. Selects the H state and the H match
                										register selected by MATCHSEL.</description>
                <name>H_COUNTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input. Selects the input selected by
                										IOSEL.</description>
                <name>INPUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Output. Selects the output selected by
                										IOSEL.</description>
                <name>OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this
            								event (if any). Do not select an input in this register, if CLKMODE
            								is 1x. In this case the clock input is an implicit ingredient of
            								every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of
            								edges on outputs lags the conditions that switch the outputs by one
            								SCT clock). In order to guarantee proper edge/state detection, an
            								input must have a minimum pulse width of at least one SCT clock
            								period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used
            								and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified
                										match or I/O condition occurs.</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition
                										only.</description>
                <name>IO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and
                										I/O condition occur simultaneously.</description>
                <name>AND</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state
            								selected by HEVENT when this event is the highest-numbered event
            								occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Add. STATEV value is added into STATE (the
                										carry-out is ignored).</description>
                <name>ADD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Load. STATEV value is loaded into
                										STATE.</description>
                <name>LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by
            								HEVENT, depending on STATELD, when this event is the
            								highest-numbered event occurring for that state. If STATELD and
            								STATEV are both zero, there is no change to the STATE
            								value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match
            								component to the triggering of this event, then a match is
            								considered to be active whenever the counter value is GREATER THAN
            								OR EQUAL TO the value specified in the match register when counting
            								up, LESS THEN OR EQUAL TO the match value when counting down. If
            								this bit is zero, a match is only be active during the cycle when
            								the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only
            								applies when the counters are operating in BIDIR mode. If BIDIR = 0,
            								the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered
                										regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during
                										up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during
                										down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV12_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT0_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x508</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT1_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x510</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT2_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x518</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT3_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x520</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT4_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x528</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT5_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x530</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT6_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x538</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT7_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x504</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT0_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT1_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x514</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT2_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x51C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT3_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x524</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT4_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x52C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT5_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x534</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT6_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x53C</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it
            								if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1, etc. The
            								number of bits = number of events in this SCT.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT7_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x1C02C000</baseAddress>
    <description>Mailbox</description>
    <groupName>MAILBOX</groupName>
    <interrupts>
      <interrupt>
        <name>MAILBOX</name>
        <value>0x1F</value>
      </interrupt>
    </interrupts>
    <name>MAILBOX</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt request register for the Cortex-M0+ CPU.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>If any bit is set, an interrupt request is sent to the
            								Cortex-M0+ interrupt controller.</description>
            <name>INTREQ</name>
          </field>
        </fields>
        <name>IRQ0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Set bits in IRQ0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 sets the corresponding bit in the IRQ0
            								register.</description>
            <name>INTREQSET</name>
          </field>
        </fields>
        <name>IRQ0SET</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Clear bits in IRQ0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 clears the corresponding bit in the IRQ0
            								register.</description>
            <name>INTREQCLR</name>
          </field>
        </fields>
        <name>IRQ0CLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt request register for the Cortex M4 CPU.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>If any bit is set, an interrupt request is sent to the
            								Cortex-M0+ interrupt controller.</description>
            <name>INTREQ</name>
          </field>
        </fields>
        <name>IRQ1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Set bits in IRQ1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 sets the corresponding bit in the IRQ1
            								register.</description>
            <name>INTREQSET</name>
          </field>
        </fields>
        <name>IRQ1SET</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Clear bits in IRQ1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 clears the corresponding bit in the IRQ1
            								register.</description>
            <name>INTREQCLR</name>
          </field>
        </fields>
        <name>IRQ1CLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>Mutual exclusion register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cleared when read, set when written. See usage description
            								above.</description>
            <name>EX</name>
          </field>
        </fields>
        <name>MUTEX</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x1C034000</baseAddress>
    <description>12-bit ADC controller 0</description>
    <groupName>ADC0</groupName>
    <interrupts>
      <interrupt>
        <name>ADC_SEQA</name>
        <value>0x1A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ADC_SEQB</name>
        <value>0x1B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ADC_THCMP</name>
        <value>0x1C</value>
      </interrupt>
    </interrupts>
    <name>ADC0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>ADC Control Register. Contains the clock divide value, enable bits
        						for each sequence and the ADC power-down bit.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>In synchronous mode only, the system clock is divided by
            								this value plus one to produce the clock for the ADC converter,
            								which should be less than or equal to 80 MHz. Typically, software
            								should program the smallest value in this field that yields this
            								maximum clock rate or slightly less, but in certain cases (such as a
            								high-impedance analog source) a slower clock may be desirable. This
            								field is ignored in the asynchronous operating mode.</description>
            <name>CLKDIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select clock mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode. The ADC clock is derived from the
                										system clock based on the divide value selected in the
                										CLKDIV field. The ADC clock will be started in a controlled
                										fashion in response to a trigger to eliminate any
                										uncertainty in the launching of an ADC conversion in
                										response to any synchronous (on-chip) trigger. In
                										Synchronous mode with the SYNCBYPASS bit (in a sequence
                										control register) set, sampling of the ADC input and start
                										of conversion will initiate 2 system clocks after the
                										leading edge of a (synchronous) trigger pulse.</description>
                <name>SYNCHRONOUS_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode. The ADC clock is based on the
                										output of the ADC clock divider ADCCLKSEL in the SYSCON
                										block.</description>
                <name>ASYNCHRONOUS_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ASYNMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>The number of bits of ADC resolution. Accuracy can be
            								reduced to achieve higher conversion rates. A single conversion
            								requires the selected number of bits of resolution plus 3 ADC
            								clocks. This field must only be altered when the ADC is fully idle.
            								Changing it during any kind of ADC operation may have unpredictable
            								results. ADC clock frequencies for various resolutions must not
            								exceed: - 5x the system clock rate for 12-bit resolution - 4.3x the
            								system clock rate for 10-bit resolution - 3.6x the system clock for
            								8-bit resolution - 3x the bus clock rate for 6-bit
            								resolution</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>6-bit resolution. An ADC conversion requires 9 ADC
                										clocks, plus any clocks specified by the TSAMP
                										field.</description>
                <name>6_BIT_RESOLUTION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit resolution. An ADC conversion requires 11 ADC
                										clocks, plus any clocks specified by the TSAMP
                										field.</description>
                <name>8_BIT_RESOLUTION</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>10-bit resolution. An ADC conversion requires 13
                										ADC clocks, plus any clocks specified by the TSAMP
                										field.</description>
                <name>10_BIT_RESOLUTION</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>12-bit resolution. An ADC conversion requires 15
                										ADC clocks, plus any clocks specified by the TSAMP
                										field.</description>
                <name>12_BIT_RESOLUTION</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RESOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bypass Calibration. This bit may be set to avoid the need
            								to calibrate if offset error is not a concern in the
            								application.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Calibrate. The stored calibration value will be
                										applied to the ADC during conversions to compensated for
                										offset error. A calibration cycle must be performed each
                										time the chip is powered-up. Re-calibration may be warranted
                										periodically - especially if operating conditions have
                										changed.</description>
                <name>CALIBRATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass calibration. Calibration is not utilized.
                										Less time is required when enabling the ADC - particularly
                										following chip power-up. Attempts to launch a calibration
                										cycle are blocked when this bit is set.</description>
                <name>BYPASS_CALIBRATION</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASSCAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Sample Time. The default sampling period (TSAMP = 000) at
            								the start of each conversion is 2.5 ADC clock periods. Depending on
            								a variety of factors, including operating conditions and the output
            								impedance of the analog source, longer sampling times may be
            								required. The TSAMP field specifies the number of additional ADC
            								clock cycles, from zero to seven, by which the sample period will be
            								extended. The total conversion time will increase by the same number
            								of clocks. 000 - The sample period will be the default 2.5 ADC
            								clocks. A complete conversion with 12-bits of accuracy will require
            								15 clocks. 001- The sample period will be extended by one ADC clock
            								to a total of 3.5 clock periods. A complete 12-bit conversion will
            								require 16 clocks. 010 - The sample period will be extended by two
            								clocks to 4.5 ADC clock cycles. A complete 12-bit conversion will
            								require 17 ADC clocks. : 111 - The sample period will be extended by
            								two clocks to 9.5 ADC clock cycles. A complete 12-bit conversion
            								will require 22 ADC clocks.</description>
            <name>TSAMP</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x600</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>ADC Conversion Sequence-A control Register: Controls triggering and
        						channel selection for conversion sequence-A. Also specifies interrupt mode
        						for sequence-A.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Selects which one or more of the ADC channels will be
            								sampled and converted when this sequence is launched. A 1 in any bit
            								of this field will cause the corresponding channel to be included in
            								the conversion sequence, where bit 0 corresponds to channel 0, bit 1
            								to channel 1 and so forth. When this conversion sequence is
            								triggered, either by a hardware trigger or via software command, ADC
            								conversions will be performed on each enabled channel, in sequence,
            								beginning with the lowest-ordered channel. This field can ONLY be
            								changed while the SEQA_ENA bit (bit 31) is LOW. It is allowed to
            								change this field and set bit 31 in the same write.</description>
            <name>CHANNELS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Selects which of the available hardware trigger sources
            								will cause this conversion sequence to be initiated. Program the
            								trigger input number in this field. See Table 351. In order to avoid
            								generating a spurious trigger, it is recommended writing to this
            								field only when the SEQA_ENA bit (bit 31) is low. It is safe to
            								change this field and set bit 31 in the same write.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select the polarity of the selected input trigger for this
            								conversion sequence. In order to avoid generating a spurious
            								trigger, it is recommended writing to this field only when the
            								SEQA_ENA bit (bit 31) is low. It is safe to change this field and
            								set bit 31 in the same write.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Negative edge. A negative edge launches the
                										conversion sequence on the selected trigger
                										input.</description>
                <name>NEGATIVE_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Positive edge. A positive edge launches the
                										conversion sequence on the selected trigger
                										input.</description>
                <name>POSITIVE_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit allows the hardware trigger input to
            								bypass synchronization flip-flop stages and therefore shorten the
            								time between the trigger input signal and the start of a conversion.
            								There are slightly different criteria for whether or not this bit
            								can be set depending on the clock operating mode: Synchronous mode
            								(the ASYNMODE in the CTRL register = 0): Synchronization may be
            								bypassed (this bit may be set) if the selected trigger source is
            								already synchronous with the main system clock (eg. coming from an
            								on-chip, system-clock-based timer). Whether this bit is set or not,
            								a trigger pulse must be maintained for at least one system clock
            								period. Asynchronous mode (the ASYNMODE in the CTRL register = 1):
            								Synchronization may be bypassed (this bit may be set) if it is
            								certain that the duration of a trigger input pulse will be at least
            								one cycle of the ADC clock (regardless of whether the trigger comes
            								from and on-chip or off-chip source). If this bit is NOT set, the
            								trigger pulse must at least be maintained for one system clock
            								period.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable trigger synchronization. The hardware
                										trigger bypass is not enabled.</description>
                <name>ENABLE_TRIGGER_SYNCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass trigger synchronization. The hardware
                										trigger bypass is enabled.</description>
                <name>BYPASS_TRIGGER_SYNCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCBYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this field will launch one pass through this
            								conversion sequence. The behavior will be identical to a sequence
            								triggered by a hardware trigger. Do not write 1 to this bit if the
            								BURST bit is set. This bit is only set to a 1 momentarily when
            								written to launch a conversion sequence. It will consequently always
            								read back as a zero.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit will cause this conversion sequence
            								to be continuously cycled through. Other sequence A triggers will be
            								ignored while this bit is set. Repeated conversions can be halted by
            								clearing this bit. The sequence currently in progress will be
            								completed before conversions are terminated. Note that a new
            								sequence could begin just before BURST is cleared.</description>
            <name>BURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is set, a hardware trigger or a write to the
            								START bit will launch a single conversion on the next channel in the
            								sequence instead of the default response of launching an entire
            								sequence of conversions. Once all of the channels comprising a
            								sequence have been converted, a subsequent trigger will repeat the
            								sequence beginning with the first enabled channel. Interrupt
            								generation will still occur either after each individual conversion
            								or at the end of the entire sequence, depending on the state of the
            								MODE bit.</description>
            <name>SINGLESTEP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set priority for sequence A.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low priority. Any B trigger which occurs while an A
                										conversion sequence is active will be ignored and
                										lost.</description>
                <name>LOW_PRIORITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High priority. Setting this bit to a 1 will permit
                										any enabled B sequence trigger (including a B sequence
                										software start) to immediately interrupt sequence A and
                										launch a B sequence in its place. The conversion currently
                										in progress will be terminated. The A sequence that was
                										interrupted will automatically resume after the B sequence
                										completes. The channel whose conversion was terminated will
                										be re-sampled and the conversion sequence will resume from
                										that point.</description>
                <name>HIGH_PRIORITY</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOWPRIO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the primary method for retrieving
            								conversion results for this sequence will be accomplished via
            								reading the global data register (SEQA_GDAT) at the end of each
            								conversion, or the individual channel result registers at the end of
            								the entire sequence. Impacts when conversion-complete interrupt/DMA
            								trigger for sequence-A will be generated and which overrun
            								conditions contribute to an overrun interrupt as described
            								below.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of conversion. The sequence A interrupt/DMA
                										trigger will be set at the end of each individual ADC
                										conversion performed under sequence A. This flag will mirror
                										the DATAVALID bit in the SEQA_GDAT register. The OVERRUN bit
                										in the SEQA_GDAT register will contribute to generation of
                										an overrun interrupt/DMA trigger if enabled.</description>
                <name>END_OF_CONVERSION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of sequence. The sequence A interrupt/DMA
                										trigger will be set when the entire set of sequence-A
                										conversions completes. This flag will need to be explicitly
                										cleared by software or by the DMA-clear signal in this mode.
                										The OVERRUN bit in the SEQA_GDAT register will NOT
                										contribute to generation of an overrun interrupt/DMA trigger
                										since it is assumed this register may not be utilized in
                										this mode.</description>
                <name>END_OF_SEQUENCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence Enable. In order to avoid spuriously triggering
            								the sequence, care should be taken to only set the SEQA_ENA bit when
            								the selected trigger input is in its INACTIVE state (as defined by
            								the TRIGPOL bit). If this condition is not met, the sequence will be
            								triggered immediately upon being enabled. In order to avoid
            								spuriously triggering the sequence, care should be taken to only set
            								the SEQA_ENA bit when the selected trigger input is in its INACTIVE
            								state (as defined by the TRIGPOL bit). If this condition is not met,
            								the sequence will be triggered immediately upon being
            								enabled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Sequence A is disabled. Sequence A
                										triggers are ignored. If this bit is cleared while sequence
                										A is in progress, the sequence will be halted at the end of
                										the current conversion. After the sequence is re-enabled, a
                										new trigger will be required to restart the sequence
                										beginning with the next enabled channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Sequence A is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQA_ENA</name>
          </field>
        </fields>
        <name>SEQA_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>ADC Conversion Sequence-B Control Register: Controls triggering and
        						channel selection for conversion sequence-B. Also specifies interrupt mode
        						for sequence-B.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Selects which one or more of the ADC channels will be
            								sampled and converted when this sequence is launched. A 1 in any bit
            								of this field will cause the corresponding channel to be included in
            								the conversion sequence, where bit 0 corresponds to channel 0, bit 1
            								to channel 1 and so forth. When this conversion sequence is
            								triggered, either by a hardware trigger or via software command, ADC
            								conversions will be performed on each enabled channel, in sequence,
            								beginning with the lowest-ordered channel. This field can ONLY be
            								changed while the SEQB_ENA bit (bit 31) is LOW. It is allowed to
            								change this field and set bit 31 in the same write.</description>
            <name>CHANNELS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Selects which of the available hardware trigger sources
            								will cause this conversion sequence to be initiated. Program the
            								trigger input number in this field. See Table 351. In order to avoid
            								generating a spurious trigger, it is recommended writing to this
            								field only when the SEQB_ENA bit (bit 31) is low. It is safe to
            								change this field and set bit 31 in the same write.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select the polarity of the selected input trigger for this
            								conversion sequence. In order to avoid generating a spurious
            								trigger, it is recommended writing to this field only when the
            								SEQB_ENA bit (bit 31) is low. It is safe to change this field and
            								set bit 31 in the same write.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Negative edge. A negative edge launches the
                										conversion sequence on the selected trigger
                										input.</description>
                <name>NEGATIVE_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Positive edge. A positive edge launches the
                										conversion sequence on the selected trigger
                										input.</description>
                <name>POSITIVE_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIGPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit allows the hardware trigger input to
            								bypass synchronization flip-flop stages and therefore shorten the
            								time between the trigger input signal and the start of a conversion.
            								There are slightly different criteria for whether or not this bit
            								can be set depending on the clock operating mode: Synchronous mode
            								(the ASYNMODE in the CTRL register = 0): Synchronization may be
            								bypassed (this bit may be set) if the selected trigger source is
            								already synchronous with the main system clock (eg. coming from an
            								on-chip, system-clock-based timer). Whether this bit is set or not,
            								a trigger pulse must be maintained for at least one system clock
            								period. Asynchronous mode (the ASYNMODE in the CTRL register = 1):
            								Synchronization may be bypassed (this bit may be set) if it is
            								certain that the duration of a trigger input pulse will be at least
            								one cycle of the ADC clock (regardless of whether the trigger comes
            								from and on-chip or off-chip source). If this bit is NOT set, the
            								trigger pulse must at least be maintained for one system clock
            								period.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable synchronization. The hardware trigger bypass
                										is not enabled.</description>
                <name>ENABLE_SYNCHRONIZATI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass synchronization. The hardware trigger bypass
                										is enabled.</description>
                <name>BYPASS_SYNCHRONIZATI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCBYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this field will launch one pass through this
            								conversion sequence. The behavior will be identical to a sequence
            								triggered by a hardware trigger. Do not write 1 to this bit if the
            								BURST bit is set. This bit is only set to a 1 momentarily when
            								written to launch a conversion sequence. It will consequently always
            								read back as a zero.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit will cause this conversion sequence
            								to be continuously cycled through. Other sequence B triggers will be
            								ignored while this bit is set. Repeated conversions can be halted by
            								clearing this bit. The sequence currently in progress will be
            								completed before conversions are terminated.</description>
            <name>BURST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is set, a hardware trigger or a write to the
            								START bit will launch a single conversion on the next channel in the
            								sequence instead of the default response of launching an entire
            								sequence of conversions. Once all of the channels comprising a
            								sequence have been converted, a subsequent trigger will repeat the
            								sequence beginning with the first enabled channel. Interrupt
            								generation will still occur either after each individual conversion
            								or at the end of the entire sequence, depending on the state of the
            								MODE bit.</description>
            <name>SINGLESTEP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the primary method for retrieving
            								conversion results for this sequence will be accomplished via
            								reading the global data register (SEQB_GDAT) at the end of each
            								conversion, or the individual channel result registers at the end of
            								the entire sequence. Impacts when conversion-complete interrupt/DMA
            								trigger for sequence-B will be generated and which overrun
            								conditions contribute to an overrun interrupt as described
            								below.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of conversion. The sequence B interrupt/DMA
                										trigger will be set at the end of each individual ADC
                										conversion performed under sequence B. This flag will mirror
                										the DATAVALID bit in the SEQB_GDAT register. The OVERRUN bit
                										in the SEQB_GDAT register will contribute to generation of
                										an overrun interrupt/DMA trigger if enabled.</description>
                <name>END_OF_CONVERSION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>End of sequence. The sequence B interrupt/DMA
                										trigger will be set when the entire set of sequence-B
                										conversions completes. This flag will need to be explicitly
                										cleared by software or by the DMA-clear signal in this mode.
                										The OVERRUN bit in the SEQB_GDAT register will NOT
                										contribute to generation of an overrun interrupt/DMA trigger
                										since it is assumed this register may not be utilized in
                										this mode.</description>
                <name>END_OF_SEQUENCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence Enable. In order to avoid spuriously triggering
            								the sequence, care should be taken to only set the SEQB_ENA bit when
            								the selected trigger input is in its INACTIVE state (as defined by
            								the TRIGPOL bit). If this condition is not met, the sequence will be
            								triggered immediately upon being enabled. In order to avoid
            								spuriously triggering the sequence, care should be taken to only set
            								the SEQB_ENA bit when the selected trigger input is in its INACTIVE
            								state (as defined by the TRIGPOL bit). If this condition is not met,
            								the sequence will be triggered immediately upon being
            								enabled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Sequence B is disabled. Sequence B
                										triggers are ignored. If this bit is cleared while sequence
                										B is in progress, the sequence will be halted at the end of
                										the current conversion. After the sequence is re-enabled, a
                										new trigger will be required to restart the sequence
                										beginning with the next enabled channel.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Sequence B is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQB_ENA</name>
          </field>
        </fields>
        <name>SEQB_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>ADC Sequence-A Global Data Register. This register contains the
        						result of the most recent ADC conversion performed under
        						sequence-A</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the most recent conversion performed under conversion sequence
            								associated with this register. The result is a binary fraction
            								representing the voltage on the currently-selected input channel as
            								it falls within the range of VREFP to VREFN. Zero in the field
            								indicates that the voltage on the input pin was less than, equal to,
            								or close to that on VREFN, while 0xFFF indicates that the voltage on
            								the input was close to, equal to, or greater than that on VREFP.
            								DATAVALID = 1 indicates that this result has not yet been
            								read.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion
            								performed was above, below or within the range established by the
            								designated threshold comparison registers (THRn_LOW and
            								THRn_HIGH).</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion
            								performed represented a crossing of the threshold level established
            								by the designated LOW threshold comparison register (THRn_LOW) and,
            								if so, in what direction the crossing occurred.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits contain the channel from which the RESULT bits
            								were converted (e.g. 0000 identifies channel 0, 0001 channel 1,
            								etc.).</description>
            <name>CHN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set if a new conversion result is loaded into
            								the RESULT field before a previous result has been read - i.e. while
            								the DATAVALID bit is set. This bit is cleared, along with the
            								DATAVALID bit, whenever this register is read. This bit will
            								contribute to an overrun interrupt/DMA trigger if the MODE bit (in
            								SEQAA_CTRL) for the corresponding sequence is set to 0 (and if the
            								overrun interrupt is enabled).</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 at the end of each conversion when a
            								new result is loaded into the RESULT field. It is cleared whenever
            								this register is read. This bit will cause a conversion-complete
            								interrupt for the corresponding sequence if the MODE bit (in
            								SEQA_CTRL) for that sequence is set to 0 (and if the interrupt is
            								enabled).</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>SEQA_GDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>ADC Sequence-B Global Data Register. This register contains the
        						result of the most recent ADC conversion performed under
        						sequence-B</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the most recent conversion performed under conversion sequence
            								associated with this register. The result is a binary fraction
            								representing the voltage on the currently-selected input channel as
            								it falls within the range of VREFP to VREFN. Zero in the field
            								indicates that the voltage on the input pin was less than, equal to,
            								or close to that on VREFN, while 0xFFF indicates that the voltage on
            								the input was close to, equal to, or greater than that on VREFP.
            								DATAVALID = 1 indicates that this result has not yet been
            								read.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion
            								performed was above, below or within the range established by the
            								designated threshold comparison registers (THRn_LOW and
            								THRn_HIGH).</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Indicates whether the result of the last conversion
            								performed represented a crossing of the threshold level established
            								by the designated LOW threshold comparison register (THRn_LOW) and,
            								if so, in what direction the crossing occurred.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits contain the channel from which the RESULT bits
            								were converted (e.g. 0000 identifies channel 0, 0001 channel 1,
            								etc.).</description>
            <name>CHN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set if a new conversion result is loaded into
            								the RESULT field before a previous result has been read - i.e. while
            								the DATAVALID bit is set. This bit is cleared, along with the
            								DATAVALID bit, whenever this register is read. This bit will
            								contribute to an overrun interrupt/DMA trigger if the MODE bit (in
            								SEQB_CTRL) for the corresponding sequence is set to 0 (and if the
            								overrun interrupt is enabled).</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 at the end of each conversion when a
            								new result is loaded into the RESULT field. It is cleared whenever
            								this register is read. This bit will cause a conversion-complete
            								interrupt for the corresponding sequence if the MODE bit (in
            								SEQB_CTRL) for that sequence is set to 0 (and if the interrupt is
            								enabled).</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>SEQB_GDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>ADC Low Compare Threshold Register 0: Contains the lower threshold
        						level for automatic threshold comparison for any channels linked to
        						threshold pair 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Low threshold value against which ADC results will be
            								compared</description>
            <name>THRLOW</name>
          </field>
        </fields>
        <name>THR0_LOW</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>ADC Low Compare Threshold Register 1: Contains the lower threshold
        						level for automatic threshold comparison for any channels linked to
        						threshold pair 1.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Low threshold value against which ADC results will be
            								compared</description>
            <name>THRLOW</name>
          </field>
        </fields>
        <name>THR1_LOW</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>ADC High Compare Threshold Register 0: Contains the upper threshold
        						level for automatic threshold comparison for any channels linked to
        						threshold pair 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>High threshold value against which ADC results will be
            								compared</description>
            <name>THRHIGH</name>
          </field>
        </fields>
        <name>THR0_HIGH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>ADC High Compare Threshold Register 1: Contains the upper threshold
        						level for automatic threshold comparison for any channels linked to
        						threshold pair 1.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>High threshold value against which ADC results will be
            								compared</description>
            <name>THRHIGH</name>
          </field>
        </fields>
        <name>THR1_HIGH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>ADC Channel-Threshold Select Register. Specifies which set of
        						threshold compare registers are to be used for each channel</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 0. Results for this channel will be
                										compared against the threshold levels indicated in the
                										THR0_LOW and THR0_HIGH registers.</description>
                <name>THRESHOLD0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold 1. Results for this channel will be
                										compared against the threshold levels indicated in the
                										THR1_LOW and THR1_HIGH registers.</description>
                <name>THRESHOLD1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH0_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 1. See description for channel
            								0.</description>
            <name>CH1_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 2. See description for channel
            								0.</description>
            <name>CH2_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 3. See description for channel
            								0.</description>
            <name>CH3_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 4. See description for channel
            								0.</description>
            <name>CH4_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 5. See description for channel
            								0.</description>
            <name>CH5_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 6. See description for channel
            								0.</description>
            <name>CH6_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 7. See description for channel
            								0.</description>
            <name>CH7_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 8. See description for channel
            								0.</description>
            <name>CH8_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 9. See description for channel
            								0.</description>
            <name>CH9_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 10. See description for
            								channel 0.</description>
            <name>CH10_THRSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold select for channel 11. See description for
            								channel 0.</description>
            <name>CH11_THRSEL</name>
          </field>
        </fields>
        <name>CHAN_THRSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x64</addressOffset>
        <description>ADC Interrupt Enable Register. This register contains enable bits
        						that enable the sequence-A, sequence-B, threshold compare and data overrun
        						interrupts to be generated.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence A interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The sequence A interrupt/DMA trigger is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The sequence A interrupt/DMA trigger is
                										enabled and will be asserted either upon completion of each
                										individual conversion performed as part of sequence A, or
                										upon completion of the entire A sequence of conversions,
                										depending on the MODE bit in the SEQA_CTRL
                										register.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQA_INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence B interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The sequence B interrupt/DMA trigger is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The sequence B interrupt/DMA trigger is
                										enabled and will be asserted either upon completion of each
                										individual conversion performed as part of sequence B, or
                										upon completion of the entire B sequence of conversions,
                										depending on the MODE bit in the SEQB_CTRL
                										register.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEQB_INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun interrupt enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The overrun interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The overrun interrupt is enabled.
                										Detection of an overrun condition on any of the 12 channel
                										data registers will cause an overrun interrupt/DMA trigger.
                										In addition, if the MODE bit for a particular sequence is 0,
                										then an overrun in the global data register for that
                										sequence will also cause this interrupt/DMA trigger to be
                										asserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OVR_INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold comparison interrupt enable for channel
            								0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Outside threshold.</description>
                <name>OUTSIDE_THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crossing threshold.</description>
                <name>CROSSING_THRESHOLD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADCMPINTEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 1 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 2 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 3 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 4 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 5 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 6 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 7 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 8 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 9 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 10 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Channel 21 threshold comparison interrupt enable. See
            								description for channel 0.</description>
            <name>ADCMPINTEN11</name>
          </field>
        </fields>
        <name>INTEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>ADC Flags Register. Contains the four interrupt/DMA trigger flags
        						and the individual component overrun and threshold-compare flags. (The
        						overrun bits replicate information stored in the result
        						registers).</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 0. Set to 1 upon
            								either an out-of-range result or a threshold-crossing result if
            								enabled to do so in the INTEN register. This bit is cleared by
            								writing a 1.</description>
            <name>THCMP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 1. See description
            								for channel 0.</description>
            <name>THCMP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 2. See description
            								for channel 0.</description>
            <name>THCMP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 3. See description
            								for channel 0.</description>
            <name>THCMP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 4. See description
            								for channel 0.</description>
            <name>THCMP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 5. See description
            								for channel 0.</description>
            <name>THCMP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 6. See description
            								for channel 0.</description>
            <name>THCMP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 7. See description
            								for channel 0.</description>
            <name>THCMP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 8. See description
            								for channel 0.</description>
            <name>THCMP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 9. See description
            								for channel 0.</description>
            <name>THCMP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 10. See description
            								for channel 0.</description>
            <name>THCMP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold comparison event on Channel 11. See description
            								for channel 0.</description>
            <name>THCMP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 0</description>
            <name>OVERRUN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 1</description>
            <name>OVERRUN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 2</description>
            <name>OVERRUN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 3</description>
            <name>OVERRUN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 4</description>
            <name>OVERRUN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 5</description>
            <name>OVERRUN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 6</description>
            <name>OVERRUN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 7</description>
            <name>OVERRUN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 8</description>
            <name>OVERRUN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 9</description>
            <name>OVERRUN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 10</description>
            <name>OVERRUN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the OVERRRUN status flag from the result register
            								for ADC channel 11</description>
            <name>OVERRUN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the global OVERRUN status flag in the SEQA_GDAT
            								register</description>
            <name>SEQA_OVR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirrors the global OVERRUN status flag in the SEQB_GDAT
            								register</description>
            <name>SEQB_OVR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence A interrupt/DMA trigger. If the MODE bit in the
            								SEQA_CTRL register is 0, this flag will mirror the DATAVALID bit in
            								the sequence A global data register (SEQA_GDAT), which is set at the
            								end of every ADC conversion performed as part of sequence A. It will
            								be cleared automatically when the SEQA_GDAT register is read. If the
            								MODE bit in the SEQA_CTRL register is 1, this flag will be set upon
            								completion of an entire A sequence. In this case it must be cleared
            								by writing a 1 to this SEQA_INT bit. This interrupt must be enabled
            								in the INTEN register.</description>
            <name>SEQA_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sequence A interrupt/DMA trigger. If the MODE bit in the
            								SEQB_CTRL register is 0, this flag will mirror the DATAVALID bit in
            								the sequence A global data register (SEQB_GDAT), which is set at the
            								end of every ADC conversion performed as part of sequence B. It will
            								be cleared automatically when the SEQB_GDAT register is read. If the
            								MODE bit in the SEQB_CTRL register is 1, this flag will be set upon
            								completion of an entire B sequence. In this case it must be cleared
            								by writing a 1 to this SEQB_INT bit. This interrupt must be enabled
            								in the INTEN register.</description>
            <name>SEQB_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Threshold Comparison Interrupt. This bit will be set if any
            								of the THCMP flags in the lower bits of this register are set to 1
            								(due to an enabled out-of-range or threshold-crossing event on any
            								channel). Each type of threshold comparison interrupt on each
            								channel must be individually enabled in the INTEN register to cause
            								this interrupt. This bit will be cleared when all of the individual
            								threshold flags are cleared via writing 1s to those
            								bits.</description>
            <name>THCMP_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Interrupt flag. Any overrun bit in any of the
            								individual channel data registers will cause this interrupt. In
            								addition, if the MODE bit in either of the SEQn_CTRL registers is 0
            								then the OVERRUN bit in the corresponding SEQn_GDAT register will
            								also cause this interrupt. This interrupt must be enabled in the
            								INTEN register. This bit will be cleared when all of the individual
            								overrun bits have been cleared via reading the corresponding data
            								registers.</description>
            <name>OVR_INT</name>
          </field>
        </fields>
        <name>FLAGS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>ADC Startup Register (typically only used by the ADC
        						API).</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC Enable bit. This bit can only be set to a 1 by
            								software. It is cleared automatically whenever the ADC is powered
            								down. This bit must not be set until at least 10 microseconds after
            								the ADC is powered up (typically by altering a system-level ADC
            								power control bit).</description>
            <name>ADC_ENA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>tbd</description>
            <name>ADC_INT</name>
          </field>
        </fields>
        <name>STARTUP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>ADC Calibration Register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Calibration request. Setting this bit will launch an ADC
            								calibration cycle. This bit can only be set to a 1 by software. It
            								is cleared automatically when the calibration cycle
            								completes.</description>
            <name>CALIB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Calibration required. This read-only bit indicates if
            								calibration is required when enabling the ADC. CALREQD will be 1 if
            								no calibration has been run since the chip was powered-up and if the
            								BYPASSCAL bit in the ADCTRL register is low. The ADC API will test
            								this bit to determine whether to initiate a calibration cycle or
            								whether to set the ADC_INIT bit (in the ADSTARTUP register) to
            								launch the ADC initialization process which includes a dummy
            								conversion cycle. Note: A dummy conversion cycle requires
            								approximately 6 ADC clocks as opposed to 81 clocks required for
            								calibration.</description>
            <name>CALREQD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Calibration Value. This read-only field displays the
            								calibration value established during last calibration cycle. This
            								value is not typically of any use to the user.</description>
            <name>CALVALUE</name>
          </field>
        </fields>
        <name>CALIB</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3C</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x40</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x44</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>ADC Channel 0 Data Register. This register contains the result of
        						the most recent conversion completed on channel 0.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>This field contains the 12-bit ADC conversion result from
            								the last conversion performed on this channel. This will be a binary
            								fraction representing the voltage on the AD0[n] pin, as it falls
            								within the range of VREFP to VREFN. Zero in the field indicates that
            								the voltage on the input pin was less than, equal to, or close to
            								that on VREFN, while 0xFFF indicates that the voltage on the input
            								was close to, equal to, or greater than that on VREFP.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Range Comparison result. 0x0 = In Range: The last
            								completed conversion was greater than or equal to the value
            								programmed into the designated LOW threshold register (THRn_LOW) but
            								less than or equal to the value programmed into the designated HIGH
            								threshold register (THRn_HIGH). 0x1 = Below Range: The last
            								completed conversion on was less than the value programmed into the
            								designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The
            								last completed conversion was greater than the value programmed into
            								the designated HIGH threshold register (THRn_HIGH). 0x3 =
            								Reserved.</description>
            <name>THCMPRANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Threshold Crossing Comparison result. 0x0 = No threshold
            								Crossing detected: The most recent completed conversion on this
            								channel had the same relationship (above or below) to the threshold
            								value established by the designated LOW threshold register
            								(THRn_LOW) as did the previous conversion on this channel. 0x1 =
            								Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that
            								a threshold crossing in the downward direction has occurred - i.e.
            								the previous sample on this channel was above the threshold value
            								established by the designated LOW threshold register (THRn_LOW) and
            								the current sample is below that threshold. 0x3 = Upward Threshold
            								Crossing Detected. Indicates that a threshold crossing in the upward
            								direction has occurred - i.e. the previous sample on this channel
            								was below the threshold value established by the designated LOW
            								threshold register (THRn_LOW) and the current sample is above that
            								threshold.</description>
            <name>THCMPCROSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field is hard-coded to contain the channel number that
            								this particular register relates to (i.e. this field will contain
            								0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
            								etc)</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit will be set to a 1 if a new conversion on this
            								channel completes and overwrites the previous contents of the RESULT
            								field before it has been read - i.e. while the DONE bit is set. This
            								bit is cleared, along with the DONE bit, whenever this register is
            								read or when the data related to this channel is read from either of
            								the global SEQn_GDAT registers. This bit (in any of the 12
            								registers) will cause an overrun interrupt/DMA trigger to be
            								asserted if the overrun interrupt is enabled. While it is allowed to
            								include the same channels in both conversion sequences, doing so may
            								cause erratic behavior of the DONE and OVERRUN bits in the data
            								registers associated with any of the channels that are shared
            								between the two sequences. Any erratic OVERRUN behavior will also
            								affect overrun interrupt generation, if enabled.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set to 1 when an ADC conversion on this channel
            								completes. This bit is cleared whenever this register is read or
            								when the data related to this channel is read from either of the
            								global SEQn_GDAT registers. While it is allowed to include the same
            								channels in both conversion sequences, doing so may cause erratic
            								behavior of the DONE and OVERRUN bits in the data registers
            								associated with any of the channels that are shared between the two
            								sequences. Any erratic OVERRUN behavior will also affect overrun
            								interrupt generation, if enabled.</description>
            <name>DATAVALID</name>
          </field>
        </fields>
        <name>DAT11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x4000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x1C038000</baseAddress>
    <description>System FIFO for Serial Peripherals </description>
    <groupName>VFIFO</groupName>
    <interrupts></interrupts>
    <name>VFIFO</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>USART FIFO global control register. These registers are byte,
        						halfword, and word addressable.The upper 16 bits of these registers provide
        						information about the System FIFO configuration, and are specific to each
        						device type.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pause all USARTs receive FIFO operations. This can be used
            								to prepare the System FIFO to reconfigure FIFO allocations among the
            								USART receivers.</description>
            <name>RXPAUSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All USART receive FIFOs are paused.</description>
            <name>RXPAUSED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All USART receive FIFOs are empty.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pause all USARTs transmit FIFO operations. This can be used
            								to prepare the System FIFO to reconfigure FIFO allocations among the
            								USART transmitters.</description>
            <name>TXPAUSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All USART transmit FIFOs are paused.</description>
            <name>TXPAUSED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All USART transmit FIFOs are empty.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Reports the receive FIFO space available for USARTs on this
            								FIFO. The reset value is device specific.</description>
            <name>RXFIFOTOTAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Reports the transmit FIFO space available for USARTs on
            								this FIFO. The reset value is device specific.</description>
            <name>TXFIFOTOTAL</name>
          </field>
        </fields>
        <name>FIFOCTLUSART</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x707</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x104</addressOffset>
        <description>USART FIFO global update register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART0 Rx FIFO size to match the USART0
            								RXSIZE. Must be done for all USARTs when any USART RXSIZE is
            								changed.</description>
            <name>USART0RXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART1 Rx FIFO size to match the USART1
            								RXSIZE. Must be done for all USARTs when any USART RXSIZE is
            								changed.</description>
            <name>USART1RXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART2 Rx FIFO size to match the USART2
            								RXSIZE. Must be done for all USARTs when any USART RXSIZE is
            								changed.</description>
            <name>USART2RXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART3 Rx FIFO size to match the USART3
            								RXSIZE. Must be done for all USARTs when any USART RXSIZE is
            								changed.</description>
            <name>USART3RXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART0 Tx FIFO size to match the USART0
            								TXSIZE. Must be done for all USARTs when any USART TXSIZE is
            								changed.</description>
            <name>USART0TXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART1 Tx FIFO size to match the USART1
            								TXSIZE. Must be done for all USARTs when any USART TXSIZE is
            								changed.</description>
            <name>USART1TXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART2 Tx FIFO size to match the USART2
            								TXSIZE. Must be done for all USARTs when any USART TXSIZE is
            								changed.</description>
            <name>USART2TXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates USART3 Tx FIFO size to match the USART3
            								TXSIZE. Must be done for all USARTs when any USART TXSIZE is
            								changed.</description>
            <name>USART3TXUPDATESIZE</name>
          </field>
        </fields>
        <name>FIFOUPDATEUSART</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SPI FIFO global control register. These registers are byte,
        						halfword, and word addressable. The upper 16 bits of these registers provide
        						information about the System FIFO configuration, and are specific to each
        						device type.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pause all SPIs receive FIFO operations. This can be used to
            								prepare the System FIFO to reconfigure FIFO allocations among the
            								SPI receivers.</description>
            <name>RXPAUSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All SPI receive FIFOs are paused.</description>
            <name>RXPAUSED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All SPI receive FIFOs are empty.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pause all SPIs transmit FIFO operations. This can be used
            								to prepare the System FIFO to reconfigure FIFO allocations among the
            								SPI transmitters.</description>
            <name>TXPAUSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All SPI transmit FIFOs are paused.</description>
            <name>TXPAUSED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>All SPI transmit FIFOs are empty.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Reports the receive FIFO space available for SPIs on the
            								System FIFO. The reset value is device specific.</description>
            <name>RXFIFOTOTAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Reports the transmit FIFO space available for SPIs on the
            								System FIFO. The reset value is device specific.</description>
            <name>TXFIFOTOTAL</name>
          </field>
        </fields>
        <name>FIFOCTLSPI</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x707</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x204</addressOffset>
        <description>SPI FIFO global update register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates SPI0 Rx FIFO size to match the SPI0
            								RXSIZE. Must be done for all SPIs when any SPI RXSIZE is
            								changed.</description>
            <name>SPI0RXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates SPI1 Rx FIFO size to match the SPI1
            								RXSIZE. Must be done for all SPIs when any SPI RXSIZE is
            								changed.</description>
            <name>SPI1RXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates SPI0 Tx FIFO size to match the SPI0
            								TXSIZE. Must be done for all SPIs when any SPI TXSIZE is
            								changed.</description>
            <name>SPI0TXUPDATESIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 updates SPI1 Tx FIFO size to match the SPI1
            								TXSIZE. Must be done for all SPIs when any SPI TXSIZE is
            								changed.</description>
            <name>SPI1TXUPDATESIZE</name>
          </field>
        </fields>
        <name>FIFOUPDATESPI</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>FIFO configuration register for USART0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART receive FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								receiver.</description>
            <name>RXSIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART transmit FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								transmitter.</description>
            <name>TXSIZE</name>
          </field>
        </fields>
        <name>FIFOCFGUSART0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x114</addressOffset>
        <description>FIFO configuration register for USART0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART receive FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								receiver.</description>
            <name>RXSIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART transmit FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								transmitter.</description>
            <name>TXSIZE</name>
          </field>
        </fields>
        <name>FIFOCFGUSART1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x118</addressOffset>
        <description>FIFO configuration register for USART0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART receive FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								receiver.</description>
            <name>RXSIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART transmit FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								transmitter.</description>
            <name>TXSIZE</name>
          </field>
        </fields>
        <name>FIFOCFGUSART2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11C</addressOffset>
        <description>FIFO configuration register for USART0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART receive FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								receiver.</description>
            <name>RXSIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the USART transmit FIFO size. A zero values
            								provides no System FIFO service for the related USART
            								transmitter.</description>
            <name>TXSIZE</name>
          </field>
        </fields>
        <name>FIFOCFGUSART3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>FIFO configuration register for SPI0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the SPI receive FIFO size. A zero values
            								provides no System FIFO service for the related SPI
            								receiver.</description>
            <name>RXSIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the SPI transmit FIFO size. A zero values
            								provides no System FIFO service for the related SPI
            								transmitter.</description>
            <name>TXSIZE</name>
          </field>
        </fields>
        <name>FIFOCFGSPI0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>FIFO configuration register for SPI0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the SPI receive FIFO size. A zero values
            								provides no System FIFO service for the related SPI
            								receiver.</description>
            <name>RXSIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Configures the SPI transmit FIFO size. A zero values
            								provides no System FIFO service for the related SPI
            								transmitter.</description>
            <name>TXSIZE</name>
          </field>
        </fields>
        <name>FIFOCFGSPI1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1000</addressOffset>
        <description>USART0 configuration</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Write. When 0, the timeout for the
            								related peripheral is reset every time data is transferred from the
            								peripheral into the receive FIFO. When 1, the timeout for the
            								related peripheral is not reset every time data is transferred into
            								the receive FIFO. This allows the timeout to be applied to
            								accumulated data, perhaps related to the FIFO
            								threshold.</description>
            <name>TIMEOUTCONTONWRITE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Empty. When 0, the timeout for the
            								related peripheral is reset when the receive FIFO becomes empty.
            								When 1, the timeout for the related peripheral is not reset when the
            								receive FIFO becomes empty. This allows the timeout to be used to
            								flag idle peripherals, and could potentially be used to indicate the
            								end of a transmission of indeterminate length.</description>
            <name>TIMEOUTCONTONEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the least significant timer bit to compare to
            								TimeoutValue. See Section 24.5.7.1 below. Value can be 0 through
            								15.</description>
            <name>TIMEOUTBASE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the maximum time value for timeout at the timer
            								position identified by TimeoutBase. Minimum time TimeoutValue - 1.
            								is See Section 24.5.7.1 below. TimeoutValue should not be 0 or 1
            								when timeout is enabled.</description>
            <name>TIMEOUTVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of entries in the receive
            								FIFO is greater than this value. For example, when RxThreshold = 0,
            								the threshold is exceeded when there is at least one entry in the
            								receive FIFO. An interrupt can be generated when the RxThreshold has
            								been reached (see Section 24.5.10), but has no effect on DMA
            								requests, which are generated whenever the receiver FIFO is not
            								empty.</description>
            <name>RXTHRESHOLD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of free entries in the
            								transmit FIFO is less than or equal to this value. For example, when
            								TxThreshold = 0, the threshold is exceeded when there is at least
            								one free entry in the transmit FIFO. An interrupt can be generated
            								when the TxThreshold has been reached (see Section 24.5.10), but has
            								no effect on DMA requests, which are generated whenever the transmit
            								FIFO has any free entries.</description>
            <name>TXTHRESHOLD</name>
          </field>
        </fields>
        <name>CFGUSART0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1100</addressOffset>
        <description>USART0 configuration</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Write. When 0, the timeout for the
            								related peripheral is reset every time data is transferred from the
            								peripheral into the receive FIFO. When 1, the timeout for the
            								related peripheral is not reset every time data is transferred into
            								the receive FIFO. This allows the timeout to be applied to
            								accumulated data, perhaps related to the FIFO
            								threshold.</description>
            <name>TIMEOUTCONTONWRITE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Empty. When 0, the timeout for the
            								related peripheral is reset when the receive FIFO becomes empty.
            								When 1, the timeout for the related peripheral is not reset when the
            								receive FIFO becomes empty. This allows the timeout to be used to
            								flag idle peripherals, and could potentially be used to indicate the
            								end of a transmission of indeterminate length.</description>
            <name>TIMEOUTCONTONEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the least significant timer bit to compare to
            								TimeoutValue. See Section 24.5.7.1 below. Value can be 0 through
            								15.</description>
            <name>TIMEOUTBASE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the maximum time value for timeout at the timer
            								position identified by TimeoutBase. Minimum time TimeoutValue - 1.
            								is See Section 24.5.7.1 below. TimeoutValue should not be 0 or 1
            								when timeout is enabled.</description>
            <name>TIMEOUTVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of entries in the receive
            								FIFO is greater than this value. For example, when RxThreshold = 0,
            								the threshold is exceeded when there is at least one entry in the
            								receive FIFO. An interrupt can be generated when the RxThreshold has
            								been reached (see Section 24.5.10), but has no effect on DMA
            								requests, which are generated whenever the receiver FIFO is not
            								empty.</description>
            <name>RXTHRESHOLD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of free entries in the
            								transmit FIFO is less than or equal to this value. For example, when
            								TxThreshold = 0, the threshold is exceeded when there is at least
            								one free entry in the transmit FIFO. An interrupt can be generated
            								when the TxThreshold has been reached (see Section 24.5.10), but has
            								no effect on DMA requests, which are generated whenever the transmit
            								FIFO has any free entries.</description>
            <name>TXTHRESHOLD</name>
          </field>
        </fields>
        <name>CFGUSART1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1200</addressOffset>
        <description>USART0 configuration</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Write. When 0, the timeout for the
            								related peripheral is reset every time data is transferred from the
            								peripheral into the receive FIFO. When 1, the timeout for the
            								related peripheral is not reset every time data is transferred into
            								the receive FIFO. This allows the timeout to be applied to
            								accumulated data, perhaps related to the FIFO
            								threshold.</description>
            <name>TIMEOUTCONTONWRITE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Empty. When 0, the timeout for the
            								related peripheral is reset when the receive FIFO becomes empty.
            								When 1, the timeout for the related peripheral is not reset when the
            								receive FIFO becomes empty. This allows the timeout to be used to
            								flag idle peripherals, and could potentially be used to indicate the
            								end of a transmission of indeterminate length.</description>
            <name>TIMEOUTCONTONEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the least significant timer bit to compare to
            								TimeoutValue. See Section 24.5.7.1 below. Value can be 0 through
            								15.</description>
            <name>TIMEOUTBASE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the maximum time value for timeout at the timer
            								position identified by TimeoutBase. Minimum time TimeoutValue - 1.
            								is See Section 24.5.7.1 below. TimeoutValue should not be 0 or 1
            								when timeout is enabled.</description>
            <name>TIMEOUTVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of entries in the receive
            								FIFO is greater than this value. For example, when RxThreshold = 0,
            								the threshold is exceeded when there is at least one entry in the
            								receive FIFO. An interrupt can be generated when the RxThreshold has
            								been reached (see Section 24.5.10), but has no effect on DMA
            								requests, which are generated whenever the receiver FIFO is not
            								empty.</description>
            <name>RXTHRESHOLD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of free entries in the
            								transmit FIFO is less than or equal to this value. For example, when
            								TxThreshold = 0, the threshold is exceeded when there is at least
            								one free entry in the transmit FIFO. An interrupt can be generated
            								when the TxThreshold has been reached (see Section 24.5.10), but has
            								no effect on DMA requests, which are generated whenever the transmit
            								FIFO has any free entries.</description>
            <name>TXTHRESHOLD</name>
          </field>
        </fields>
        <name>CFGUSART2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1300</addressOffset>
        <description>USART0 configuration</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Write. When 0, the timeout for the
            								related peripheral is reset every time data is transferred from the
            								peripheral into the receive FIFO. When 1, the timeout for the
            								related peripheral is not reset every time data is transferred into
            								the receive FIFO. This allows the timeout to be applied to
            								accumulated data, perhaps related to the FIFO
            								threshold.</description>
            <name>TIMEOUTCONTONWRITE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Empty. When 0, the timeout for the
            								related peripheral is reset when the receive FIFO becomes empty.
            								When 1, the timeout for the related peripheral is not reset when the
            								receive FIFO becomes empty. This allows the timeout to be used to
            								flag idle peripherals, and could potentially be used to indicate the
            								end of a transmission of indeterminate length.</description>
            <name>TIMEOUTCONTONEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the least significant timer bit to compare to
            								TimeoutValue. See Section 24.5.7.1 below. Value can be 0 through
            								15.</description>
            <name>TIMEOUTBASE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the maximum time value for timeout at the timer
            								position identified by TimeoutBase. Minimum time TimeoutValue - 1.
            								is See Section 24.5.7.1 below. TimeoutValue should not be 0 or 1
            								when timeout is enabled.</description>
            <name>TIMEOUTVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of entries in the receive
            								FIFO is greater than this value. For example, when RxThreshold = 0,
            								the threshold is exceeded when there is at least one entry in the
            								receive FIFO. An interrupt can be generated when the RxThreshold has
            								been reached (see Section 24.5.10), but has no effect on DMA
            								requests, which are generated whenever the receiver FIFO is not
            								empty.</description>
            <name>RXTHRESHOLD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of free entries in the
            								transmit FIFO is less than or equal to this value. For example, when
            								TxThreshold = 0, the threshold is exceeded when there is at least
            								one free entry in the transmit FIFO. An interrupt can be generated
            								when the TxThreshold has been reached (see Section 24.5.10), but has
            								no effect on DMA requests, which are generated whenever the transmit
            								FIFO has any free entries.</description>
            <name>TXTHRESHOLD</name>
          </field>
        </fields>
        <name>CFGUSART3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1004</addressOffset>
        <description>USART0 status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached. This is a read-only bit.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached. This is a read-only bit.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout. When 1, the receive FIFO has timed
            								out, based on the timeout configuration in the CFGUSART register.
            								The timeout condition can be cleared by writing a 1 to this bit, by
            								enabling or disabling the timeout interrupt, or by writing a 1 to
            								the timeout interrupt enable.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. When 1, a bus error has occurred while
            								processing data for USARTn. The bus error flag can be cleared by
            								writing a 1 to this bit.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. When 1, the receive FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. When 1, the transmit FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. Indicates how many entries may be read
            								from the receive FIFO. 0 = FIFO empty. This is a read-only
            								field.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Count. Indicates how many entries may be
            								written to the transmit FIFO. 0 = FIFO full. This is a read-only
            								field that is valid only when the TxFIFO is fully configured and
            								enabled.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>STATUSART0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1104</addressOffset>
        <description>USART0 status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached. This is a read-only bit.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached. This is a read-only bit.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout. When 1, the receive FIFO has timed
            								out, based on the timeout configuration in the CFGUSART register.
            								The timeout condition can be cleared by writing a 1 to this bit, by
            								enabling or disabling the timeout interrupt, or by writing a 1 to
            								the timeout interrupt enable.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. When 1, a bus error has occurred while
            								processing data for USARTn. The bus error flag can be cleared by
            								writing a 1 to this bit.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. When 1, the receive FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. When 1, the transmit FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. Indicates how many entries may be read
            								from the receive FIFO. 0 = FIFO empty. This is a read-only
            								field.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Count. Indicates how many entries may be
            								written to the transmit FIFO. 0 = FIFO full. This is a read-only
            								field that is valid only when the TxFIFO is fully configured and
            								enabled.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>STATUSART1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1204</addressOffset>
        <description>USART0 status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached. This is a read-only bit.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached. This is a read-only bit.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout. When 1, the receive FIFO has timed
            								out, based on the timeout configuration in the CFGUSART register.
            								The timeout condition can be cleared by writing a 1 to this bit, by
            								enabling or disabling the timeout interrupt, or by writing a 1 to
            								the timeout interrupt enable.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. When 1, a bus error has occurred while
            								processing data for USARTn. The bus error flag can be cleared by
            								writing a 1 to this bit.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. When 1, the receive FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. When 1, the transmit FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. Indicates how many entries may be read
            								from the receive FIFO. 0 = FIFO empty. This is a read-only
            								field.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Count. Indicates how many entries may be
            								written to the transmit FIFO. 0 = FIFO full. This is a read-only
            								field that is valid only when the TxFIFO is fully configured and
            								enabled.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>STATUSART2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1304</addressOffset>
        <description>USART0 status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached. This is a read-only bit.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached. This is a read-only bit.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout. When 1, the receive FIFO has timed
            								out, based on the timeout configuration in the CFGUSART register.
            								The timeout condition can be cleared by writing a 1 to this bit, by
            								enabling or disabling the timeout interrupt, or by writing a 1 to
            								the timeout interrupt enable.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. When 1, a bus error has occurred while
            								processing data for USARTn. The bus error flag can be cleared by
            								writing a 1 to this bit.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. When 1, the receive FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. When 1, the transmit FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. Indicates how many entries may be read
            								from the receive FIFO. 0 = FIFO empty. This is a read-only
            								field.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Count. Indicates how many entries may be
            								written to the transmit FIFO. 0 = FIFO full. This is a read-only
            								field that is valid only when the TxFIFO is fully configured and
            								enabled.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>STATUSART3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1008</addressOffset>
        <description>USART0 interrupt status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached, and the related interrupt is
            								enabled.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached, and the related interrupt is
            								enabled.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Timeout. When 1, the receive FIFO has timed out,
            								based on the timeout configuration in the CFGUSART register, and the
            								related interrupt is enabled.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. This is simply a copy of the same bit in the
            								STATUSART register. The bus error interrupt is always
            								enabled.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. This is simply a copy of the same field
            								in the STATUSART register, included here so an ISR can read all
            								needed status information in one read.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Available. This is simply a copy of the same
            								field in the STATUSART register, included here so an ISR can read
            								all needed status information in one read.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>INTSTATUSART0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1108</addressOffset>
        <description>USART0 interrupt status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached, and the related interrupt is
            								enabled.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached, and the related interrupt is
            								enabled.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Timeout. When 1, the receive FIFO has timed out,
            								based on the timeout configuration in the CFGUSART register, and the
            								related interrupt is enabled.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. This is simply a copy of the same bit in the
            								STATUSART register. The bus error interrupt is always
            								enabled.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. This is simply a copy of the same field
            								in the STATUSART register, included here so an ISR can read all
            								needed status information in one read.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Available. This is simply a copy of the same
            								field in the STATUSART register, included here so an ISR can read
            								all needed status information in one read.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>INTSTATUSART1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1208</addressOffset>
        <description>USART0 interrupt status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached, and the related interrupt is
            								enabled.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached, and the related interrupt is
            								enabled.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Timeout. When 1, the receive FIFO has timed out,
            								based on the timeout configuration in the CFGUSART register, and the
            								related interrupt is enabled.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. This is simply a copy of the same bit in the
            								STATUSART register. The bus error interrupt is always
            								enabled.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. This is simply a copy of the same field
            								in the STATUSART register, included here so an ISR can read all
            								needed status information in one read.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Available. This is simply a copy of the same
            								field in the STATUSART register, included here so an ISR can read
            								all needed status information in one read.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>INTSTATUSART2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1308</addressOffset>
        <description>USART0 interrupt status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached, and the related interrupt is
            								enabled.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached, and the related interrupt is
            								enabled.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Timeout. When 1, the receive FIFO has timed out,
            								based on the timeout configuration in the CFGUSART register, and the
            								related interrupt is enabled.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. This is simply a copy of the same bit in the
            								STATUSART register. The bus error interrupt is always
            								enabled.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This is simply a copy of the same bit
            								in the STATUSART register.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. This is simply a copy of the same field
            								in the STATUSART register, included here so an ISR can read all
            								needed status information in one read.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Available. This is simply a copy of the same
            								field in the STATUSART register, included here so an ISR can read
            								all needed status information in one read.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>INTSTATUSART3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100C</addressOffset>
        <description>USART0 control read and set register. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt Enable.</description>
            <name>RXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt Enable.</description>
            <name>TXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt Enable. When enabled, this
            								also enables the timeout for this USART. Writing a 1 to this bit
            								resets the USART timeout logic.</description>
            <name>RXTIMEOUTINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush. Writing a 1 to this bit forces the
            								receive FIFO to be empty.</description>
            <name>RXFLUSH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush. Writing a 1 to this bit forces the
            								transmit FIFO to be empty.</description>
            <name>TXFLUSH</name>
          </field>
        </fields>
        <name>CTLSETUSART0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110C</addressOffset>
        <description>USART0 control read and set register. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt Enable.</description>
            <name>RXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt Enable.</description>
            <name>TXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt Enable. When enabled, this
            								also enables the timeout for this USART. Writing a 1 to this bit
            								resets the USART timeout logic.</description>
            <name>RXTIMEOUTINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush. Writing a 1 to this bit forces the
            								receive FIFO to be empty.</description>
            <name>RXFLUSH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush. Writing a 1 to this bit forces the
            								transmit FIFO to be empty.</description>
            <name>TXFLUSH</name>
          </field>
        </fields>
        <name>CTLSETUSART1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x120C</addressOffset>
        <description>USART0 control read and set register. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt Enable.</description>
            <name>RXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt Enable.</description>
            <name>TXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt Enable. When enabled, this
            								also enables the timeout for this USART. Writing a 1 to this bit
            								resets the USART timeout logic.</description>
            <name>RXTIMEOUTINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush. Writing a 1 to this bit forces the
            								receive FIFO to be empty.</description>
            <name>RXFLUSH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush. Writing a 1 to this bit forces the
            								transmit FIFO to be empty.</description>
            <name>TXFLUSH</name>
          </field>
        </fields>
        <name>CTLSETUSART2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x130C</addressOffset>
        <description>USART0 control read and set register. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt Enable.</description>
            <name>RXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt Enable.</description>
            <name>TXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt Enable. When enabled, this
            								also enables the timeout for this USART. Writing a 1 to this bit
            								resets the USART timeout logic.</description>
            <name>RXTIMEOUTINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush. Writing a 1 to this bit forces the
            								receive FIFO to be empty.</description>
            <name>RXFLUSH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush. Writing a 1 to this bit forces the
            								transmit FIFO to be empty.</description>
            <name>TXFLUSH</name>
          </field>
        </fields>
        <name>CTLSETUSART3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x1010</addressOffset>
        <description>USART0 control clear register. Writing a 1 to any implemented bit
        						position causes the corresponding bit in the related CTLSET register to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt clear.</description>
            <name>RXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt clear.</description>
            <name>TXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Time-out Interrupt clear.</description>
            <name>RXTIMEOUTINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush clear.</description>
            <name>RXFLUSHCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush clear.</description>
            <name>TXFLUSHCLR</name>
          </field>
        </fields>
        <name>CTLCLRUSART0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x1110</addressOffset>
        <description>USART0 control clear register. Writing a 1 to any implemented bit
        						position causes the corresponding bit in the related CTLSET register to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt clear.</description>
            <name>RXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt clear.</description>
            <name>TXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Time-out Interrupt clear.</description>
            <name>RXTIMEOUTINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush clear.</description>
            <name>RXFLUSHCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush clear.</description>
            <name>TXFLUSHCLR</name>
          </field>
        </fields>
        <name>CTLCLRUSART1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x1210</addressOffset>
        <description>USART0 control clear register. Writing a 1 to any implemented bit
        						position causes the corresponding bit in the related CTLSET register to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt clear.</description>
            <name>RXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt clear.</description>
            <name>TXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Time-out Interrupt clear.</description>
            <name>RXTIMEOUTINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush clear.</description>
            <name>RXFLUSHCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush clear.</description>
            <name>TXFLUSHCLR</name>
          </field>
        </fields>
        <name>CTLCLRUSART2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x1310</addressOffset>
        <description>USART0 control clear register. Writing a 1 to any implemented bit
        						position causes the corresponding bit in the related CTLSET register to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt clear.</description>
            <name>RXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt clear.</description>
            <name>TXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Time-out Interrupt clear.</description>
            <name>RXTIMEOUTINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush clear.</description>
            <name>RXFLUSHCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush clear.</description>
            <name>TXFLUSHCLR</name>
          </field>
        </fields>
        <name>CTLCLRUSART3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1014</addressOffset>
        <description>USART0 received data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDATUSART0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1114</addressOffset>
        <description>USART0 received data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDATUSART1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1214</addressOffset>
        <description>USART0 received data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDATUSART2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1314</addressOffset>
        <description>USART0 received data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDATUSART3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1018</addressOffset>
        <description>USART0 received data with status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTATUSART0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1118</addressOffset>
        <description>USART0 received data with status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTATUSART1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1218</addressOffset>
        <description>USART0 received data with status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTATUSART2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1318</addressOffset>
        <description>USART0 received data with status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The UART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the UART
            								configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTATUSART3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x101C</addressOffset>
        <description>USART0 transmit data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the UART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and the condition for transmitting data is met: TXDIS bit
            								= 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDATUSART0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x111C</addressOffset>
        <description>USART0 transmit data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the UART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and the condition for transmitting data is met: TXDIS bit
            								= 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDATUSART1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x121C</addressOffset>
        <description>USART0 transmit data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the UART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and the condition for transmitting data is met: TXDIS bit
            								= 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDATUSART2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x131C</addressOffset>
        <description>USART0 transmit data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the UART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and the condition for transmitting data is met: TXDIS bit
            								= 0.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDATUSART3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2000</addressOffset>
        <description>SPI0 configuration</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Write. When 0, the timeout for the
            								related peripheral is reset every time data is transferred from the
            								peripheral into the receive FIFO. When 1, the timeout for the
            								related peripheral is not reset every time data is transferred into
            								the receive FIFO. This allows the timeout to be applied to
            								accumulated data, perhaps related to the FIFO
            								threshold.</description>
            <name>TIMEOUTCONTONWRITE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Empty. When 0, the timeout for the
            								related peripheral is reset when the receive FIFO becomes empty.
            								When 1, the timeout for the related peripheral is not reset when the
            								receive FIFO becomes empty. This allows the timeout to be used to
            								flag idle peripherals, and could potentially be used to indicate the
            								end of a transmission of indeterminate length.</description>
            <name>TIMEOUTCONTONEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the least significant timer bit to compare to
            								TimeoutValue. Value can be 0 through 15.</description>
            <name>TIMEOUTBASE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the maximum time value for timeout at the timer
            								position identified by TimeoutBase. Minimum time TimeoutValue - 1.
            								TimeoutValue should not be 0 or 1 when timeout is
            								enabled.</description>
            <name>TIMEOUTVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of entries in the receive
            								FIFO is greater than this value. For example, when RxThreshold = 0,
            								the threshold is exceeded when there is at least one entry in the
            								receive FIFO. An interrupt can be generated when the RxThreshold has
            								been reached, but has no effect on DMA requests, which are generated
            								whenever the receiver FIFO is not empty.</description>
            <name>RXTHRESHOLD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of free entries in the
            								transmit FIFO is less than or equal to this value. For example, when
            								TxThreshold = 0, the threshold is exceeded when there is at least
            								one free entry in the transmit FIFO. An interrupt can be generated
            								when the TxThreshold has been reached, but has no effect on DMA
            								requests, which are generated whenever the transmit FIFO has any
            								free entries.</description>
            <name>TXTHRESHOLD</name>
          </field>
        </fields>
        <name>CFGSPI0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2100</addressOffset>
        <description>SPI0 configuration</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Write. When 0, the timeout for the
            								related peripheral is reset every time data is transferred from the
            								peripheral into the receive FIFO. When 1, the timeout for the
            								related peripheral is not reset every time data is transferred into
            								the receive FIFO. This allows the timeout to be applied to
            								accumulated data, perhaps related to the FIFO
            								threshold.</description>
            <name>TIMEOUTCONTONWRITE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timeout Continue On Empty. When 0, the timeout for the
            								related peripheral is reset when the receive FIFO becomes empty.
            								When 1, the timeout for the related peripheral is not reset when the
            								receive FIFO becomes empty. This allows the timeout to be used to
            								flag idle peripherals, and could potentially be used to indicate the
            								end of a transmission of indeterminate length.</description>
            <name>TIMEOUTCONTONEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the least significant timer bit to compare to
            								TimeoutValue. Value can be 0 through 15.</description>
            <name>TIMEOUTBASE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the maximum time value for timeout at the timer
            								position identified by TimeoutBase. Minimum time TimeoutValue - 1.
            								TimeoutValue should not be 0 or 1 when timeout is
            								enabled.</description>
            <name>TIMEOUTVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of entries in the receive
            								FIFO is greater than this value. For example, when RxThreshold = 0,
            								the threshold is exceeded when there is at least one entry in the
            								receive FIFO. An interrupt can be generated when the RxThreshold has
            								been reached, but has no effect on DMA requests, which are generated
            								whenever the receiver FIFO is not empty.</description>
            <name>RXTHRESHOLD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Threshold. The System FIFO indicates that the
            								threshold has been reached when the number of free entries in the
            								transmit FIFO is less than or equal to this value. For example, when
            								TxThreshold = 0, the threshold is exceeded when there is at least
            								one free entry in the transmit FIFO. An interrupt can be generated
            								when the TxThreshold has been reached, but has no effect on DMA
            								requests, which are generated whenever the transmit FIFO has any
            								free entries.</description>
            <name>TXTHRESHOLD</name>
          </field>
        </fields>
        <name>CFGSPI1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2004</addressOffset>
        <description>SPI0 status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached. This is a read-only bit.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached. This is a read-only bit.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout. When 1, the receive FIFO has timed
            								out, based on the timeout configuration in the CFGSPI register. The
            								timeout condition can be cleared by writing a 1 to this bit, by
            								enabling or disabling the timeout interrupt, or by writing a 1 to
            								the timeout interrupt enable.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. When 1, a bus error has occurred while
            								processing data for SPI. The bus error flag can be cleared by
            								writing a 1 to this bit.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. When 1, the receive FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. When 1, the transmit FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. Indicates how many entries may be read
            								from the receive FIFO. 0 = FIFO empty. This is a read-only
            								field.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Count. Indicates how many entries may be
            								written to the transmit FIFO. 0 = FIFO full. This is a read-only
            								field that is valid only when the TxFIFO is fully configured and
            								enabled.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>STATSPI0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2104</addressOffset>
        <description>SPI0 status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached. This is a read-only bit.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached. This is a read-only bit.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout. When 1, the receive FIFO has timed
            								out, based on the timeout configuration in the CFGSPI register. The
            								timeout condition can be cleared by writing a 1 to this bit, by
            								enabling or disabling the timeout interrupt, or by writing a 1 to
            								the timeout interrupt enable.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. When 1, a bus error has occurred while
            								processing data for SPI. The bus error flag can be cleared by
            								writing a 1 to this bit.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. When 1, the receive FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. When 1, the transmit FIFO is currently
            								empty. This is a read-only bit.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. Indicates how many entries may be read
            								from the receive FIFO. 0 = FIFO empty. This is a read-only
            								field.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Count. Indicates how many entries may be
            								written to the transmit FIFO. 0 = FIFO full. This is a read-only
            								field that is valid only when the TxFIFO is fully configured and
            								enabled.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>STATSPI1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2008</addressOffset>
        <description>SPI0 interrupt status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached, and the related interrupt is
            								enabled.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached, and the related interrupt is
            								enabled.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Timeout. When 1, the receive FIFO has timed out,
            								based on the timeout configuration in the CFGSPI register, and the
            								related interrupt is enabled.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. This is simply a copy of the same bit in the
            								STATSPI register. The bus error interrupt is always
            								enabled.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. This is simply a copy of the same bit
            								in the STATSPI register.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This is simply a copy of the same bit
            								in the STATSPI register.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. This is simply a copy of the same field
            								in the STATSPI register, included here so an ISR can read all needed
            								status information in one read.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Available. This is simply a copy of the same
            								field in the STATSPI register, included here so an ISR can read all
            								needed status information in one read.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>INTSTATSPI0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2108</addressOffset>
        <description>SPI0 interrupt status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold. When 1, the receive FIFO threshold
            								has been reached, and the related interrupt is
            								enabled.</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold. When 1, the transmit FIFO
            								threshold has been reached, and the related interrupt is
            								enabled.</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Timeout. When 1, the receive FIFO has timed out,
            								based on the timeout configuration in the CFGSPI register, and the
            								related interrupt is enabled.</description>
            <name>RXTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bus Error. This is simply a copy of the same bit in the
            								STATSPI register. The bus error interrupt is always
            								enabled.</description>
            <name>BUSERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Empty. This is simply a copy of the same bit
            								in the STATSPI register.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Empty. This is simply a copy of the same bit
            								in the STATSPI register.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive FIFO Count. This is simply a copy of the same field
            								in the STATSPI register, included here so an ISR can read all needed
            								status information in one read.</description>
            <name>RXCOUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit FIFO Available. This is simply a copy of the same
            								field in the STATSPI register, included here so an ISR can read all
            								needed status information in one read.</description>
            <name>TXCOUNT</name>
          </field>
        </fields>
        <name>INTSTATSPI1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x300</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200C</addressOffset>
        <description>SPI0 control read and set register. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt Enable.</description>
            <name>RXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt Enable.</description>
            <name>TXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt Enable. When enabled, this
            								also enables the timeout for this SPI. Writing a 1 to this bit
            								resets the SPI timeout logic.</description>
            <name>RXTIMEOUTINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush. Writing a 1 to this bit forces the
            								receive FIFO to be empty.</description>
            <name>RXFLUSH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush. Writing a 1 to this bit forces the
            								transmit FIFO to be empty.</description>
            <name>TXFLUSH</name>
          </field>
        </fields>
        <name>CTLSETSPI0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210C</addressOffset>
        <description>SPI0 control read and set register. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt Enable.</description>
            <name>RXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt Enable.</description>
            <name>TXTHINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt Enable. When enabled, this
            								also enables the timeout for this SPI. Writing a 1 to this bit
            								resets the SPI timeout logic.</description>
            <name>RXTIMEOUTINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush. Writing a 1 to this bit forces the
            								receive FIFO to be empty.</description>
            <name>RXFLUSH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush. Writing a 1 to this bit forces the
            								transmit FIFO to be empty.</description>
            <name>TXFLUSH</name>
          </field>
        </fields>
        <name>CTLSETSPI1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2010</addressOffset>
        <description>SPI0 control clear register. Writing a 1 to any implemented bit
        						position causes the corresponding bit in the related CTLSET register to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt clear.</description>
            <name>RXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt clear.</description>
            <name>TXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt clear.</description>
            <name>RXTIMEOUTINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush clear. do the clear bits 8 and 9 do
            								anything?</description>
            <name>RXFLUSHCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush clear.</description>
            <name>TXFLUSHCLR</name>
          </field>
        </fields>
        <name>CTLCLRSPI0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2110</addressOffset>
        <description>SPI0 control clear register. Writing a 1 to any implemented bit
        						position causes the corresponding bit in the related CTLSET register to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Threshold Interrupt clear.</description>
            <name>RXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO Threshold Interrupt clear.</description>
            <name>TXTHINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO Timeout Interrupt clear.</description>
            <name>RXTIMEOUTINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO flush clear. do the clear bits 8 and 9 do
            								anything?</description>
            <name>RXFLUSHCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO flush clear.</description>
            <name>TXFLUSHCLR</name>
          </field>
        </fields>
        <name>CTLCLRSPI1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2014</addressOffset>
        <description>SPI0 received data. These registers are half word
        						addressable.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Receiver Data. This contains the next piece of received
            								data. The number of bits that are used depends on the LEN setting in
            								TXCTL / TXDATCTL.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL0 pin to be saved along with received data. The value will
            								reflect the SSEL0 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL1 pin to be saved along with received data. The value will
            								reflect the SSEL1 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL2 pin to be saved along with received data. The value will
            								reflect the SSEL2 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL3 pin to be saved along with received data. The value will
            								reflect the SSEL3 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start of Transfer flag. This flag will be 1 if this is the
            								first data after the SSELs went from deasserted to asserted (i.e.,
            								any previous transfer has ended). This information can be used to
            								identify the first piece of data in cases where the transfer length
            								is greater than 16 bit.</description>
            <name>SOT</name>
          </field>
        </fields>
        <name>RXDATSPI0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2114</addressOffset>
        <description>SPI0 received data. These registers are half word
        						addressable.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Receiver Data. This contains the next piece of received
            								data. The number of bits that are used depends on the LEN setting in
            								TXCTL / TXDATCTL.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL0 pin to be saved along with received data. The value will
            								reflect the SSEL0 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL1 pin to be saved along with received data. The value will
            								reflect the SSEL1 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL2 pin to be saved along with received data. The value will
            								reflect the SSEL2 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL3 pin to be saved along with received data. The value will
            								reflect the SSEL3 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start of Transfer flag. This flag will be 1 if this is the
            								first data after the SSELs went from deasserted to asserted (i.e.,
            								any previous transfer has ended). This information can be used to
            								identify the first piece of data in cases where the transfer length
            								is greater than 16 bit.</description>
            <name>SOT</name>
          </field>
        </fields>
        <name>RXDATSPI1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2018</addressOffset>
        <description>SPI0 transmit data. These registers are half word
        						addressable.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 1 to 16 bits of
            								data to be transmitted.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL0 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL0 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL0 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL0 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL1 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL1 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL1 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL1 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL2 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL2 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL2 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL2 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL3 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL3 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL3 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL3 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer. The asserted SSEL will be deasserted at
            								the end of a transfer, and remain so for at least the time specified
            								by the Transfer_delay value in the DLY register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not deasserted. SSEL not deasserted. This piece of
                										data is not treated as the end of a transfer. SSEL will not
                										be deasserted at the end of this data.</description>
                <name>NOT_DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deasserted. SSEL deasserted. This piece of data is
                										treated as the end of a transfer. SSEL will be deasserted at
                										the end of this piece of data.</description>
                <name>DEASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame. Between frames, a delay may be inserted, as
            								defined by the FRAME_DELAY value in the DLY register. The end of a
            								frame may not be particularly meaningful if the FRAME_DELAY value =
            								0. This control can be used as part of the support for frame lengths
            								greater than 16 bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data not EOF. This piece of data transmitted is not
                										treated as the end of a frame.</description>
                <name>DATA_NOT_EOF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data EOF. This piece of data is treated as the end
                										of a frame, causing the FRAME_DELAY time to be inserted
                										before subsequent data is transmitted.</description>
                <name>DATA_EOF</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore. This allows data to be transmitted using
            								the SPI without the need to read unneeded data from the receiver to
            								simplify the transmit process and can be used with the
            								DMA.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read received data. Received data must be read in
                										order to allow transmission to progress. In slave mode, an
                										overrun error will occur if received data is not read before
                										new data is received.</description>
                <name>READ_RECEIVED_DATA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignore received data. Received data is ignored,
                										allowing transmission without reading unneeded received
                										data. No receiver flags are generated.</description>
                <name>IGNORE_RECEIVED_DATA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Length. Specifies the data length from 1 to 16 bits.
            								Note that transfer lengths greater than 16 bits are supported by
            								implementing multiple sequential data transmits. 0x0 = Data transfer
            								is 1 bit in length. 0x1 = Data transfer is 2 bits in length. 0x2 =
            								Data transfer is 3 bits in length. ... 0xF = Data transfer is 16
            								bits in length.</description>
            <name>LEN</name>
          </field>
        </fields>
        <name>TXDATSPI0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2118</addressOffset>
        <description>SPI0 transmit data. These registers are half word
        						addressable.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 1 to 16 bits of
            								data to be transmitted.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL0 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL0 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL0 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL0 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL1 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL1 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL1 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL1 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL2 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL2 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL2 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL2 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL3 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL3 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asserted. SSEL3 asserted.</description>
                <name>ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not asserted. SSEL3 not asserted.</description>
                <name>NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer. The asserted SSEL will be deasserted at
            								the end of a transfer, and remain so for at least the time specified
            								by the Transfer_delay value in the DLY register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not deasserted. SSEL not deasserted. This piece of
                										data is not treated as the end of a transfer. SSEL will not
                										be deasserted at the end of this data.</description>
                <name>NOT_DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deasserted. SSEL deasserted. This piece of data is
                										treated as the end of a transfer. SSEL will be deasserted at
                										the end of this piece of data.</description>
                <name>DEASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame. Between frames, a delay may be inserted, as
            								defined by the FRAME_DELAY value in the DLY register. The end of a
            								frame may not be particularly meaningful if the FRAME_DELAY value =
            								0. This control can be used as part of the support for frame lengths
            								greater than 16 bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data not EOF. This piece of data transmitted is not
                										treated as the end of a frame.</description>
                <name>DATA_NOT_EOF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data EOF. This piece of data is treated as the end
                										of a frame, causing the FRAME_DELAY time to be inserted
                										before subsequent data is transmitted.</description>
                <name>DATA_EOF</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore. This allows data to be transmitted using
            								the SPI without the need to read unneeded data from the receiver to
            								simplify the transmit process and can be used with the
            								DMA.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read received data. Received data must be read in
                										order to allow transmission to progress. In slave mode, an
                										overrun error will occur if received data is not read before
                										new data is received.</description>
                <name>READ_RECEIVED_DATA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignore received data. Received data is ignored,
                										allowing transmission without reading unneeded received
                										data. No receiver flags are generated.</description>
                <name>IGNORE_RECEIVED_DATA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Length. Specifies the data length from 1 to 16 bits.
            								Note that transfer lengths greater than 16 bits are supported by
            								implementing multiple sequential data transmits. 0x0 = Data transfer
            								is 1 bit in length. 0x1 = Data transfer is 2 bits in length. 0x2 =
            								Data transfer is 3 bits in length. ... 0xF = Data transfer is 16
            								bits in length.</description>
            <name>LEN</name>
          </field>
        </fields>
        <name>TXDATSPI1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40000000</baseAddress>
    <description>System configuration</description>
    <groupName>SYSCON</groupName>
    <interrupts></interrupts>
    <name>SYSCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>System memory remap</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System memory remap. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Boot Loader Mode. Interrupt vectors are re-mapped
                										to Boot ROM.</description>
                <name>BOOT_LOADER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>User RAM Mode. Interrupt vectors are re-mapped to
                										Static RAM.</description>
                <name>USER_RAM_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>User Flash Mode. Interrupt vectors are not
                										re-mapped and reside in Flash.</description>
                <name>USER_FLASH_MODE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MAP</name>
          </field>
        </fields>
        <name>SYSMEMREMAP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>AHB multilayer matrix priority control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>I-Code bus priority. Should be lower than PRI_DCODE for
            								proper operation.</description>
            <name>PRI_ICODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>D-Code bus priority.</description>
            <name>PRI_DCODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System bus priority.</description>
            <name>PRI_SYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>DMA controller priority.</description>
            <name>PRI_DMA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System FIFO bus priority</description>
            <name>PRI_FIFO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Cortex-M0+ bus priority.</description>
            <name>PRI_M0</name>
          </field>
        </fields>
        <name>AHBMATPRIO</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>System tick counter calibration</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>System tick timer calibration value.</description>
            <name>CAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Initial value for the Systick timer.</description>
            <name>SKEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Initial value for the Systick timer.</description>
            <name>NOREF</name>
          </field>
        </fields>
        <name>SYSTCKCAL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>NMI Source Select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>The IRQ number of the interrupt that acts as the
            								Non-Maskable Interrupt (NMI) for the Cortex-M4, if enabled by
            								NMIENM4.</description>
            <name>IRQM4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>The IRQ number of the interrupt that acts as the
            								Non-Maskable Interrupt (NMI) for the Cortex-M0+, if enabled by
            								NMIENM0.</description>
            <name>IRQM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write a 1 to this bit to enable the Non-Maskable Interrupt
            								(NMI) source selected by IRQM0.</description>
            <name>NMIENM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write a 1 to this bit to enable the Non-Maskable Interrupt
            								(NMI) source selected by IRQM4.</description>
            <name>NMIENM4</name>
          </field>
        </fields>
        <name>NMISRC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Asynchronous APB Control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the asynchronous APB bridge and
            								subsystem.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Asynchronous APB bridge is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Asynchronous APB bridge is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>ASYNCAPBCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>System reset status register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>POR reset status</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No POR detected</description>
                <name>NO_POR_DETECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>POR detected. Writing a one clears this
                										reset.</description>
                <name>POR_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the external RESET pin. External reset
            								status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No reset event detected.</description>
                <name>NO_RESET_EVENT_DETEC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset detected. Writing a one clears this
                										reset.</description>
                <name>RESET_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EXTRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the Watchdog reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No WDT reset detected</description>
                <name>NO_WDT_RESET_DETECTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WDT reset detected. Writing a one clears this
                										reset.</description>
                <name>WDT_RESET_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the Brown-out detect reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No BOD reset detected</description>
                <name>NO_BOD_RESET_DETECTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>BOD reset detected. Writing a one clears this
                										reset.</description>
                <name>BOD_RESET_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the software system reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No System reset detected</description>
                <name>NO_SYSTEM_RESET_DETE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System reset detected. Writing a one clears this
                										reset.</description>
                <name>SYSTEM_RESET_DETECTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSRST</name>
          </field>
        </fields>
        <name>SYSRSTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Peripheral reset control 0</description>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash controller reset control. 0 = Clear reset to this
            								function. 1 = Assert reset to this function.</description>
            <name>FLASH_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash accelerator reset control. 0 = Clear reset to this
            								function. 1 = Assert reset to this function.</description>
            <name>FMC_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input mux reset control. 0 = Clear reset to this function.
            								1 = Assert reset to this function.</description>
            <name>MUX_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IOCON reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>IOCON_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO0 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>GPIO0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO1 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>GPIO1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pin interrupt (PINT) reset control. 0 = Clear reset to this
            								function. 1 = Assert reset to this function.</description>
            <name>PINT_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Grouped interrupt (GINT) reset control. 0 = Clear reset to
            								this function. 1 = Assert reset to this function.</description>
            <name>GINT_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DMA reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>DMA_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRC generator reset control. 0 = Clear reset to this
            								function. 1 = Assert reset to this function.</description>
            <name>CRC_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog timer reset control. 0 = Clear reset to this
            								function. 1 = Assert reset to this function.</description>
            <name>WWDT_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>RTC_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mailbox reset control. 0 = Clear reset to this function. 1
            								= Assert reset to this function.</description>
            <name>MAILBOX_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC0 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>ADC0_RST</name>
          </field>
        </fields>
        <name>PRESETCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Peripheral reset control 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Multi-rate timer (MRT) reset control. 0 = Clear reset to
            								this function. 1 = Assert reset to this function.</description>
            <name>MRT_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Repetitive interrupt timer (RIT) reset control. 0 = Clear
            								reset to this function. 1 = Assert reset to this
            								function.</description>
            <name>RIT_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>State configurable timer 0 (SCT0) reset control. 0 = Clear
            								reset to this function. 1 = Assert reset to this
            								function.</description>
            <name>SCT0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>System FIFO reset control. 0 = Clear reset to this
            								function. 1 = Assert reset to this function.</description>
            <name>FIFO_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Micro-tick Timer reset control. 0 = Clear reset to this
            								function. 1 = Assert reset to this function.</description>
            <name>UTICK_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 2 reset control. 0 = Clear reset to this function. 1
            								= Assert reset to this function.</description>
            <name>TIMER2_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 3 reset control. 0 = Clear reset to this function. 1
            								= Assert reset to this function.</description>
            <name>TIMER3_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 4 reset control. 0 = Clear reset to this function. 1
            								= Assert reset to this function.</description>
            <name>TIMER4_RST</name>
          </field>
        </fields>
        <name>PRESETCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>Set bits in PRESETCTRL0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the PRESETCTRL0 register, if they are implemented. Bits that
            								do not correspond to defined bits in PRESETCTRL0 are reserved and
            								only zeroes should be written to them.</description>
            <name>RST_SET0</name>
          </field>
        </fields>
        <name>PRESETCTRLSET0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x50</addressOffset>
        <description>Set bits in PRESETCTRL1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the PRESETCTRL1 register, if they are implemented. Bits that
            								do not correspond to defined bits in PRESETCTRL1 are reserved and
            								only zeroes should be written to them.</description>
            <name>RST_SET1</name>
          </field>
        </fields>
        <name>PRESETCTRLSET1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x54</addressOffset>
        <description>Clear bits in PRESETCTRL0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the PRESETCTRL0 register, if they are implemented. Bits
            								that do not correspond to defined bits in PRESETCTRL0 are reserved
            								and only zeroes should be written to them.</description>
            <name>RST_CLR0</name>
          </field>
        </fields>
        <name>PRESETCTRLCLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x58</addressOffset>
        <description>Clear bits in PRESETCTRL1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the PRESETCTRL1 register, if they are implemented. Bits
            								that do not correspond to defined bits in PRESETCTRL1 are reserved
            								and only zeroes should be written to them.</description>
            <name>RST_CLR1</name>
          </field>
        </fields>
        <name>PRESETCTRLCLR1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x5C</addressOffset>
        <description>POR captured PIO status 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>State of PIO0_31 through PIO0_0 at power-on
            								reset</description>
            <name>PIOPORSTAT</name>
          </field>
        </fields>
        <name>PIOPORCAP0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x60</addressOffset>
        <description>POR captured PIO status 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>State of PIO1_31 through PIO1_0 at power-on
            								reset</description>
            <name>PIOPORSTAT</name>
          </field>
        </fields>
        <name>PIOPORCAP1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>Reset captured PIO status 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>State of PIO0_31 through PIO0_0 for resets other than
            								power-on reset.</description>
            <name>PIORESSTAT</name>
          </field>
        </fields>
        <name>PIORESCAP0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x6C</addressOffset>
        <description>Reset captured PIO status 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>State of PIO1_31 through PIO1_0 for resets other than
            								power-on reset.</description>
            <name>PIORESSTAT</name>
          </field>
        </fields>
        <name>PIORESCAP1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>Main clock source select A</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock source for main clock source selector A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC Oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLKIN</description>
                <name>CLKIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>MAINCLKSELA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>Main clock source select B</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock source for main clock source selector B. Selects the
            								clock source for the main clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>MAINCLKSELA. Use the clock source selected in
                										MAINCLKSELA register.</description>
                <name>MAINCLKSELA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System PLL input.</description>
                <name>SYSTEM_PLL_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System PLL output.</description>
                <name>SYSTEM_PLL_OUTPUT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RTC osc output. RTC oscillator 32 kHz
                										output.</description>
                <name>RTC_OSC_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>MAINCLKSELB</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C</addressOffset>
        <description>ADC clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>ADC clock source.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Main clock</description>
                <name>MAIN_CLOCK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System PLL output</description>
                <name>SYSTEM_PLL_OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC Oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>ADCCLKSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>CLKOUT clock source select A</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CLKOUT clock source</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Main clock</description>
                <name>MAIN_CLOCK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLKIN</description>
                <name>CLKIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>CLKOUTSELA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98</addressOffset>
        <description>CLKOUT clock source select B</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CLKOUT clock source</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLKOUTSELA. Clock source selected in the CLKOUTSELA
                										register.</description>
                <name>CLKOUTSELA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>reserved</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>reserved</description>
                <name>RESERVED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RTC 32 kHz clock</description>
                <name>RTC_32_KHZ_CLOCK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>CLKOUTSELB</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>PLL clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System PLL clock source</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC Oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLKIN</description>
                <name>CLKIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RTC 32 kHz clock</description>
                <name>RTC_32_KHZ_CLOCK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>SYSPLLCLKSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC0</addressOffset>
        <description>AHB Clock control 0</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the Boot ROM. 0 = Disable; 1 =
            								Enable.</description>
            <name>ROM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for SRAM1. 0 = Disable; 1 =
            								Enable.</description>
            <name>SRAM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for SRAM2. 0 = Disable; 1 =
            								Enable.</description>
            <name>SRAM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the flash controller. 0 = Disable; 1
            								= Enable.</description>
            <name>FLASH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the Flash accelerator. 0 = Disable; 1
            								= Enable.</description>
            <name>FMC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the input muxes. 0 = Disable; 1 =
            								Enable.</description>
            <name>INPUTMUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the IOCON block. 0 = Disable; 1 =
            								Enable.</description>
            <name>IOCON</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the GPIO0 port registers. 0 =
            								Disable; 1 = Enable.</description>
            <name>GPIO0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the GPIO1 port registers. 0 =
            								Disable; 1 = Enable.</description>
            <name>GPIO1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the pin interrupt block.0 = Disable;
            								1 = Enable.</description>
            <name>PINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the grouped pin interrupt block. 0 =
            								Disable; 1 = Enable.</description>
            <name>GINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the DMA controller. 0 = Disable; 1 =
            								Enable.</description>
            <name>DMA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the CRC engine. 0 = Disable; 1 =
            								Enable.</description>
            <name>CRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the Watchdog Timer. 0 = Disable; 1 =
            								Enable.</description>
            <name>WWDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the RTC. 0 = Disable; 1 =
            								Enable.</description>
            <name>RTC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the Mailbox. 0 = Disable; 1 =
            								Enable.</description>
            <name>MAILBOX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the ADC0 register interface. 0 =
            								Disable; 1 = Enable.</description>
            <name>ADC0</name>
          </field>
        </fields>
        <name>AHBCLKCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC4</addressOffset>
        <description>AHB Clock control 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the Multi-Rate Timer. 0 = Disable; 1
            								= Enable.</description>
            <name>MRT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the repetitive interrupt timer. 0 =
            								Disable; 1 = Enable.</description>
            <name>RIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for SCT0. 0 = Disable; 1 =
            								Enable.</description>
            <name>SCT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for system FIFOs. 0 = Disable; 1 =
            								Enable.</description>
            <name>FIFO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the Micro-tick Timer. 0 = Disable; 1
            								= Enable.</description>
            <name>UTICK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for Timer 2. 0 = Disable; 1 =
            								Enable.</description>
            <name>TIMER2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for Timer 3. 0 = Disable; 1 =
            								Enable.</description>
            <name>TIMER3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for Timer 4. 0 = Disable; 1 =
            								Enable.</description>
            <name>TIMER4</name>
          </field>
        </fields>
        <name>AHBCLKCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC8</addressOffset>
        <description>Set bits in AHBCLKCTRL0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the AHBCLKCTRL0 register, if they are implemented. Bits that
            								do not correspond to defined bits in AHBCLKCTRL0 are reserved and
            								only zeroes should be written to them.</description>
            <name>CLK_SET0</name>
          </field>
        </fields>
        <name>AHBCLKCTRLSET0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xCC</addressOffset>
        <description>Set bits in AHBCLKCTRL1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the AHBCLKCTRL1 register, if they are implemented. Bits that
            								do not correspond to defined bits in AHBCLKCTRL1 are reserved and
            								only zeroes should be written to them.</description>
            <name>CLK_SET1</name>
          </field>
        </fields>
        <name>AHBCLKCTRLSET1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xD0</addressOffset>
        <description>Clear bits in AHBCLKCTRL0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the AHBCLKCTRL0 register, if they are implemented. Bits
            								that do not correspond to defined bits in AHBCLKCTRL0 are reserved
            								and only zeroes should be written to them.</description>
            <name>CLK_CLR0</name>
          </field>
        </fields>
        <name>AHBCLKCTRLCLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xD4</addressOffset>
        <description>Clear bits in AHBCLKCTRL1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the AHBCLKCTRL1 register, if they are implemented. Bits
            								that do not correspond to defined bits in AHBCLKCTRL1 are reserved
            								and only zeroes should be written to them.</description>
            <name>CLK_CLR1</name>
          </field>
        </fields>
        <name>AHBCLKCTRLCLR1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE0</addressOffset>
        <description>SYSTICK clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SYSTICK clock divider value. 0: Disable SYSTICK timer
            								clock. 1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>SYSTICKCLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>System clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System AHB clock divider value. 0: System clock disabled.
            								1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>AHBCLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>ADC clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>ADC clock divider value. 0: Disable ADC clock. 1: Divide by
            								1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>ADCCLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>CLKOUT clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CLKOUT clock divider value. 0: Disable CLKOUT clock
            								divider. 1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>CLKOUTDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x120</addressOffset>
        <description>Frequency measure register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xE</bitWidth>
            <description>Stores the capture result which is used to calculate the
            								frequency of the target clock. This field is
            								read-only.</description>
            <name>CAPVAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set this bit to one to initiate a frequency measurement
            								cycle. Hardware clears this bit when the measurement cycle has
            								completed and there is valid capture data in the CAPVAL field (bits
            								13:0).</description>
            <name>PROG</name>
          </field>
        </fields>
        <name>FREQMECTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x124</addressOffset>
        <description>Flash wait states configuration</description>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Flash memory access time. FLASHTIM +1 is equal to the
            								number of system clocks used for flash access.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. 1 system clock flash access time
                										(for system clock frequencies of up to MHz).</description>
                <name>1_CLOCK_CYCLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. 2 system clocks flash access time
                										(for system clock frequencies of up to MHz).</description>
                <name>2_CLOCK_CYCLES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. 3 system clocks flash access time
                										(for system clock frequencies of up to MHz).</description>
                <name>3_CLOCK_CYCLES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clock cycles. 4 system clocks flash access
                										time.</description>
                <name>4_CLOCK_CYCLES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clock cycles. 5 system clocks flash access
                										time.</description>
                <name>5_CLOCK_CYCLES</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clock cycles. 6 system clocks flash access
                										time.</description>
                <name>6_CLOCK_CYCLES</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clock cycles. 7 system clocks flash access
                										time.</description>
                <name>7_CLOCK_CYCLES</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clock cycles. 8 system clocks flash access
                										time.</description>
                <name>8_CLOCK_CYCLES</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASHTIM</name>
          </field>
        </fields>
        <name>FLASHCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x148</addressOffset>
        <description>Serial interface FIFO enables</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART0 transmitter FIFO enable</description>
            <name>U0TXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART1 transmitter FIFO enable</description>
            <name>U1TXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART2 transmitter FIFO enable</description>
            <name>U2TXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART3 transmitter FIFO enable</description>
            <name>U3TXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 transmitter FIFO enable</description>
            <name>SPI0TXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 transmitter FIFO enable</description>
            <name>SPI1TXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART0 receiver FIFO enable</description>
            <name>U0RXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART1 receiver FIFO enable</description>
            <name>U1RXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART2 receiver FIFO enable</description>
            <name>U2RXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART3 receiver FIFO enable</description>
            <name>U3RXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 receiver FIFO enable</description>
            <name>SPI0RXFIFOEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 receiver FIFO enable</description>
            <name>SPI1RXFIFOEN</name>
          </field>
        </fields>
        <name>FIFOCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x184</addressOffset>
        <description>IRC oscillator control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trim value</description>
            <name>TRIM</name>
          </field>
        </fields>
        <name>IRCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x190</addressOffset>
        <description>RTC oscillator 32 kHz output control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 32 kHz clock enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. RTC clock off.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. RTC clock on.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EN</name>
          </field>
        </fields>
        <name>RTCOSCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1B0</addressOffset>
        <description>PLL control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Bandwidth select R value</description>
            <name>SELR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Bandwidth select I value</description>
            <name>SELI</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Bandwidth select P value</description>
            <name>SELP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL bypass control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. PLL CCO is used to create the PLL
                										output.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. PLL is bypassed, the PLL input clock is
                										routed directly to the PLL output (default).</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bypass feedback clock divide by 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 2. The CCO feedback clock is divided by 2
                										in addition to the programmed M divide.</description>
                <name>DIVIDE_BY_2</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass. The CCO feedback clock is divided only by
                										the programmed M divide.</description>
                <name>BYPASS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASSCCODIV2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable spread spectrum/fractional mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal mode.</description>
                <name>NORMAL_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSGC mode. Spread spectrum/fractional
                										mode.</description>
                <name>SSGC_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UPLIMOFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL filter control. Set this bit to one when the SSGC is
            								disabled or at low frequencies.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSCG control. The PLL filter uses the parameters
                										derived from the SSCG decoder.</description>
                <name>SSCG_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MDEC control. The PLL filter uses the programmable
                										fields SELP, SELR, and SELI in this register to control the
                										filter constants.</description>
                <name>MDEC_CONTROL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BANDSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL0 direct input enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The PLL input divider (N divider) output
                										is used to drive the PLL CCO.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The PLL input divider (N divider) is
                										bypassed. the PLL input clock is used directly to drive the
                										PLL CCO.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTI</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL0 direct output enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The PLL output divider (P divider) is
                										used to create the PLL output.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The PLL output divider (P divider) is
                										bypassed, the PLL CCO output is used as the PLL
                										output.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTO</name>
          </field>
        </fields>
        <name>SYSPLLCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x8000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1B4</addressOffset>
        <description>PLL status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL0 lock indicator</description>
            <name>LOCK</name>
          </field>
        </fields>
        <name>SYSPLLSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1B8</addressOffset>
        <description>PLL N decoder</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Decoded N-divider coefficient value</description>
            <name>NDEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>NDEC reload request. When a 1 is written to this bit, the
            								NDEC value is loaded into the PLL. Must be cleared by software for
            								any subsequent load, or the PLL can be powered down and back up via
            								the PDEN_SYS_PLL bit in the PDRUNCFG register if the NDEC value is
            								changed.</description>
            <name>NREQ</name>
          </field>
        </fields>
        <name>SYSPLLNDEC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1BC</addressOffset>
        <description>PLL P decoder</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Decoded P-divider coefficient value</description>
            <name>PDEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDEC reload request. When a 1 is written to this bit, the
            								PDEC value is loaded into the PLL. Must be cleared by software for
            								any subsequent load, or the PLL can be powered down and back up via
            								the PDEN_SYS_PLL bit in the PDRUNCFG register if the PDEC value is
            								changed.</description>
            <name>PREQ</name>
          </field>
        </fields>
        <name>SYSPLLPDEC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C0</addressOffset>
        <description>PLL spread spectrum control 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x11</bitWidth>
            <description>Decoded M-divider coefficient value</description>
            <name>MDEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MDEC reload request. When a 1 is written to this bit, the
            								MDEC value is loaded into the PLL. Must be cleared by software for
            								any subsequent load, or the PLL can be powered down and back up via
            								the PDEN_SYS_PLL bit in the PDRUNCFG register if the MDEC value is
            								changed.</description>
            <name>MREQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select spread spectrum mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Spread spectrum mode. Spread spectrum mode
                										enabled.</description>
                <name>SPREAD_SPECTRUM_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MDEC enabled. Spread spectrum clock generator not
                										used.</description>
                <name>MDEC_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL_EXT</name>
          </field>
        </fields>
        <name>SYSPLLSSCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C4</addressOffset>
        <description>PLL spread spectrum control 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x13</bitWidth>
            <description>M- divider value with fraction. MD[18:11] : integer portion
            								of the feedback divider value. MD[10:0] : fractional portion of the
            								feedback divider value.</description>
            <name>MD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MD reload request. When a 1 is written to this bit, the MD
            								value is loaded into the PLL. This bit is cleared when the load is
            								complete.</description>
            <name>MDREQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Programmable modulation frequency fm = Fref/Nss with Fref =
            								Fin/N 0b000 =&gt; Nss = 512 (fm = 3.9 - 7.8 kHz) 0b001 =&gt; Nss = 384 (fm
            								= 5.2 - 10.4 kHz) 0b010 =&gt; Nss = 256 (fm = 7.8 - 15.6 kHz) 0b011 =&gt;
            								Nss = 128 (fm = 15.6 - 31.3 kHz) 0b100 =&gt; Nss = 64 (fm = 32.3 - 64.5
            								kHz) 0b101 =&gt; Nss = 32 (fm = 62.5- 125 kHz) 0b110 =&gt; Nss = 24 (fm =
            								83.3- 166.6 kHz) 0b111 =&gt; Nss = 16 (fm = 125- 250 kHz)</description>
            <name>MF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Programmable frequency modulation depth deltafmodpk-pk =
            								Fref x k/Fcco = k/MDdec 0 = no spread 0b000 =&gt; k = 0 (no spread
            								spectrum) 0b001 =&gt; k = 1 0b010 =&gt; k = 1.5 0b011 =&gt; k = 2 0b100 =&gt; k
            								= 3 0b101 =&gt; k = 4 0b110 =&gt; k = 6 0b111 =&gt; k = 8</description>
            <name>MR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Modulation waveform control 0 = no compensation
            								Compensation for low pass filtering of the PLL to get a triangular
            								modulation at the output of the PLL, giving a flat frequency
            								spectrum. 0b00 =&gt; no compensation 0b10 =&gt; recommended setting 0b11
            								=&gt; max. compensation</description>
            <name>MC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Power down.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Spread spectrum controller is
                										enabled</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Spread spectrum controller is
                										disabled</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select modulation frequency.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fixed. Fixed modulation frequency.</description>
                <name>FIXED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Dither. Randomly dither between two modulation
                										frequencies.</description>
                <name>DITHER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DITHER</name>
          </field>
        </fields>
        <name>SYSPLLSSCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x10000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>Power configuration register</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator output. 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_IRC_OSC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator. 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_IRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash memory. 0 = Powered; 1 = Powered down.</description>
            <name>PDEN_FLASH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown-out Detect reset. 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_BOD_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown-out Detect interrupt. 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_BOD_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC0. 0 = Powered; 1 = Powered down.</description>
            <name>PDEN_ADC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>First 8 kB of SRAM0). 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_SRAM0A</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Remaining portion of SRAM0). 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_SRAM0B</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SRAM1. 0 = Powered; 1 = Powered down.</description>
            <name>PDEN_SRAM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SRAM2 (undedicated 8 kB RAM). 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_SRAM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ROM. 0 = Powered; 1 = Powered down.</description>
            <name>PDEN_ROM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Vdda to the ADC, must be enabled for the ADC to work. Also
            								see bit 23. 0 = Powered; 1 = Powered down.</description>
            <name>PDEN_VDDA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog oscillator. 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_WDT_OSC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL0. 0 = Powered; 1 = Powered down.</description>
            <name>PDEN_SYS_PLL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Vrefp to the ADC, must be enabled for the ADC to work. Also
            								see bit 19. 0 = Powered; 1 = Powered down.</description>
            <name>PDEN_VREFP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>32 kHz RTC oscillator. 0 = Powered; 1 = Powered
            								down.</description>
            <name>PDEN_32K_OSC</name>
          </field>
        </fields>
        <name>PDRUNCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x500500</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x214</addressOffset>
        <description>Set bits in PDRUNCFG</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the PDRUNCFG register, if they are implemented. Bits that do
            								not correspond to defined bits in PDRUNCFG are reserved and only
            								zeroes should be written to them.</description>
            <name>PD_SET</name>
          </field>
        </fields>
        <name>PDRUNCFGSET</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x218</addressOffset>
        <description>Clear bits in PDRUNCFG</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the PDRUNCFG register, if they are implemented. Bits that
            								do not correspond to defined bits in PDRUNCFG are reserved and only
            								zeroes should be written to them.</description>
            <name>PD_CLR</name>
          </field>
        </fields>
        <name>PDRUNCFGCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x240</addressOffset>
        <description>Start logic 0 wake-up enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>WWDT interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.</description>
            <name>WWDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.</description>
            <name>BOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DMA wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
            								Typically used in sleep mode only.</description>
            <name>DMA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt 0 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled.</description>
            <name>GINT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 0 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 1 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 2 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 3 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Micro-tick Timer wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.</description>
            <name>UTICK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Multi-Rate Timer wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Typically used in sleep mode only.</description>
            <name>MRT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 0 wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.Typically used in sleep mode only.</description>
            <name>TIMER0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 1 wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.Typically used in sleep mode only.</description>
            <name>TIMER1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 2 wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.Typically used in sleep mode only.</description>
            <name>TIMER2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 3 wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.Typically used in sleep mode only.</description>
            <name>TIMER3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 4 wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.Typically used in sleep mode only.</description>
            <name>TIMER4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT0 wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.Typically used in sleep mode only.</description>
            <name>SCT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>USART0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>USART1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART2 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>USART2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART2 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>USART3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>I2C0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>I2C1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C2 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>I2C2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>SPI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled. Peripheral interrupt.</description>
            <name>SPI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC0 sequence A interrupt wake-up. 0 = Wake-up disabled. 1
            								= Wake-up enabled.Typically used in sleep mode only.</description>
            <name>ADC0_SEQA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC0 sequence B interrupt wake-up. 0 = Wake-up disabled. 1
            								= Wake-up enabled.Typically used in sleep mode only.</description>
            <name>ADC0_SEQB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC0 threshold and error interrupt wake-up. 0 = Wake-up
            								disabled. 1 = Wake-up enabled.Typically used in sleep mode
            								only.</description>
            <name>ADC0_THCMP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up
            								enabled.</description>
            <name>RTC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mailbox interrupt wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled.Typically used in sleep mode only.</description>
            <name>MAILBOX</name>
          </field>
        </fields>
        <name>STARTERP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x244</addressOffset>
        <description>Start logic 1 wake-up enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt 0 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled.</description>
            <name>GINT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 4 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 5 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 6 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 7 wake-up. 0 = Wake-up disabled. 1 =
            								Wake-up enabled. Not for pattern match.</description>
            <name>PINT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Repetitive Interrupt Timer interrupt wake-up. 0 = Wake-up
            								disabled. 1 = Wake-up enabled. Typically used in sleep mode
            								only.</description>
            <name>RIT</name>
          </field>
        </fields>
        <name>STARTERP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x248</addressOffset>
        <description>Set bits in STARTERP0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the STARTERP0 register, if they are implemented. Bits that
            								do not correspond to defined bits in STARTERP0 are reserved and only
            								zeroes should be written to them.</description>
            <name>START_SET0</name>
          </field>
        </fields>
        <name>STARTERPSET0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24C</addressOffset>
        <description>Set bits in STARTERP1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the STARTERP1 register, if they are implemented. Bits that
            								do not correspond to defined bits in STARTERP1 are reserved and only
            								zeroes should be written to them.</description>
            <name>START_SET1</name>
          </field>
        </fields>
        <name>STARTERPSET1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x250</addressOffset>
        <description>Clear bits in STARTERP0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the STARTERP0 register, if they are implemented. Bits
            								that do not correspond to defined bits in STARTERP0 are reserved and
            								only zeroes should be written to them.</description>
            <name>START_CLR0</name>
          </field>
        </fields>
        <name>STARTERPCLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x254</addressOffset>
        <description>Clear bits in STARTERP1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the STARTERP1 register, if they are implemented. Bits
            								that do not correspond to defined bits in STARTERP1 are reserved and
            								only zeroes should be written to them.</description>
            <name>START_CLR1</name>
          </field>
        </fields>
        <name>STARTERPCLR1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>CPU Control for multiple processors</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines which CPU is considered the master. The master
            								CPU cannot have its clock turned off via the related CMnCLKEN bit or
            								be reset via the related CMxRSTEN in this register. The slave CPU
            								wakes up briefly following device reset, then goes back to sleep
            								until activated by the master CPU.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>M0+. Cortex-M0+ is the master CPU.</description>
                <name>M0P</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>M4. Cortex-M4 is the master CPU.</description>
                <name>M4</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MASTERCPU</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cortex-M4 clock enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The Cortex-M4 clock is not
                										enabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Cortex-M4 clock is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CM4CLKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cortex-M0+ clock enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The Cortex-M0+ clock is not
                										enabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Cortex-M0+ clock is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CM0CLKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cortex-M4 reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The Cortex-M4 is not being
                										reset.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Cortex-M4 is being
                										reset.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CM4RSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cortex-M0+ reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The Cortex-M0+ is not being
                										reset.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Cortex-M0+ is being
                										reset.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CM0RSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Identifies the owner of reduced power mode control: which
            								CPU can cause the device to enter Sleep, Deep Sleep, Power-down, and
            								Deep Power-down modes.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>M0+. Cortex-M0+ is the owner of reduced power mode
                										control.</description>
                <name>M0P</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>M4. Cortex-M4 is the owner of reduced power mode
                										control.</description>
                <name>M4</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POWERCPU</name>
          </field>
        </fields>
        <name>CPUCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4D</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Coprocessor Boot Address</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Slave processor boot address.</description>
            <name>BOOTADDR</name>
          </field>
        </fields>
        <name>CPBOOT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>Coprocessor Stack Address</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Slave processor stack address.</description>
            <name>STACKADDR</name>
          </field>
        </fields>
        <name>CPSTACK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3F4</addressOffset>
        <description>JTAG ID code register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>JTAG ID code.</description>
            <name>JTAGID</name>
          </field>
        </fields>
        <name>JTAGIDCODE</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3F8</addressOffset>
        <description>Part ID register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Part ID</description>
            <name>PARTID</name>
          </field>
        </fields>
        <name>DEVICE_ID0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3FC</addressOffset>
        <description>Boot ROM and die revision register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Revision.</description>
            <name>REVID</name>
          </field>
        </fields>
        <name>DEVICE_ID1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40004000</baseAddress>
    <description>Standard counter/timer 2 </description>
    <interrupts>
      <interrupt>
        <name>CT32B2</name>
        <value>0xD</value>
      </interrupt>
    </interrupts>
    <name>CT32B2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The
        						IR can be read to identify which of eight possible interrupt sources are
        						pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 3 event.</description>
            <name>CR3INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer
        						Counter functions. The Timer Counter can be disabled or reset through the
        						TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and Prescale Counter are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do nothing.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and the Prescale Counter
                										are synchronously reset on the next positive edge of PCLK.
                										The counters remain reset until TCR[1] is returned to
                										zero.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 32 bit TC is incremented every PR+1 cycles of
        						PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (PC) is equal to this
        						value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PRVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 32 bit PC is a counter which is incremented
        						to the value stored in PR. When the value in PR is reached, the TC is
        						incremented and the PC is cleared. The PC is observable and controllable
        						through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt
        						is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR0 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1
            								matches the value in the TC. 0 = disabled. 1 = enabled. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR1 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR2 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR3 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the
        						capture inputs are used to load the Capture Registers and whether or not an
        						interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0: a sequence of 0 then 1
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0: a sequence of 1 then 0
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load
            								generates an interrupt.</description>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1: a sequence of 0 then 1
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1: a sequence of 1 then 0
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load
            								generates an interrupt.</description>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2: a sequence of 0 then 1
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load
            								generates an interrupt.</description>
            <name>CAP2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 3: a sequence of 0 then 1
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 3: a sequence of 1 then 0
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 3 capture event: a CR3 load
            								generates an interrupt.</description>
            <name>CAP3I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and
        						the external match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output
            								MAT0, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR0, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output
            								MAT1, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR1, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of output
            								MAT2, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR2, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output
            								MAT3, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR3, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of
            								External Match 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT0 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT0 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of
            								External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT1 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT1 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of
            								External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT2 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT2 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of
            								External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT3 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT3 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter
        						mode, and in Counter mode selects the signal and edge(s) for
        						counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode This field selects which rising PCLK
            								edges can increment Timer's Prescale Counter (PC), or clear PC and
            								increment Timer Counter (TC). Timer Mode: the TC is incremented when
            								the Prescale Counter matches the Prescale Register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode. Incremented every rising PCLK
                										edge.</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode rising edge. TC is incremented on
                										rising edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge. TC is incremented on
                										falling edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge. TC is incremented on both
                										edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_DUAL_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select When bits 1:0 in this register are not
            								00, these bits select which CAP pin is sampled for clocking. Note:
            								If Counter mode is selected for a particular CAPn input in the CTCR,
            								the 3 bits for that input in the Capture Control Register (CCR) must
            								be programmed as 000. However, capture and/or interrupt can be
            								selected for the other 3 CAPn inputs in the same
            								timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0. CAPn.0 for TIMERn</description>
                <name>CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1. CAPn.1 for TIMERn</description>
                <name>CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2. CAPn.2 for TIMERn</description>
                <name>CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 3. CAPn.3 for TIMERn</description>
                <name>CHANNEL_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CINSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the
            								prescaler when the capture-edge event specified in bits 7:5
            								occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which
            								capture input edge will cause the timer and prescaler to be cleared.
            								These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and
            								0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Rising Edge. Rising edge of the signal on
                										capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_RISING_EDG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Falling Edge. Falling edge of the signal
                										on capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_FALLING_ED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Rising Edge. Rising edge of the signal on
                										capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_RISING_EDG</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Falling Edge. Falling edge of the signal
                										on capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Rising Edge. Rising edge of the signal on
                										capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_RISING_EDG</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Falling Edge. Falling edge of the signal
                										on capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_FALLING_ED</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external
        						match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT0 is controlled by
                										EM0.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT01 is controlled by
                										EM1.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT2 is controlled by
                										EM2.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3. Note: It is recommended to
            								use match channel 3 to set the PWM cycle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT3 is controlled by
                										EM3.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT132Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40008000</baseAddress>
    <derivedFrom>CT32B2</derivedFrom>
    <description>Standard counter/timer 3 </description>
    <interrupts>
      <interrupt>
        <name>CT32B3</name>
        <value>0xE</value>
      </interrupt>
    </interrupts>
    <name>CT32B3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The
        						IR can be read to identify which of eight possible interrupt sources are
        						pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 3 event.</description>
            <name>CR3INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer
        						Counter functions. The Timer Counter can be disabled or reset through the
        						TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and Prescale Counter are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do nothing.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and the Prescale Counter
                										are synchronously reset on the next positive edge of PCLK.
                										The counters remain reset until TCR[1] is returned to
                										zero.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 32 bit TC is incremented every PR+1 cycles of
        						PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (PC) is equal to this
        						value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PRVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 32 bit PC is a counter which is incremented
        						to the value stored in PR. When the value in PR is reached, the TC is
        						incremented and the PC is cleared. The PC is observable and controllable
        						through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt
        						is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR0 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1
            								matches the value in the TC. 0 = disabled. 1 = enabled. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR1 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR2 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR3 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the
        						capture inputs are used to load the Capture Registers and whether or not an
        						interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0: a sequence of 0 then 1
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0: a sequence of 1 then 0
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load
            								generates an interrupt.</description>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1: a sequence of 0 then 1
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1: a sequence of 1 then 0
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load
            								generates an interrupt.</description>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2: a sequence of 0 then 1
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load
            								generates an interrupt.</description>
            <name>CAP2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 3: a sequence of 0 then 1
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 3: a sequence of 1 then 0
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 3 capture event: a CR3 load
            								generates an interrupt.</description>
            <name>CAP3I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and
        						the external match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output
            								MAT0, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR0, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output
            								MAT1, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR1, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of output
            								MAT2, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR2, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output
            								MAT3, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR3, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of
            								External Match 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT0 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT0 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of
            								External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT1 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT1 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of
            								External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT2 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT2 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of
            								External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT3 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT3 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter
        						mode, and in Counter mode selects the signal and edge(s) for
        						counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode This field selects which rising PCLK
            								edges can increment Timer's Prescale Counter (PC), or clear PC and
            								increment Timer Counter (TC). Timer Mode: the TC is incremented when
            								the Prescale Counter matches the Prescale Register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode. Incremented every rising PCLK
                										edge.</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode rising edge. TC is incremented on
                										rising edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge. TC is incremented on
                										falling edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge. TC is incremented on both
                										edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_DUAL_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select When bits 1:0 in this register are not
            								00, these bits select which CAP pin is sampled for clocking. Note:
            								If Counter mode is selected for a particular CAPn input in the CTCR,
            								the 3 bits for that input in the Capture Control Register (CCR) must
            								be programmed as 000. However, capture and/or interrupt can be
            								selected for the other 3 CAPn inputs in the same
            								timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0. CAPn.0 for TIMERn</description>
                <name>CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1. CAPn.1 for TIMERn</description>
                <name>CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2. CAPn.2 for TIMERn</description>
                <name>CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 3. CAPn.3 for TIMERn</description>
                <name>CHANNEL_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CINSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the
            								prescaler when the capture-edge event specified in bits 7:5
            								occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which
            								capture input edge will cause the timer and prescaler to be cleared.
            								These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and
            								0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Rising Edge. Rising edge of the signal on
                										capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_RISING_EDG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Falling Edge. Falling edge of the signal
                										on capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_FALLING_ED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Rising Edge. Rising edge of the signal on
                										capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_RISING_EDG</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Falling Edge. Falling edge of the signal
                										on capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Rising Edge. Rising edge of the signal on
                										capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_RISING_EDG</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Falling Edge. Falling edge of the signal
                										on capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_FALLING_ED</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external
        						match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT0 is controlled by
                										EM0.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT01 is controlled by
                										EM1.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT2 is controlled by
                										EM2.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3. Note: It is recommended to
            								use match channel 3 to set the PWM cycle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT3 is controlled by
                										EM3.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT132Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4000C000</baseAddress>
    <derivedFrom>CT32B2</derivedFrom>
    <description>Standard counter/timer 4 </description>
    <interrupts>
      <interrupt>
        <name>CT32B4</name>
        <value>0xF</value>
      </interrupt>
    </interrupts>
    <name>CT32B4</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The
        						IR can be read to identify which of eight possible interrupt sources are
        						pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 3 event.</description>
            <name>CR3INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer
        						Counter functions. The Timer Counter can be disabled or reset through the
        						TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and Prescale Counter are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do nothing.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and the Prescale Counter
                										are synchronously reset on the next positive edge of PCLK.
                										The counters remain reset until TCR[1] is returned to
                										zero.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 32 bit TC is incremented every PR+1 cycles of
        						PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (PC) is equal to this
        						value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PRVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 32 bit PC is a counter which is incremented
        						to the value stored in PR. When the value in PR is reached, the TC is
        						incremented and the PC is cleared. The PC is observable and controllable
        						through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt
        						is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR0 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1
            								matches the value in the TC. 0 = disabled. 1 = enabled. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR1 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR2 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR3 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the
        						capture inputs are used to load the Capture Registers and whether or not an
        						interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0: a sequence of 0 then 1
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0: a sequence of 1 then 0
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load
            								generates an interrupt.</description>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1: a sequence of 0 then 1
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1: a sequence of 1 then 0
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load
            								generates an interrupt.</description>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2: a sequence of 0 then 1
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load
            								generates an interrupt.</description>
            <name>CAP2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 3: a sequence of 0 then 1
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 3: a sequence of 1 then 0
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 3 capture event: a CR3 load
            								generates an interrupt.</description>
            <name>CAP3I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and
        						the external match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output
            								MAT0, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR0, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output
            								MAT1, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR1, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of output
            								MAT2, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR2, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output
            								MAT3, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR3, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of
            								External Match 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT0 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT0 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of
            								External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT1 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT1 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of
            								External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT2 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT2 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of
            								External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT3 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT3 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter
        						mode, and in Counter mode selects the signal and edge(s) for
        						counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode This field selects which rising PCLK
            								edges can increment Timer's Prescale Counter (PC), or clear PC and
            								increment Timer Counter (TC). Timer Mode: the TC is incremented when
            								the Prescale Counter matches the Prescale Register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode. Incremented every rising PCLK
                										edge.</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode rising edge. TC is incremented on
                										rising edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge. TC is incremented on
                										falling edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge. TC is incremented on both
                										edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_DUAL_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select When bits 1:0 in this register are not
            								00, these bits select which CAP pin is sampled for clocking. Note:
            								If Counter mode is selected for a particular CAPn input in the CTCR,
            								the 3 bits for that input in the Capture Control Register (CCR) must
            								be programmed as 000. However, capture and/or interrupt can be
            								selected for the other 3 CAPn inputs in the same
            								timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0. CAPn.0 for TIMERn</description>
                <name>CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1. CAPn.1 for TIMERn</description>
                <name>CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2. CAPn.2 for TIMERn</description>
                <name>CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 3. CAPn.3 for TIMERn</description>
                <name>CHANNEL_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CINSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the
            								prescaler when the capture-edge event specified in bits 7:5
            								occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which
            								capture input edge will cause the timer and prescaler to be cleared.
            								These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and
            								0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Rising Edge. Rising edge of the signal on
                										capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_RISING_EDG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Falling Edge. Falling edge of the signal
                										on capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_FALLING_ED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Rising Edge. Rising edge of the signal on
                										capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_RISING_EDG</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Falling Edge. Falling edge of the signal
                										on capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Rising Edge. Rising edge of the signal on
                										capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_RISING_EDG</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Falling Edge. Falling edge of the signal
                										on capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_FALLING_ED</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external
        						match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT0 is controlled by
                										EM0.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT01 is controlled by
                										EM1.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT2 is controlled by
                										EM2.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3. Note: It is recommended to
            								use match channel 3 to set the PWM cycle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT3 is controlled by
                										EM3.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT132Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40010000</baseAddress>
    <description>Group GPIO input interrupt 0</description>
    <groupName>GINT0</groupName>
    <interrupts>
      <interrupt>
        <name>GINT0</name>
        <value>0x4</value>
      </interrupt>
    </interrupts>
    <name>GINT0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO grouped interrupt control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt status. This bit is cleared by writing a
            								one to it. Writing zero has no effect.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No request. No interrupt request is
                										pending.</description>
                <name>NO_REQUEST</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Request active. Interrupt request is
                										active.</description>
                <name>REQUEST_ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Combine enabled inputs for group interrupt</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Or. OR functionality: A grouped interrupt is
                										generated when any one of the enabled inputs is active
                										(based on its programmed polarity).</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>And. AND functionality: An interrupt is generated
                										when all enabled bits are active (based on their programmed
                										polarity).</description>
                <name>AND</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt trigger</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge-triggered.</description>
                <name>EDGE_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level-triggered.</description>
                <name>LEVEL_TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40014000</baseAddress>
    <derivedFrom>GINT0</derivedFrom>
    <description>Group GPIO input interrupt 1</description>
    <groupName>GINT0</groupName>
    <interrupts>
      <interrupt>
        <name>GINT1</name>
        <value>0x20</value>
      </interrupt>
    </interrupts>
    <name>GINT1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO grouped interrupt control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt status. This bit is cleared by writing a
            								one to it. Writing zero has no effect.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No request. No interrupt request is
                										pending.</description>
                <name>NO_REQUEST</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Request active. Interrupt request is
                										active.</description>
                <name>REQUEST_ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Combine enabled inputs for group interrupt</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Or. OR functionality: A grouped interrupt is
                										generated when any one of the enabled inputs is active
                										(based on its programmed polarity).</description>
                <name>OR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>And. AND functionality: An interrupt is generated
                										when all enabled bits are active (based on their programmed
                										polarity).</description>
                <name>AND</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Group interrupt trigger</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Edge-triggered.</description>
                <name>EDGE_TRIGGERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level-triggered.</description>
                <name>LEVEL_TRIGGERED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TRIG</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO grouped interrupt port 0 polarity register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Configure pin polarity of port m pins for group interrupt.
            								Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active
            								LOW. If the level on this pin is LOW, the pin contributes to the
            								group interrupt. 1 = the pin is active HIGH. If the level on this
            								pin is HIGH, the pin contributes to the group
            								interrupt.</description>
            <name>POL</name>
          </field>
        </fields>
        <name>PORT_POL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>GPIO grouped interrupt port 0 enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable port 0 pin for group interrupt. Bit n corresponds to
            								pin Pm_n of port m. 0 = the port 0 pin is disabled and does not
            								contribute to the grouped interrupt. 1 = the port 0 pin is enabled
            								and contributes to the grouped interrupt.</description>
            <name>ENA</name>
          </field>
        </fields>
        <name>PORT_ENA2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40018000</baseAddress>
    <description>Pin interrupt and pattern match engine</description>
    <groupName>PINT</groupName>
    <interrupts>
      <interrupt>
        <name>PIN_INT0</name>
        <value>0x5</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT1</name>
        <value>0x6</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT2</name>
        <value>0x7</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT3</name>
        <value>0x8</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT4</name>
        <value>0x21</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT5</name>
        <value>0x22</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT6</name>
        <value>0x23</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PIN_INT7</name>
        <value>0x24</value>
      </interrupt>
    </interrupts>
    <name>PINT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Pin Interrupt Mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n
            								configures the pin interrupt selected in PINTSELn. 0 = Edge
            								sensitive 1 = Level sensitive</description>
            <name>PMODE</name>
          </field>
        </fields>
        <name>ISEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Pin interrupt level or rising edge interrupt enable
        						register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin
            								interrupt. Bit n configures the pin interrupt selected in PINTSELn.
            								0 = Disable rising edge or level interrupt. 1 = Enable rising edge
            								or level interrupt.</description>
            <name>ENRL</name>
          </field>
        </fields>
        <name>IENR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Pin interrupt level or rising edge interrupt set
        						register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus
            								enabling interrupts. Bit n sets bit n in the IENR register. 0 = No
            								operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL</name>
          </field>
        </fields>
        <name>SIENR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Pin interrupt level (rising edge interrupt) clear
        						register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus
            								disabling the interrupts. Bit n clears bit n in the IENR register. 0
            								= No operation. 1 = Disable rising edge or level
            								interrupt.</description>
            <name>CENRL</name>
          </field>
        </fields>
        <name>CIENR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin interrupt active level or falling edge interrupt enable
        						register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Enables the falling edge or configures the active level
            								interrupt for each pin interrupt. Bit n configures the pin interrupt
            								selected in PINTSELn. 0 = Disable falling edge interrupt or set
            								active interrupt level LOW. 1 = Enable falling edge interrupt
            								enabled or set active interrupt level HIGH.</description>
            <name>ENAF</name>
          </field>
        </fields>
        <name>IENF</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Pin interrupt active level or falling edge interrupt set
        						register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus
            								enabling interrupts. Bit n sets bit n in the IENF register. 0 = No
            								operation. 1 = Select HIGH-active interrupt or enable falling edge
            								interrupt.</description>
            <name>SETENAF</name>
          </field>
        </fields>
        <name>SIENF</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Pin interrupt active level or falling edge interrupt clear
        						register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus
            								disabling interrupts. Bit n clears bit n in the IENF register. 0 =
            								No operation. 1 = LOW-active interrupt selected or falling edge
            								interrupt disabled.</description>
            <name>CENAF</name>
          </field>
        </fields>
        <name>CIENF</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Pin interrupt rising edge register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the
            								pin selected in PINTSELn. Read 0: No rising edge has been detected
            								on this pin since Reset or the last time a one was written to this
            								bit. Write 0: no operation. Read 1: a rising edge has been detected
            								since Reset or the last time a one was written to this bit. Write 1:
            								clear rising edge detection for this pin.</description>
            <name>RDET</name>
          </field>
        </fields>
        <name>RISE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Pin interrupt falling edge register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the
            								pin selected in PINTSELn. Read 0: No falling edge has been detected
            								on this pin since Reset or the last time a one was written to this
            								bit. Write 0: no operation. Read 1: a falling edge has been detected
            								since Reset or the last time a one was written to this bit. Write 1:
            								clear falling edge detection for this pin.</description>
            <name>FDET</name>
          </field>
        </fields>
        <name>FALL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Pin interrupt status register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the
            								edge interrupt, or inverts the active level of the pin selected in
            								PINTSELn. Read 0: interrupt is not being requested for this
            								interrupt pin. Write 0: no operation. Read 1: interrupt is being
            								requested for this interrupt pin. Write 1 (edge-sensitive): clear
            								rising- and falling-edge detection for this pin. Write 1
            								(level-sensitive): switch the active level for this pin (in the IENF
            								register).</description>
            <name>PSTAT</name>
          </field>
        </fields>
        <name>IST</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Pattern match interrupt control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies whether the 8 pin interrupts are controlled by
            								the pin interrupt function or by the pattern match
            								function.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pin interrupt. Interrupts are driven in response to
                										the standard pin interrupt function.</description>
                <name>PIN_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pattern match. Interrupts are driven in response to
                										pattern matches.</description>
                <name>PATTERN_MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL_PMATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the RXEV output to the CPU and/or to a GPIO output
            								when the specified boolean expression evaluates to
            								true.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. RXEV output to the CPU is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. RXEV output to the CPU is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA_RXEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This field displays the current state of pattern matches. A
            								1 in any bit of this field indicates that the corresponding product
            								term is matched by the current state of the appropriate
            								inputs.</description>
            <name>PMAT</name>
          </field>
        </fields>
        <name>PMCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Pattern match interrupt bit-slice source register</description>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 0</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 0.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 0.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 0.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 0.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 0.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 0.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 0.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 0.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 1.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 1.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 1.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 1.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 1.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 1.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 1.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 1.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 2</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 2.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 2.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 2.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 2.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 2.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 2.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 2.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 2.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 3</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 3.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 3.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 3.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 3.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 3.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 3.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 3.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 3.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 4</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 4.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 4.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 4.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 4.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 4.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 4.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 4.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 4.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 5</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 5.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 5.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 5.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 5.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 5.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 5.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 5.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 5.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 6</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 6.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 6.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 6.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 6.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 6.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 6.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 6.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 6.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 7</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects the pin selected in the PINTSEL0
                										register as the source to bit slice 7.</description>
                <name>INPUT_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects the pin selected in the PINTSEL1
                										register as the source to bit slice 7.</description>
                <name>INPUT_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects the pin selected in the PINTSEL2
                										register as the source to bit slice 7.</description>
                <name>INPUT_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects the pin selected in the PINTSEL3
                										register as the source to bit slice 7.</description>
                <name>INPUT_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects the pin selected in the PINTSEL4
                										register as the source to bit slice 7.</description>
                <name>INPUT_4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects the pin selected in the PINTSEL5
                										register as the source to bit slice 7.</description>
                <name>INPUT_5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects the pin selected in the PINTSEL6
                										register as the source to bit slice 7.</description>
                <name>INPUT_6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects the pin selected in the PINTSEL7
                										register as the source to bit slice 7.</description>
                <name>INPUT_7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC7</name>
          </field>
        </fields>
        <name>PMSRC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Pattern match interrupt bit slice configuration
        						register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether slice 0 is an endpoint.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Slice 0 is not an
                										endpoint.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>endpoint. Slice 0 is the endpoint of a product term
                										(minterm). Pin interrupt 0 in the NVIC is raised if the
                										minterm evaluates as true.</description>
                <name>ENDPOINT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROD_ENDPTS0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether slice 1 is an endpoint.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Slice 1 is not an
                										endpoint.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>endpoint. Slice 1 is the endpoint of a product term
                										(minterm). Pin interrupt 1 in the NVIC is raised if the
                										minterm evaluates as true.</description>
                <name>ENDPOINT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROD_ENDPTS1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether slice 2 is an endpoint.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Slice 2 is not an
                										endpoint.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>endpoint. Slice 2 is the endpoint of a product term
                										(minterm). Pin interrupt 2 in the NVIC is raised if the
                										minterm evaluates as true.</description>
                <name>ENDPOINT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROD_ENDPTS2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether slice 3 is an endpoint.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Slice 3 is not an
                										endpoint.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>endpoint. Slice 3 is the endpoint of a product term
                										(minterm). Pin interrupt 3 in the NVIC is raised if the
                										minterm evaluates as true.</description>
                <name>ENDPOINT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROD_ENDPTS3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether slice 4 is an endpoint.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Slice 4 is not an
                										endpoint.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>endpoint. Slice 4 is the endpoint of a product term
                										(minterm). Pin interrupt 4 in the NVIC is raised if the
                										minterm evaluates as true.</description>
                <name>ENDPOINT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROD_ENDPTS4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether slice 5 is an endpoint.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Slice 5 is not an
                										endpoint.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>endpoint. Slice 5 is the endpoint of a product term
                										(minterm). Pin interrupt 5 in the NVIC is raised if the
                										minterm evaluates as true.</description>
                <name>ENDPOINT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROD_ENDPTS5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether slice 6 is an endpoint.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Slice 6 is not an
                										endpoint.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>endpoint. Slice 6 is the endpoint of a product term
                										(minterm). Pin interrupt 6 in the NVIC is raised if the
                										minterm evaluates as true.</description>
                <name>ENDPOINT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PROD_ENDPTS6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								4.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								5.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								6.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match contribution condition for bit slice
            								7.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant HIGH. This bit slice always contributes to
                										a product term match.</description>
                <name>CONSTANT_HIGH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising edge. Match occurs if a rising edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky falling edge. Match occurs if a falling edge
                										on the specified input has occurred since the last time the
                										edge detection for this bit slice was cleared. This bit is
                										only cleared when the PMCFG or the PMSRC registers are
                										written to.</description>
                <name>STICKY_FALLING_EDGE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sticky rising or falling edge. Match occurs if
                										either a rising or falling edge on the specified input has
                										occurred since the last time the edge detection for this bit
                										slice was cleared. This bit is only cleared when the PMCFG
                										or the PMSRC registers are written to.</description>
                <name>STICKY_RISING_OR_FAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when
                										there is a high level on the input specified for this bit
                										slice in the PMSRC register.</description>
                <name>HIGH_LEVEL</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level
                										on the specified input.</description>
                <name>LOW_LEVEL</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a
                										match (should be used to disable any unused bit
                										slices).</description>
                <name>CONSTANT_0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Non-sticky rising or falling edge. Match
                										occurs on an event - i.e. when either a rising or falling
                										edge is first detected on the specified input (this is a
                										non-sticky version of value 0x3) . This bit is cleared after
                										one clock cycle.</description>
                <name>EVENT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG7</name>
          </field>
        </fields>
        <name>PMCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4001C000</baseAddress>
    <description>I/O pin configuration </description>
    <groupName>IOCON</groupName>
    <interrupts></interrupts>
    <name>IOCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_0 to
        						PIO0_15.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_16 to
        						PIO0_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_16</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x195</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_16 to
        						PIO0_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_17</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x195</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_18 to
        						PIO0_22.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_18</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_18 to
        						PIO0_22.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_19</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_18 to
        						PIO0_22.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_20</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_18 to
        						PIO0_22.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_21</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_18 to
        						PIO0_22.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_22</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_23 to PIO0_28. These pins
        						support I2C with true open-drain, drive and filtering for modes up to
        						Fast-mode Plus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls slew rate of I2C pad.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2C mode.</description>
                <name>I2C_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>GPIO mode.</description>
                <name>GPIO_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CSLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the current sink capability of the
            								pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low drive. Output drive sink is 4 mA. This is
                										sufficient for standard and fast mode I2C.</description>
                <name>LOW_DRIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High drive. Output drive sink is 20 mA. This is
                										needed for Fast Mode Plus I 2C. Refer to the appropriate
                										specific device data sheet for details.</description>
                <name>HIGH_DRIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CDRIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configures I2C features for standard mode, fast mode, and
            								Fast Mode Plus operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. I2C 50 ns glitch filter
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. I2C 50 ns glitch filter
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CFILTER</name>
          </field>
        </fields>
        <name>PIO0_23</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1A0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_23 to PIO0_28. These pins
        						support I2C with true open-drain, drive and filtering for modes up to
        						Fast-mode Plus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls slew rate of I2C pad.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2C mode.</description>
                <name>I2C_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>GPIO mode.</description>
                <name>GPIO_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CSLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the current sink capability of the
            								pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low drive. Output drive sink is 4 mA. This is
                										sufficient for standard and fast mode I2C.</description>
                <name>LOW_DRIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High drive. Output drive sink is 20 mA. This is
                										needed for Fast Mode Plus I 2C. Refer to the appropriate
                										specific device data sheet for details.</description>
                <name>HIGH_DRIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CDRIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configures I2C features for standard mode, fast mode, and
            								Fast Mode Plus operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. I2C 50 ns glitch filter
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. I2C 50 ns glitch filter
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CFILTER</name>
          </field>
        </fields>
        <name>PIO0_24</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1A0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x64</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_23 to PIO0_28. These pins
        						support I2C with true open-drain, drive and filtering for modes up to
        						Fast-mode Plus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls slew rate of I2C pad.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2C mode.</description>
                <name>I2C_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>GPIO mode.</description>
                <name>GPIO_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CSLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the current sink capability of the
            								pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low drive. Output drive sink is 4 mA. This is
                										sufficient for standard and fast mode I2C.</description>
                <name>LOW_DRIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High drive. Output drive sink is 20 mA. This is
                										needed for Fast Mode Plus I 2C. Refer to the appropriate
                										specific device data sheet for details.</description>
                <name>HIGH_DRIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CDRIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configures I2C features for standard mode, fast mode, and
            								Fast Mode Plus operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. I2C 50 ns glitch filter
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. I2C 50 ns glitch filter
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CFILTER</name>
          </field>
        </fields>
        <name>PIO0_25</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1A0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_23 to PIO0_28. These pins
        						support I2C with true open-drain, drive and filtering for modes up to
        						Fast-mode Plus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls slew rate of I2C pad.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2C mode.</description>
                <name>I2C_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>GPIO mode.</description>
                <name>GPIO_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CSLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the current sink capability of the
            								pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low drive. Output drive sink is 4 mA. This is
                										sufficient for standard and fast mode I2C.</description>
                <name>LOW_DRIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High drive. Output drive sink is 20 mA. This is
                										needed for Fast Mode Plus I 2C. Refer to the appropriate
                										specific device data sheet for details.</description>
                <name>HIGH_DRIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CDRIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configures I2C features for standard mode, fast mode, and
            								Fast Mode Plus operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. I2C 50 ns glitch filter
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. I2C 50 ns glitch filter
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CFILTER</name>
          </field>
        </fields>
        <name>PIO0_26</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1A0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_23 to PIO0_28. These pins
        						support I2C with true open-drain, drive and filtering for modes up to
        						Fast-mode Plus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls slew rate of I2C pad.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2C mode.</description>
                <name>I2C_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>GPIO mode.</description>
                <name>GPIO_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CSLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the current sink capability of the
            								pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low drive. Output drive sink is 4 mA. This is
                										sufficient for standard and fast mode I2C.</description>
                <name>LOW_DRIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High drive. Output drive sink is 20 mA. This is
                										needed for Fast Mode Plus I 2C. Refer to the appropriate
                										specific device data sheet for details.</description>
                <name>HIGH_DRIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CDRIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configures I2C features for standard mode, fast mode, and
            								Fast Mode Plus operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. I2C 50 ns glitch filter
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. I2C 50 ns glitch filter
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CFILTER</name>
          </field>
        </fields>
        <name>PIO0_27</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1A0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_23 to PIO0_28. These pins
        						support I2C with true open-drain, drive and filtering for modes up to
        						Fast-mode Plus.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls slew rate of I2C pad.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2C mode.</description>
                <name>I2C_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>GPIO mode.</description>
                <name>GPIO_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CSLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the current sink capability of the
            								pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low drive. Output drive sink is 4 mA. This is
                										sufficient for standard and fast mode I2C.</description>
                <name>LOW_DRIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High drive. Output drive sink is 20 mA. This is
                										needed for Fast Mode Plus I 2C. Refer to the appropriate
                										specific device data sheet for details.</description>
                <name>HIGH_DRIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CDRIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configures I2C features for standard mode, fast mode, and
            								Fast Mode Plus operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. I2C 50 ns glitch filter
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. I2C 50 ns glitch filter
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CFILTER</name>
          </field>
        </fields>
        <name>PIO0_28</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1A0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_29 to PIO0_31. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_29</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_29 to PIO0_31. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_30</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C</addressOffset>
        <description>Digital I/O control for port 0 pins PIO0_29 to PIO0_31. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO0_31</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x88</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>Digital I/O control for port 1 pins PIO0_0 to PIO0_8. These pins
        						include an ADC input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA8</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAC</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB0</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB4</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB8</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBC</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC0</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_16</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC4</addressOffset>
        <description>Digital I/O control for port 1 pins PIO1_9 to
        						PIO1_17.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects pin function.</description>
            <name>FUNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor
            								control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. Inactive (no pull-down/pull-up resistor
                										enabled).</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down. Pull-down resistor
                										enabled.</description>
                <name>PULL_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up. Pull-up resistor enabled.</description>
                <name>PULL_UP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater. Repeater mode.</description>
                <name>REPEATER</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Input function is not
                										inverted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Input is function inverted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select Analog/Digital mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Analog mode.</description>
                <name>ANALOG_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital mode.</description>
                <name>DIGITAL_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIGIMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls input glitch filter.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter enabled. Noise pulses below approximately 10
                										ns are filtered out</description>
                <name>FILTER_ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Filter disabled. No input filtering is
                										done</description>
                <name>FILTER_DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FILTEROFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driver slew rate.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode, output slew rate control is enabled.
                										More outputs can be switched simultaneously.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast mode, slew rate control is disabled. Refer to
                										the appropriate specific device data sheet for
                										details.</description>
                <name>FAST_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal. Normal push-pull output</description>
                <name>NORMAL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain. Simulated open-drain output (high drive
                										disabled)</description>
                <name>OPEN_DRAIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <name>PIO1_17</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x190</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40020000</baseAddress>
    <description>Micro-tick timer</description>
    <groupName>UTICK</groupName>
    <interrupts>
      <interrupt>
        <name>UTICK</name>
        <value>0x9</value>
      </interrupt>
    </interrupts>
    <name>UTICK</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1F</bitWidth>
            <description>Tick interval value. The delay will be equal to DELAYVAL +
            								1 periods of the timer clock. The minimum usable value is 1, for a
            								delay of 2 timer clocks. A value of 0 stops the timer.</description>
            <name>DELAYVAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Repeat delay. 0 = One-time delay. 1 = Delay repeats
            								continuously.</description>
            <name>REPEAT</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag. 0 = No interrupt is pending. 1 = An
            								interrupt is pending. A write of any value to this register clears
            								this flag.</description>
            <name>INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active flag. 0 = The Micro-Tick Timer is stopped. 1 = The
            								Micro-Tick Timer is currently active.</description>
            <name>ACTIVE</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4002C000</baseAddress>
    <description>Advanced System configuration </description>
    <groupName>ADVSYSCON</groupName>
    <interrupts>
      <interrupt>
        <name>BOD</name>
        <value>0x1</value>
      </interrupt>
    </interrupts>
    <name>ADVSYSCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Brown-Out Detect control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD reset level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 0: 1.5 V</description>
                <name>LEVEL_0_1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 1: 1.85 V</description>
                <name>LEVEL_1_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2: 2.0 V</description>
                <name>LEVEL_2_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3: 2.3 V</description>
                <name>LEVEL_3_2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTLEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD interrupt level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 0: 2.05 V</description>
                <name>LEVEL_0_2</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 1: 2.45 V</description>
                <name>LEVEL_1_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2: 2.75 V</description>
                <name>LEVEL_2_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3: 3.05 V</description>
                <name>LEVEL_3_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODINTVAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD reset enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable reset function.</description>
                <name>DISABLE_RESET_FUNCTI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable reset function.</description>
                <name>ENABLE_RESET_FUNCTIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTENA</name>
          </field>
        </fields>
        <name>BODCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40038000</baseAddress>
    <description>Windowed Watchdog Timer</description>
    <groupName>WWDT</groupName>
    <interrupts>
      <interrupt>
        <name>WDT</name>
        <value>0x0</value>
      </interrupt>
    </interrupts>
    <name>WWDT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Watchdog mode register. This register contains the basic mode and
        						status of the Watchdog Timer.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog enable bit. Once this bit is set to one and a
            								watchdog feed is performed, the watchdog timer will run
            								permanently.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stop. The watchdog timer is stopped.</description>
                <name>STOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Run. The watchdog timer is running.</description>
                <name>RUN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog reset enable bit. Once this bit has been written
            								with a 1 it cannot be re-written with a 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Interrupt. A watchdog time-out will not cause a
                										chip reset.</description>
                <name>INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset. A watchdog time-out will cause a chip
                										reset.</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDRESET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog time-out flag. Set when the watchdog timer times
            								out, by a feed error, or by events associated with WDPROTECT.
            								Cleared by software. Causes a chip reset if WDRESET =
            								1.</description>
            <name>WDTOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Warning interrupt flag. Set when the timer reaches the
            								value in WDWARNINT. Cleared by software.</description>
            <name>WDINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog update mode. This bit can be set once by software
            								and is only cleared by a reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flexible. The watchdog time-out value (TC) can be
                										changed at any time.</description>
                <name>FLEXIBLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Threshold. The watchdog time-out value (TC) can be
                										changed only after the counter is below the value of
                										WDWARNINT and WDWINDOW.</description>
                <name>THRESHOLD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDPROTECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Once this bit is set to one and a watchdog feed is
            								performed, disabling or powering down the watchdog oscillator is
            								prevented by hardware. This bit can be set once by software and is
            								only cleared by any reset.</description>
            <name>LOCK</name>
          </field>
        </fields>
        <name>MOD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Watchdog timer constant register. This 24-bit register determines
        						the time-out value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Watchdog time-out value.</description>
            <name>COUNT</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Watchdog feed sequence register. Writing 0xAA followed by 0x55 to
        						this register reloads the Watchdog timer with the value contained in
        						WDTC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Feed value should be 0xAA followed by 0x55.</description>
            <name>FEED</name>
          </field>
        </fields>
        <name>FEED</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Watchdog timer value register. This 24-bit register reads out the
        						current value of the Watchdog timer.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Counter timer value.</description>
            <name>COUNT</name>
          </field>
        </fields>
        <name>TV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Watchdog Warning Interrupt compare value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Watchdog warning interrupt compare value.</description>
            <name>WARNINT</name>
          </field>
        </fields>
        <name>WARNINT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Watchdog Window compare value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Watchdog window value.</description>
            <name>WINDOW</name>
          </field>
        </fields>
        <name>WINDOW</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4003C000</baseAddress>
    <description>Real-Time Clock</description>
    <groupName>RTC</groupName>
    <interrupts>
      <interrupt>
        <name>RTC</name>
        <value>0x1D</value>
      </interrupt>
    </interrupts>
    <name>RTC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>RTC control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not in reset. The RTC is not held in reset. This
                										bit must be cleared prior to configuring or initiating any
                										operation of the RTC.</description>
                <name>NOT_IN_RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>In reset. The RTC is held in reset. All register
                										bits within the RTC will be forced to their reset value
                										except the OFD bit. This bit must be cleared before writing
                										to any register in the RTC - including writes to set any of
                										the other bits within this register. Do not attempt to write
                										to any bits of this register at the same time that the reset
                										bit is being cleared.</description>
                <name>IN_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWRESET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Oscillator fail detect status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Run. The RTC oscillator is running properly.
                										Writing a 0 has no effect.</description>
                <name>RUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fail. RTC oscillator fail detected. Clear this flag
                										after the following power-up. Writing a 1 clears this
                										bit.</description>
                <name>FAIL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OFD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 Hz timer alarm flag status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No match. No match has occurred on the 1 Hz RTC
                										timer. Writing a 0 has no effect.</description>
                <name>NO_MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. A match condition has occurred on the 1 Hz
                										RTC timer. This flag generates an RTC alarm interrupt
                										request RTC_ALARM which can also wake up the part from any
                										low power mode. Writing a 1 clears this bit.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ALARM1HZ</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 kHz timer wake-up flag status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Run. The RTC 1 kHz timer is running. Writing a 0
                										has no effect.</description>
                <name>RUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Time-out. The 1 kHz high-resolution/wake-up timer
                										has timed out. This flag generates an RTC wake-up interrupt
                										request RTC-WAKE which can also wake up the part from any
                										low power mode. Writing a 1 clears this bit.</description>
                <name>TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKE1KHZ</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 Hz timer alarm enable for Deep
            								power-down.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. A match on the 1 Hz RTC timer will not
                										bring the part out of Deep power-down mode.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. A match on the 1 Hz RTC timer bring the
                										part out of Deep power-down mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ALARMDPD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 kHz timer wake-up enable for Deep
            								power-down.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. A match on the 1 kHz RTC timer will not
                										bring the part out of Deep power-down mode.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. A match on the 1 kHz RTC timer bring the
                										part out of Deep power-down mode.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKEDPD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC 1 kHz clock enable. This bit can be set to 0 to
            								conserve power if the 1 kHz timer is not used. This bit has no
            								effect when the RTC is disabled (bit 7 of this register is
            								0).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. A match on the 1 kHz RTC timer will not
                										bring the part out of Deep power-down mode.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. The 1 kHz RTC timer is
                										enabled.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTC1KHZ_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. The RTC 1 Hz and 1 kHz clocks are shut
                										down and the RTC operation is disabled. This bit should be 0
                										when writing to load a value in the RTC counter
                										register.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. The 1 Hz RTC clock is running and RTC
                										operation is enabled. This bit must be set to initiate
                										operation of the RTC. The first clock to the RTC counter
                										occurs 1 s after this bit is set. To also enable the
                										high-resolution, 1 kHz clock, set bit 6 in this
                										register.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RTC_EN</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>RTC match register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Contains the match value against which the 1 Hz RTC timer
            								will be compared to generate set the alarm flag RTC_ALARM and
            								generate an alarm interrupt/wake-up if enabled.</description>
            <name>MATVAL</name>
          </field>
        </fields>
        <name>MATCH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>RTC counter register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>A read reflects the current value of the main, 1 Hz RTC
            								timer. A write loads a new initial value into the timer. The RTC
            								counter will count up continuously at a 1 Hz rate once the RTC
            								Software Reset is removed (by clearing bit 0 of the CTRL register).
            								Only write to this register when the RTC_EN bit in the RTC CTRL
            								Register is 0. The counter increments one second after the RTC_EN
            								bit is set.</description>
            <name>VAL</name>
          </field>
        </fields>
        <name>COUNT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>RTC high-resolution/wake-up timer control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A read reflects the current value of the
            								high-resolution/wake-up timer. A write pre-loads a start count value
            								into the wake-up timer and initializes a count-down sequence. Do not
            								write to this register while counting is in progress.</description>
            <name>VAL</name>
          </field>
        </fields>
        <name>WAKE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40050000</baseAddress>
    <description>Input multiplexing</description>
    <groupName>INPUTMUX</groupName>
    <interrupts></interrupts>
    <name>INPUTMUX</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x160</addressOffset>
        <description>Clock selection for frequency measurement function reference
        						clock</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Clock source number (decimal value) for frequency measure
            								function target clock: 0 = System oscillator (MAIN_OSC) 1 = IRC
            								oscillator 2 = Watchdog oscillator 3 = 32 kHz RTC oscillator 4 =
            								Main clock (see Section 4.5.21) 5 = PIO0_4 6 = PIO0_20 7 = PIO0_24 8
            								= PIO1_4</description>
            <name>CLKIN</name>
          </field>
        </fields>
        <name>FREQMEAS_REF</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x164</addressOffset>
        <description>Clock selection for frequency measurement function target
        						clock</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Clock source number (decimal value) for frequency measure
            								function target clock: 0 = System oscillator (MAIN_OSC) 1 = IRC
            								oscillator 2 = Watchdog oscillator 3 = 32 kHz RTC oscillator 4 =
            								Main clock (see Section 4.5.18) 5 = PIO0_4 6 = PIO0_20 7 = PIO0_24 8
            								= PIO1_4</description>
            <name>CLKIN</name>
          </field>
        </fields>
        <name>FREQMEAS_TARGET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC0</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC4</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC8</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCC</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD0</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD4</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD8</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDC</addressOffset>
        <description>Pin interrupt select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine
            								input. (PIO0_0 to PIO1_31 correspond to numbers 0 to
            								63).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE0</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE4</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE8</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x114</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x118</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11C</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x120</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX16</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x124</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX17</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x128</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX18</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x12C</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX19</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x130</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX20</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x134</addressOffset>
        <description>Trigger select register for DMA channel 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trigger input number (decimal value) for DMA channel n (n =
            								0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B
            								interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer 0
            								Match 0 5 = Timer 0 Match 1 6 = Timer 1 Match 0 7 = Timer 2 Match 0
            								8 = Timer 2 Match 1 9 = Timer 3 Match 0 10 = Timer 4 Match 0 11 =
            								Timer 4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin
            								interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 =
            								DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA
            								output trigger mux 3</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_ITRIG_INMUX21</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x140</addressOffset>
        <description>DMA output trigger selection to become DMA trigger 16</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>DMA trigger output number (decimal value) for DMA channel n
            								(n = 0 to 19).</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_OTRIG_INMUX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x144</addressOffset>
        <description>DMA output trigger selection to become DMA trigger 16</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>DMA trigger output number (decimal value) for DMA channel n
            								(n = 0 to 19).</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_OTRIG_INMUX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x148</addressOffset>
        <description>DMA output trigger selection to become DMA trigger 16</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>DMA trigger output number (decimal value) for DMA channel n
            								(n = 0 to 19).</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_OTRIG_INMUX2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14C</addressOffset>
        <description>DMA output trigger selection to become DMA trigger 16</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>DMA trigger output number (decimal value) for DMA channel n
            								(n = 0 to 19).</description>
            <name>INP</name>
          </field>
        </fields>
        <name>DMA_OTRIG_INMUX3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40070000</baseAddress>
    <description>Repetitive Interrupt Timer</description>
    <groupName>RIT</groupName>
    <interrupts>
      <interrupt>
        <name>RIT</name>
        <value>0x28</value>
      </interrupt>
    </interrupts>
    <name>RIT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Compare value LSB register. Holds the 32 LSBs of the compare
        						value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Compare register. Holds the 32 LSBs of the value which is
            								compared to the counter.</description>
            <name>RICOMP</name>
          </field>
        </fields>
        <name>COMPVAL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Mask LSB register. This register holds the 32 LSB s of the mask
        						value. A 1 written to any bit will force the compare to be true for the
        						corresponding bit of the counter and compare register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Mask register. This register holds the 32 LSBs of the mask
            								value. A one written to any bit overrides the result of the
            								comparison for the corresponding bit of the counter and compare
            								register (causes the comparison of the register bits to be always
            								true).</description>
            <name>RIMASK</name>
          </field>
        </fields>
        <name>MASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>This bit is set to 1 by hardware whenever the
                										counter value equals the masked compare value specified by
                										the contents of RICOMPVAL and RIMASK registers. Writing a 1
                										to this bit will clear it to 0. Writing a 0 has no
                										effect.</description>
                <name>MATCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counter value does not equal the masked compare
                										value.</description>
                <name>NOMTCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RITINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer enable clear</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The timer will be cleared to 0 whenever the counter
                										value equals the masked compare value specified by the
                										contents of COMPVAL/COMPVAL_H and MASK/MASK_H registers.
                										This will occur on the same clock that sets the interrupt
                										flag.</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The timer will not be cleared to 0.</description>
                <name>NOCLEAR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RITENCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer enable for debug</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The timer is halted when the processor is halted
                										for debugging.</description>
                <name>HALT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Debug has no effect on the timer
                										operation.</description>
                <name>DEBUG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RITENBR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer enabled. This can be overruled by a debug
                										halt if enabled in bit 2.</description>
                <name>TIMER_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer disabled.</description>
                <name>TIMER_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RITEN</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xC</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Counter LSB register. 32 LSBs of the counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>32 LSBs of the up counter. Counts continuously unless RITEN
            								bit in CTRL register is cleared or debug mode is entered (if enabled
            								by the RITNEBR bit in RICTRL). Can be loaded to any value in
            								software.</description>
            <name>RICOUNTER</name>
          </field>
        </fields>
        <name>COUNTER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Compare value MSB register. Holds the 16 MSBs of the compare
        						value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Compare value MSB register. Holds the 16 MSBs of the value
            								which is compared to the counter.</description>
            <name>RICOMP</name>
          </field>
        </fields>
        <name>COMPVAL_H</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Mask MSB register. This register holds the 16 MSBs of the mask
        						value. A 1 written to any bit will force a compare on the corresponding bit
        						of the counter and compare register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Mask register. This register holds the 16 MSBs of the mask
            								value. A one written to any bit overrides the result of the
            								comparison for the corresponding bit of the counter and compare
            								register (causes the comparison of the register bits to be always
            								true).</description>
            <name>RIMASK</name>
          </field>
        </fields>
        <name>MASK_H</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Counter MSB register. 16 MSBs of the counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>16 LSBs of the up counter. Counts continuously unless RITEN
            								bit in RICTRL register is cleared or debug mode is entered (if
            								enabled by the RITNEBR bit in RICTRL). Can be loaded to any value in
            								software.</description>
            <name>RICOUNTER</name>
          </field>
        </fields>
        <name>COUNTER_H</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40074000</baseAddress>
    <description>Multi-Rate Timer</description>
    <groupName>MRT</groupName>
    <interrupts>
      <interrupt>
        <name>MRT</name>
        <value>0xA</value>
      </interrupt>
    </interrupts>
    <name>MRT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>Module Configuration register. This register provides information
        						about this particular MRT instance, and allows choosing an overall mode for
        						the idle channel feature.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Identifies the number of channels in this
            								MRT.</description>
            <name>NOC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Identifies the number of timer bits in this
            								MRT.</description>
            <name>NOB</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the operating mode for the INUSE flags and the
            								IDLE_CH register. See Idle channel register (IDLE_CH) for
            								details.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Hardware status mode. In this mode, the INUSE(n)
                										flags for all channels are reset.</description>
                <name>HARDWARE_STATUS_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Multi-task mode.</description>
                <name>MULTI_TASK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MULTITASK</name>
          </field>
        </fields>
        <name>MODCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4</addressOffset>
        <description>Idle channel register. This register returns the number of the
        						first idle channel.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Idle channel. Reading the CHAN bits, returns the lowest
            								idle timer channel. The number is positioned such that it can be
            								used as an offset from the MRT base address in order to access the
            								registers for the allocated channel. If all timer channels are
            								running, CHAN = 0xF. See text above for more details.</description>
            <name>CHAN</name>
          </field>
        </fields>
        <name>IDLE_CH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>Global interrupt flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent
                										to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because
                										TIMER0 has reached the end of the time interval. If the
                										INTEN bit in the CONTROL0 register is also set to 1, the
                										interrupt for timer channel 0 and the global interrupt are
                										raised. Writing a 1 to this bit clears the interrupt
                										request.</description>
                <name>PENDING_INTERRUPT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GFLAG0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER1. See description of
            								channel 0.</description>
            <name>GFLAG1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER2. See description of
            								channel 0.</description>
            <name>GFLAG2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER3. See description of
            								channel 0.</description>
            <name>GFLAG3</name>
          </field>
        </fields>
        <name>IRQ_FLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>MRTn Time interval value register. This value is loaded into the
        						TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the
            								TIMERn register and the MRT channel n starts counting down from
            								IVALUE -1. If the timer is idle, writing a non-zero value to this
            								bit field starts the timer immediately. If the timer is running,
            								writing a zero to this bit field does the following: If LOAD = 1,
            								the timer stops immediately. If LOAD = 0, the timer stops at the end
            								of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE -1 is loaded
            								into the TIMERn register. This bit is write-only. Reading this bit
            								always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register
                										to the TIMERn register is processed at the end of the time
                										interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE -1 is
                										immediately loaded into the TIMERn register while TIMERn is
                										running.</description>
                <name>FORCE_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>MRTn Time interval value register. This value is loaded into the
        						TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the
            								TIMERn register and the MRT channel n starts counting down from
            								IVALUE -1. If the timer is idle, writing a non-zero value to this
            								bit field starts the timer immediately. If the timer is running,
            								writing a zero to this bit field does the following: If LOAD = 1,
            								the timer stops immediately. If LOAD = 0, the timer stops at the end
            								of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE -1 is loaded
            								into the TIMERn register. This bit is write-only. Reading this bit
            								always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register
                										to the TIMERn register is processed at the end of the time
                										interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE -1 is
                										immediately loaded into the TIMERn register while TIMERn is
                										running.</description>
                <name>FORCE_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>MRTn Time interval value register. This value is loaded into the
        						TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the
            								TIMERn register and the MRT channel n starts counting down from
            								IVALUE -1. If the timer is idle, writing a non-zero value to this
            								bit field starts the timer immediately. If the timer is running,
            								writing a zero to this bit field does the following: If LOAD = 1,
            								the timer stops immediately. If LOAD = 0, the timer stops at the end
            								of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE -1 is loaded
            								into the TIMERn register. This bit is write-only. Reading this bit
            								always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register
                										to the TIMERn register is processed at the end of the time
                										interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE -1 is
                										immediately loaded into the TIMERn register while TIMERn is
                										running.</description>
                <name>FORCE_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>MRTn Time interval value register. This value is loaded into the
        						TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the
            								TIMERn register and the MRT channel n starts counting down from
            								IVALUE -1. If the timer is idle, writing a non-zero value to this
            								bit field starts the timer immediately. If the timer is running,
            								writing a zero to this bit field does the following: If LOAD = 1,
            								the timer stops immediately. If LOAD = 0, the timer stops at the end
            								of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE -1 is loaded
            								into the TIMERn register. This bit is write-only. Reading this bit
            								always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register
                										to the TIMERn register is processed at the end of the time
                										interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE -1 is
                										immediately loaded into the TIMERn register while TIMERn is
                										running.</description>
                <name>FORCE_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>MRTn Timer register. This register reads the value of the
        						down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The
            								initial value of the TIMERn register is loaded as IVALUE - 1 from
            								the INTVALn register either at the end of the time interval or
            								immediately in the following cases: INTVALn register is updated in
            								the idle state. INTVALn register is updated with LOAD = 1. When the
            								timer is in idle state, reading this bit fields returns -1 (0x00FF
            								FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>MRTn Timer register. This register reads the value of the
        						down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The
            								initial value of the TIMERn register is loaded as IVALUE - 1 from
            								the INTVALn register either at the end of the time interval or
            								immediately in the following cases: INTVALn register is updated in
            								the idle state. INTVALn register is updated with LOAD = 1. When the
            								timer is in idle state, reading this bit fields returns -1 (0x00FF
            								FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>MRTn Timer register. This register reads the value of the
        						down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The
            								initial value of the TIMERn register is loaded as IVALUE - 1 from
            								the INTVALn register either at the end of the time interval or
            								immediately in the following cases: INTVALn register is updated in
            								the idle state. INTVALn register is updated with LOAD = 1. When the
            								timer is in idle state, reading this bit fields returns -1 (0x00FF
            								FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>MRTn Timer register. This register reads the value of the
        						down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The
            								initial value of the TIMERn register is loaded as IVALUE - 1 from
            								the INTVALn register either at the end of the time interval or
            								immediately in the following cases: INTVALn register is updated in
            								the idle state. INTVALn register is updated with LOAD = 1. When the
            								timer is in idle state, reading this bit fields returns -1 (0x00FF
            								FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>MRTn Control register. This register controls the MRTn
        						modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot stall mode.</description>
                <name>ONE_SHOT_STALL_MODE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>MRTn Control register. This register controls the MRTn
        						modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot stall mode.</description>
                <name>ONE_SHOT_STALL_MODE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>MRTn Control register. This register controls the MRTn
        						modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot stall mode.</description>
                <name>ONE_SHOT_STALL_MODE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>MRTn Control register. This register controls the MRTn
        						modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TIMERn interrupt is enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot stall mode.</description>
                <name>ONE_SHOT_STALL_MODE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>MRTn Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent
                										to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because
                										TIMERn has reached the end of the time interval. If the
                										INTEN bit in the CONTROLn is also set to 1, the interrupt
                										for timer channel n and the global interrupt are raised.
                										Writing a 1 to this bit clears the interrupt
                										request.</description>
                <name>PENDING_INTERRUPT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is
            								read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel In Use flag. Operating details depend on the
            								MULTITASK bit in the MODCFG register, and affects the use of
            								IDLE_CH. </description>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is not in use.</description>
                <name>NO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is in use.</description>
                <name>YES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INUSE</name>
          </field>
        </fields>
        <name>STAT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>MRTn Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent
                										to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because
                										TIMERn has reached the end of the time interval. If the
                										INTEN bit in the CONTROLn is also set to 1, the interrupt
                										for timer channel n and the global interrupt are raised.
                										Writing a 1 to this bit clears the interrupt
                										request.</description>
                <name>PENDING_INTERRUPT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is
            								read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel In Use flag. Operating details depend on the
            								MULTITASK bit in the MODCFG register, and affects the use of
            								IDLE_CH. </description>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is not in use.</description>
                <name>NO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is in use.</description>
                <name>YES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INUSE</name>
          </field>
        </fields>
        <name>STAT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>MRTn Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent
                										to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because
                										TIMERn has reached the end of the time interval. If the
                										INTEN bit in the CONTROLn is also set to 1, the interrupt
                										for timer channel n and the global interrupt are raised.
                										Writing a 1 to this bit clears the interrupt
                										request.</description>
                <name>PENDING_INTERRUPT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is
            								read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel In Use flag. Operating details depend on the
            								MULTITASK bit in the MODCFG register, and affects the use of
            								IDLE_CH. </description>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is not in use.</description>
                <name>NO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is in use.</description>
                <name>YES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INUSE</name>
          </field>
        </fields>
        <name>STAT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>MRTn Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent
                										to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because
                										TIMERn has reached the end of the time interval. If the
                										INTEN bit in the CONTROLn is also set to 1, the interrupt
                										for timer channel n and the global interrupt are raised.
                										Writing a 1 to this bit clears the interrupt
                										request.</description>
                <name>PENDING_INTERRUPT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is
            								read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel In Use flag. Operating details depend on the
            								MULTITASK bit in the MODCFG register, and affects the use of
            								IDLE_CH. </description>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is not in use.</description>
                <name>NO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>This channel is in use.</description>
                <name>YES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INUSE</name>
          </field>
        </fields>
        <name>STAT3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40080000</baseAddress>
    <description>Asynchronous system configuration</description>
    <groupName>ASYNCSYSCON</groupName>
    <interrupts></interrupts>
    <name>ASYNCSYSCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Async peripheral reset control</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART0 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>USART0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART1 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>USART1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART2 reset control.0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>USART2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART3 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>USART3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C0 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>I2C0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C1 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>I2C1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C2 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>I2C2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>SPI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>SPI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 0 reset control. 0 = Clear reset to this function. 1
            								= Assert reset to this function.</description>
            <name>TIMER0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer 1 reset control. 0 = Clear reset to this function. 1
            								= Assert reset to this function.</description>
            <name>TIMER1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FRG reset control. 0 = Clear reset to this function. 1 =
            								Assert reset to this function.</description>
            <name>FRG0</name>
          </field>
        </fields>
        <name>AYSNCPRESETCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Set bits in AYSNCPRESETCTRL</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the AYSNCPRESETCTRL register, if they are implemented. Bits
            								that do not correspond to defined bits in AYSNCPRESETCTRL are
            								reserved and only zeroes should be written to them.</description>
            <name>ARST_SET</name>
          </field>
        </fields>
        <name>AYSNCPRESETCTRLSET</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Clear bits in AYSNCPRESETCTRL</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the AYSNCPRESETCTRL register, if they are implemented.
            								Bits that do not correspond to defined bits in AYSNCPRESETCTRL are
            								reserved and only zeroes should be written to them.</description>
            <name>ARST_CLR</name>
          </field>
        </fields>
        <name>AYSNCPRESETCTRLCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Async peripheral clock control</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for USART0. 0 = Disable; 1 =
            								Enable.</description>
            <name>USART0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for USART1. 0 = Disable; 1 =
            								Enable.</description>
            <name>USART1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for USART2. 0 = Disable; 1 =
            								Enable.</description>
            <name>USART2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for USART3. 0 = Disable; 1 =
            								Enable.</description>
            <name>USART3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for I2C0. 0 = Disable; 1 =
            								Enable.</description>
            <name>I2C0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for I2C1. 0 = Disable; 1 =
            								Enable.</description>
            <name>I2C1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for I2C2. 0 = Disable; 1 =
            								Enable.</description>
            <name>I2C2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for SPI0. 0 = Disable; 1 =
            								Enable.</description>
            <name>SPI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for SPI1. 0 = Disable; 1 =
            								Enable.</description>
            <name>SPI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for TIMER0. 0 = Disable; 1 =
            								Enable.</description>
            <name>TIMER0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for TIMER1. 0 = Disable; 1 =
            								Enable.</description>
            <name>TIMER1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls the clock for the Fractional Rate Generator used
            								with the USARTs. 0 = Disable; 1 = Enable.</description>
            <name>FRG0</name>
          </field>
        </fields>
        <name>ASYNCAPBCLKCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Set bits in ASYNCAPBCLKCTRL</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register sets the corresponding bit or
            								bits in the ASYNCAPBCLKCTRL register, if they are implemented. Bits
            								that do not correspond to defined bits in AYSNCPRESETCTRL are
            								reserved and only zeroes should be written to them.</description>
            <name>ACLK_SET</name>
          </field>
        </fields>
        <name>ASYNCAPBCLKCTRLSET</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Clear bits in ASYNCAPBCLKCTRL</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing ones to this register clears the corresponding bit
            								or bits in the ASYNCAPBCLKCTRL register, if they are implemented.
            								Bits that do not correspond to defined bits in ASYNCAPBCLKCTRL are
            								reserved and only zeroes should be written to them.</description>
            <name>ACLK_CLR</name>
          </field>
        </fields>
        <name>ASYNCAPBCLKCTRLCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Async APB clock source select A</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock source for asynchronous clock source selector
            								A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC Oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>ASYNCAPBCLKSELA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Async APB clock source select B</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock source for asynchronous clock source selector
            								B.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Main clock</description>
                <name>MAIN_CLOCK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLKIN</description>
                <name>CLKIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System PLL output.</description>
                <name>SYSTEM_PLL_OUTPUT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ASYNCAPBCLKSELA. Clock selected by the
                										ASYNCAPBCLKSELA register.</description>
                <name>ASYNCAPBCLKSELA</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>ASYNCAPBCLKSELB</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Async APB clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Asynchronous APB clock divider value. 0: Clock disabled. 1:
            								Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>ASYNCCLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>USART fractional rate generator control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Denominator of the fractional divider. DIV is equal to the
            								programmed value +1. Always set to 0xFF to use with the fractional
            								baud rate generator.</description>
            <name>DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Numerator of the fractional divider. MULT is equal to the
            								programmed value.</description>
            <name>MULT</name>
          </field>
        </fields>
        <name>FRGCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Brown-Out Detect control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD reset level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 0: 1.5 V</description>
                <name>LEVEL_0_1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 1: 1.85 V</description>
                <name>LEVEL_1_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2: 2.0 V</description>
                <name>LEVEL_2_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3: 2.3 V</description>
                <name>LEVEL_3_2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTLEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD interrupt level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 0: 2.05 V</description>
                <name>LEVEL_0_2</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 1: 2.45 V</description>
                <name>LEVEL_1_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2: 2.75 V</description>
                <name>LEVEL_2_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3: 3.05 V</description>
                <name>LEVEL_3_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODINTVAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD reset enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable reset function.</description>
                <name>DISABLE_RESET_FUNCTI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable reset function.</description>
                <name>ENABLE_RESET_FUNCTIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTENA</name>
          </field>
        </fields>
        <name>BODCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40084000</baseAddress>
    <description>USART0 </description>
    <groupName>USART0</groupName>
    <interrupts>
      <interrupt>
        <name>UART0</name>
        <value>0x11</value>
      </interrupt>
    </interrupts>
    <name>USART0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings
        						that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal
                										state machine and counters are reset. While Enable = 0, all
                										USART interrupts and DMA transfers are disabled. When Enable
                										is set again, CFG and most other control bits remain
                										unchanged. For instance, when re-enabled, the USART will
                										immediately generate a TxRdy interrupt (if enabled in the
                										INTENSET register) or a DMA transfer request because the
                										transmitter has been reset and is therefore
                										available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for
                										operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for
                										addressing in multidrop mode. See the ADDRDET bit in the CTL
                										register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the
            								USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is even, and the
                										number of 1s in a received character is expected to be
                										even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is odd, and the
                										number of 1s in a received character is expected to be
                										odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a
            								single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for
                										asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART uses standard
                										clocking.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART uses the 32 kHz clock from the RTC
                										oscillator as the clock source to the BRG, and uses a
                										special bit clocking scheme.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN break mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Break detect and generate is configured
                										for normal operation.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Break detect and generate is configured
                										for LIN bus operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LINMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow
            								control. CTS can be from the input pin, or from the USART's own RTS
            								if loopback mode is enabled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive
                										any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses the CTS
                										input (or RTS output in loopback mode) for flow control
                										purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode.</description>
                <name>ASYNCHRONOUS_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode.</description>
                <name>SYNCHRONOUS_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received
            								data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge
                										of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge
                										of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART
                										is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART
                										is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform
                										diagnostic loopback testing for USART data. Serial data from
                										the transmitter (Un_TXD) is connected internally to serial
                										input of the receive (Un_RXD). Un_TXD and Un_RTS activity
                										will also appear on external pins if these functions are
                										configured to appear on device pins. The receiver RTS signal
                										is also looped back to CTS and performs flow control if
                										enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I/O output mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. USART output and input operate in
                										standard fashion.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA. USART output and input operate in IrDA
                										mode.</description>
                <name>IRDA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. If selected by OESEL, the Output Enable
                										signal deasserted at the end of the last stop bit of a
                										transmission.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. If selected by OESEL, the Output Enable
                										signal remains asserted for one character time after the end
                										of the last stop bit of a transmission. OE will also remain
                										asserted if another transmit begins before it is
                										deasserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET,
                										address matching is done by software. This provides the
                										possibility of versatile addressing (e.g. respond to more
                										than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET,
                										address matching is done by hardware, using the value in the
                										ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RTS signal is used as the standard
                										flow control function.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RS-485. The RTS signal configured to provide an
                										output enable signal to control an RS-485
                										transceiver.</description>
                <name>RS_485</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is
                										active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is
                										active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RX signal is used as it arrives from
                										the pin. This means that the RX rest value is 1, start bit
                										is 0, data is not inverted, and the stop bit is
                										1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being
                										used by the USART. This means that the RX rest value is 0,
                										start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The TX signal is sent out without change.
                										This means that the TX rest value is 1, start bit is 0, data
                										is not inverted, and the stop bit is 1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the USART
                										before being sent out. This means that the TX rest value is
                										0, start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely
        						to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break. Continuous break is sent
                										immediately when this bit is set, and remains until this bit
                										is cleared. A break may be sent without danger of corrupting
                										any currently transmitting character if the transmitter is
                										first disabled (TXDIS in CTL is set) and then waiting for
                										the transmitter to be disabled (TXDISINT in STAT = 1) before
                										writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming
                										data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data
                										that does not have the most significant bit of the data
                										(typically the 9th bit) = 1. When the data MSB bit = 1, the
                										receiver treats the incoming data normally, generating a
                										received data interrupt. Software can then check the data to
                										see if this is an address that should be handled. If it is,
                										the ADDRDET bit is cleared by software and further incoming
                										data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not
                										disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any
                										character currently being transmitted is complete. This
                										feature can be used to facilitate software flow
                										control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only
            								output while data is being transmitted in synchronous
            								mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK
                										cycles only when characters are being sent on Un_TXD or to
                										complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in
                										synchronous mode, allowing characters to be received on
                										Un_RxD independently from transmission on
                										Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared
                										when a complete character has been received. This bit is
                										cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART is in normal operating
                										mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART is in autobaud mode. This bit should
                										only be set when the USART receiver is idle. The first start
                										bit of RX is measured and used the update the BRG register
                										to match the received data rate. AUTOBAUD is cleared once
                										this process is complete, or if there is an
                										AERR.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here.
        						Writing ones clears some bits in the register. Some bits can be cleared by
        						writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is
            								available to be read from the receiver buffer. Cleared after a read
            								of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is
            								currently in the process of receiving data. When 1, indicates that
            								the receiver is not currently in the process of receiving
            								data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that
            								data may be written to the transmit buffer. Previous data may still
            								be in the process of being transmitted. Cleared when data is written
            								to TXDAT. Set when the data is moved from the transmit buffer to the
            								transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is
            								currently in the process of sending data.When 1, indicate that the
            								transmitter is not currently in the process of sending
            								data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal,
            								regardless of the setting of the CTSEN bit in the CFG register. This
            								will be the value of the CTS input pin unless loopback mode is
            								enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for
            								the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Status flag. When 1, this bit
            								indicates that the USART transmitter is fully idle after being
            								disabled via the TXDIS bit in the CFG register (TXDIS =
            								1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new
            								character is received while the receiver buffer is still in use. If
            								this occurs, the newly received character in the shift register is
            								lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the
            								receiver break detection logic. It is set when the Un_RXD pin
            								remains low for 16 bit times. Note that FRAMERRINT will also be set
            								when this condition occurs because the stop bit(s) for the character
            								would be missing. RXBRK is cleared when the Un_RXD pin goes
            								high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input. Its purpose is primarily to allow wake-up from Deep-sleep or
            								Power-down mode immediately when a start is detected. Cleared by
            								software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a
            								character is received with a missing stop bit at the expected
            								location. This could be an indication of a baud rate or
            								configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity
            								error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received
            								data are taken in order to determine the value of each received data
            								bit, except in synchronous mode. This acts as a noise filter if one
            								sample disagrees. This flag is set when a received data bit contains
            								one disagreeing sample. This could indicate line noise, a baud rate
            								or character format mismatch, or loss of synchronization during data
            								reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error. An auto baud error can occur if the BRG
            								counts to its limit before the end of the start bit that is being
            								measured, essentially an auto baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual
        						interrupt enable bit for each potential USART interrupt. A complete value
        						may be read from this register. Writing a 1 to any implemented bit position
        						causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received
            								character available to be read from the RXDAT
            								register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is
            								available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes
            								idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the
            								state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully
            								disabled as indicated by the TXDISINT flag in STAT. See description
            								of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error
            								occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has
            								occurred in the detection of a received break condition (break
            								condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has
            								been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been
            								detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been
            								detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected. See
            								description of the RXNOISEINT bit in Table 311.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto baud error
            								occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of
        						bits in the INTENSET register. Writing a 1 to any implemented bit position
        						causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXDISCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character
        						received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character
        						received with the current USART receive status. Allows DMA or software to
        						recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>RXDATA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RxNoiseInt bit
            								in Table 311.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written
        						here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and any conditions for transmitting data are met: CTS low
            								(if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor
        						value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to
            								determine the baud rate, based on the input clock from the FRG. 0 =
            								The FRG clock is used directly by the USART function. 1 = The FRG
            								clock is divided by 2 before use by the USART function. 2 = The FRG
            								clock is divided by 3 before use by the USART function. ... 0xFFFF =
            								The FRG clock is divided by 65,536 before use by the USART
            								function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently
        						enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input
            								is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error Interrupt flag.</description>
            <name>ABERRINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous
        						communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5
            								peripheral clocks are used to transmit and receive each data bit.
            								0x5 = 6 peripheral clocks are used to transmit and receive each data
            								bit. ... 0xF= 16 peripheral clocks are used to transmit and receive
            								each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used
            								when address detection is enabled (ADDRDET in CTL = 1) and automatic
            								address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40088000</baseAddress>
    <derivedFrom>USART0</derivedFrom>
    <description>USART1</description>
    <groupName>USART0</groupName>
    <interrupts>
      <interrupt>
        <name>UART1</name>
        <value>0x12</value>
      </interrupt>
    </interrupts>
    <name>USART1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings
        						that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal
                										state machine and counters are reset. While Enable = 0, all
                										USART interrupts and DMA transfers are disabled. When Enable
                										is set again, CFG and most other control bits remain
                										unchanged. For instance, when re-enabled, the USART will
                										immediately generate a TxRdy interrupt (if enabled in the
                										INTENSET register) or a DMA transfer request because the
                										transmitter has been reset and is therefore
                										available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for
                										operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for
                										addressing in multidrop mode. See the ADDRDET bit in the CTL
                										register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the
            								USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is even, and the
                										number of 1s in a received character is expected to be
                										even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is odd, and the
                										number of 1s in a received character is expected to be
                										odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a
            								single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for
                										asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART uses standard
                										clocking.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART uses the 32 kHz clock from the RTC
                										oscillator as the clock source to the BRG, and uses a
                										special bit clocking scheme.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN break mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Break detect and generate is configured
                										for normal operation.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Break detect and generate is configured
                										for LIN bus operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LINMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow
            								control. CTS can be from the input pin, or from the USART's own RTS
            								if loopback mode is enabled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive
                										any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses the CTS
                										input (or RTS output in loopback mode) for flow control
                										purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode.</description>
                <name>ASYNCHRONOUS_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode.</description>
                <name>SYNCHRONOUS_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received
            								data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge
                										of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge
                										of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART
                										is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART
                										is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform
                										diagnostic loopback testing for USART data. Serial data from
                										the transmitter (Un_TXD) is connected internally to serial
                										input of the receive (Un_RXD). Un_TXD and Un_RTS activity
                										will also appear on external pins if these functions are
                										configured to appear on device pins. The receiver RTS signal
                										is also looped back to CTS and performs flow control if
                										enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I/O output mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. USART output and input operate in
                										standard fashion.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA. USART output and input operate in IrDA
                										mode.</description>
                <name>IRDA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. If selected by OESEL, the Output Enable
                										signal deasserted at the end of the last stop bit of a
                										transmission.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. If selected by OESEL, the Output Enable
                										signal remains asserted for one character time after the end
                										of the last stop bit of a transmission. OE will also remain
                										asserted if another transmit begins before it is
                										deasserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET,
                										address matching is done by software. This provides the
                										possibility of versatile addressing (e.g. respond to more
                										than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET,
                										address matching is done by hardware, using the value in the
                										ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RTS signal is used as the standard
                										flow control function.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RS-485. The RTS signal configured to provide an
                										output enable signal to control an RS-485
                										transceiver.</description>
                <name>RS_485</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is
                										active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is
                										active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RX signal is used as it arrives from
                										the pin. This means that the RX rest value is 1, start bit
                										is 0, data is not inverted, and the stop bit is
                										1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being
                										used by the USART. This means that the RX rest value is 0,
                										start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The TX signal is sent out without change.
                										This means that the TX rest value is 1, start bit is 0, data
                										is not inverted, and the stop bit is 1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the USART
                										before being sent out. This means that the TX rest value is
                										0, start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely
        						to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break. Continuous break is sent
                										immediately when this bit is set, and remains until this bit
                										is cleared. A break may be sent without danger of corrupting
                										any currently transmitting character if the transmitter is
                										first disabled (TXDIS in CTL is set) and then waiting for
                										the transmitter to be disabled (TXDISINT in STAT = 1) before
                										writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming
                										data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data
                										that does not have the most significant bit of the data
                										(typically the 9th bit) = 1. When the data MSB bit = 1, the
                										receiver treats the incoming data normally, generating a
                										received data interrupt. Software can then check the data to
                										see if this is an address that should be handled. If it is,
                										the ADDRDET bit is cleared by software and further incoming
                										data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not
                										disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any
                										character currently being transmitted is complete. This
                										feature can be used to facilitate software flow
                										control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only
            								output while data is being transmitted in synchronous
            								mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK
                										cycles only when characters are being sent on Un_TXD or to
                										complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in
                										synchronous mode, allowing characters to be received on
                										Un_RxD independently from transmission on
                										Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared
                										when a complete character has been received. This bit is
                										cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART is in normal operating
                										mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART is in autobaud mode. This bit should
                										only be set when the USART receiver is idle. The first start
                										bit of RX is measured and used the update the BRG register
                										to match the received data rate. AUTOBAUD is cleared once
                										this process is complete, or if there is an
                										AERR.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here.
        						Writing ones clears some bits in the register. Some bits can be cleared by
        						writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is
            								available to be read from the receiver buffer. Cleared after a read
            								of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is
            								currently in the process of receiving data. When 1, indicates that
            								the receiver is not currently in the process of receiving
            								data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that
            								data may be written to the transmit buffer. Previous data may still
            								be in the process of being transmitted. Cleared when data is written
            								to TXDAT. Set when the data is moved from the transmit buffer to the
            								transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is
            								currently in the process of sending data.When 1, indicate that the
            								transmitter is not currently in the process of sending
            								data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal,
            								regardless of the setting of the CTSEN bit in the CFG register. This
            								will be the value of the CTS input pin unless loopback mode is
            								enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for
            								the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Status flag. When 1, this bit
            								indicates that the USART transmitter is fully idle after being
            								disabled via the TXDIS bit in the CFG register (TXDIS =
            								1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new
            								character is received while the receiver buffer is still in use. If
            								this occurs, the newly received character in the shift register is
            								lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the
            								receiver break detection logic. It is set when the Un_RXD pin
            								remains low for 16 bit times. Note that FRAMERRINT will also be set
            								when this condition occurs because the stop bit(s) for the character
            								would be missing. RXBRK is cleared when the Un_RXD pin goes
            								high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input. Its purpose is primarily to allow wake-up from Deep-sleep or
            								Power-down mode immediately when a start is detected. Cleared by
            								software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a
            								character is received with a missing stop bit at the expected
            								location. This could be an indication of a baud rate or
            								configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity
            								error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received
            								data are taken in order to determine the value of each received data
            								bit, except in synchronous mode. This acts as a noise filter if one
            								sample disagrees. This flag is set when a received data bit contains
            								one disagreeing sample. This could indicate line noise, a baud rate
            								or character format mismatch, or loss of synchronization during data
            								reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error. An auto baud error can occur if the BRG
            								counts to its limit before the end of the start bit that is being
            								measured, essentially an auto baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual
        						interrupt enable bit for each potential USART interrupt. A complete value
        						may be read from this register. Writing a 1 to any implemented bit position
        						causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received
            								character available to be read from the RXDAT
            								register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is
            								available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes
            								idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the
            								state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully
            								disabled as indicated by the TXDISINT flag in STAT. See description
            								of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error
            								occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has
            								occurred in the detection of a received break condition (break
            								condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has
            								been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been
            								detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been
            								detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected. See
            								description of the RXNOISEINT bit in Table 311.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto baud error
            								occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of
        						bits in the INTENSET register. Writing a 1 to any implemented bit position
        						causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXDISCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character
        						received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character
        						received with the current USART receive status. Allows DMA or software to
        						recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>RXDATA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RxNoiseInt bit
            								in Table 311.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written
        						here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and any conditions for transmitting data are met: CTS low
            								(if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor
        						value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to
            								determine the baud rate, based on the input clock from the FRG. 0 =
            								The FRG clock is used directly by the USART function. 1 = The FRG
            								clock is divided by 2 before use by the USART function. 2 = The FRG
            								clock is divided by 3 before use by the USART function. ... 0xFFFF =
            								The FRG clock is divided by 65,536 before use by the USART
            								function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently
        						enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input
            								is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error Interrupt flag.</description>
            <name>ABERRINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous
        						communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5
            								peripheral clocks are used to transmit and receive each data bit.
            								0x5 = 6 peripheral clocks are used to transmit and receive each data
            								bit. ... 0xF= 16 peripheral clocks are used to transmit and receive
            								each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used
            								when address detection is enabled (ADDRDET in CTL = 1) and automatic
            								address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4008C000</baseAddress>
    <derivedFrom>USART0</derivedFrom>
    <description>USART2</description>
    <groupName>USART0</groupName>
    <interrupts>
      <interrupt>
        <name>UART2</name>
        <value>0x13</value>
      </interrupt>
    </interrupts>
    <name>USART2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings
        						that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal
                										state machine and counters are reset. While Enable = 0, all
                										USART interrupts and DMA transfers are disabled. When Enable
                										is set again, CFG and most other control bits remain
                										unchanged. For instance, when re-enabled, the USART will
                										immediately generate a TxRdy interrupt (if enabled in the
                										INTENSET register) or a DMA transfer request because the
                										transmitter has been reset and is therefore
                										available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for
                										operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for
                										addressing in multidrop mode. See the ADDRDET bit in the CTL
                										register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the
            								USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is even, and the
                										number of 1s in a received character is expected to be
                										even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is odd, and the
                										number of 1s in a received character is expected to be
                										odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a
            								single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for
                										asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART uses standard
                										clocking.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART uses the 32 kHz clock from the RTC
                										oscillator as the clock source to the BRG, and uses a
                										special bit clocking scheme.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN break mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Break detect and generate is configured
                										for normal operation.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Break detect and generate is configured
                										for LIN bus operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LINMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow
            								control. CTS can be from the input pin, or from the USART's own RTS
            								if loopback mode is enabled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive
                										any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses the CTS
                										input (or RTS output in loopback mode) for flow control
                										purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode.</description>
                <name>ASYNCHRONOUS_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode.</description>
                <name>SYNCHRONOUS_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received
            								data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge
                										of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge
                										of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART
                										is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART
                										is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform
                										diagnostic loopback testing for USART data. Serial data from
                										the transmitter (Un_TXD) is connected internally to serial
                										input of the receive (Un_RXD). Un_TXD and Un_RTS activity
                										will also appear on external pins if these functions are
                										configured to appear on device pins. The receiver RTS signal
                										is also looped back to CTS and performs flow control if
                										enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I/O output mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. USART output and input operate in
                										standard fashion.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA. USART output and input operate in IrDA
                										mode.</description>
                <name>IRDA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. If selected by OESEL, the Output Enable
                										signal deasserted at the end of the last stop bit of a
                										transmission.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. If selected by OESEL, the Output Enable
                										signal remains asserted for one character time after the end
                										of the last stop bit of a transmission. OE will also remain
                										asserted if another transmit begins before it is
                										deasserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET,
                										address matching is done by software. This provides the
                										possibility of versatile addressing (e.g. respond to more
                										than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET,
                										address matching is done by hardware, using the value in the
                										ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RTS signal is used as the standard
                										flow control function.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RS-485. The RTS signal configured to provide an
                										output enable signal to control an RS-485
                										transceiver.</description>
                <name>RS_485</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is
                										active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is
                										active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RX signal is used as it arrives from
                										the pin. This means that the RX rest value is 1, start bit
                										is 0, data is not inverted, and the stop bit is
                										1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being
                										used by the USART. This means that the RX rest value is 0,
                										start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The TX signal is sent out without change.
                										This means that the TX rest value is 1, start bit is 0, data
                										is not inverted, and the stop bit is 1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the USART
                										before being sent out. This means that the TX rest value is
                										0, start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely
        						to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break. Continuous break is sent
                										immediately when this bit is set, and remains until this bit
                										is cleared. A break may be sent without danger of corrupting
                										any currently transmitting character if the transmitter is
                										first disabled (TXDIS in CTL is set) and then waiting for
                										the transmitter to be disabled (TXDISINT in STAT = 1) before
                										writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming
                										data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data
                										that does not have the most significant bit of the data
                										(typically the 9th bit) = 1. When the data MSB bit = 1, the
                										receiver treats the incoming data normally, generating a
                										received data interrupt. Software can then check the data to
                										see if this is an address that should be handled. If it is,
                										the ADDRDET bit is cleared by software and further incoming
                										data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not
                										disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any
                										character currently being transmitted is complete. This
                										feature can be used to facilitate software flow
                										control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only
            								output while data is being transmitted in synchronous
            								mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK
                										cycles only when characters are being sent on Un_TXD or to
                										complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in
                										synchronous mode, allowing characters to be received on
                										Un_RxD independently from transmission on
                										Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared
                										when a complete character has been received. This bit is
                										cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART is in normal operating
                										mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART is in autobaud mode. This bit should
                										only be set when the USART receiver is idle. The first start
                										bit of RX is measured and used the update the BRG register
                										to match the received data rate. AUTOBAUD is cleared once
                										this process is complete, or if there is an
                										AERR.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here.
        						Writing ones clears some bits in the register. Some bits can be cleared by
        						writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is
            								available to be read from the receiver buffer. Cleared after a read
            								of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is
            								currently in the process of receiving data. When 1, indicates that
            								the receiver is not currently in the process of receiving
            								data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that
            								data may be written to the transmit buffer. Previous data may still
            								be in the process of being transmitted. Cleared when data is written
            								to TXDAT. Set when the data is moved from the transmit buffer to the
            								transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is
            								currently in the process of sending data.When 1, indicate that the
            								transmitter is not currently in the process of sending
            								data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal,
            								regardless of the setting of the CTSEN bit in the CFG register. This
            								will be the value of the CTS input pin unless loopback mode is
            								enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for
            								the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Status flag. When 1, this bit
            								indicates that the USART transmitter is fully idle after being
            								disabled via the TXDIS bit in the CFG register (TXDIS =
            								1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new
            								character is received while the receiver buffer is still in use. If
            								this occurs, the newly received character in the shift register is
            								lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the
            								receiver break detection logic. It is set when the Un_RXD pin
            								remains low for 16 bit times. Note that FRAMERRINT will also be set
            								when this condition occurs because the stop bit(s) for the character
            								would be missing. RXBRK is cleared when the Un_RXD pin goes
            								high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input. Its purpose is primarily to allow wake-up from Deep-sleep or
            								Power-down mode immediately when a start is detected. Cleared by
            								software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a
            								character is received with a missing stop bit at the expected
            								location. This could be an indication of a baud rate or
            								configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity
            								error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received
            								data are taken in order to determine the value of each received data
            								bit, except in synchronous mode. This acts as a noise filter if one
            								sample disagrees. This flag is set when a received data bit contains
            								one disagreeing sample. This could indicate line noise, a baud rate
            								or character format mismatch, or loss of synchronization during data
            								reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error. An auto baud error can occur if the BRG
            								counts to its limit before the end of the start bit that is being
            								measured, essentially an auto baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual
        						interrupt enable bit for each potential USART interrupt. A complete value
        						may be read from this register. Writing a 1 to any implemented bit position
        						causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received
            								character available to be read from the RXDAT
            								register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is
            								available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes
            								idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the
            								state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully
            								disabled as indicated by the TXDISINT flag in STAT. See description
            								of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error
            								occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has
            								occurred in the detection of a received break condition (break
            								condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has
            								been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been
            								detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been
            								detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected. See
            								description of the RXNOISEINT bit in Table 311.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto baud error
            								occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of
        						bits in the INTENSET register. Writing a 1 to any implemented bit position
        						causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXDISCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character
        						received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character
        						received with the current USART receive status. Allows DMA or software to
        						recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>RXDATA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RxNoiseInt bit
            								in Table 311.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written
        						here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and any conditions for transmitting data are met: CTS low
            								(if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor
        						value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to
            								determine the baud rate, based on the input clock from the FRG. 0 =
            								The FRG clock is used directly by the USART function. 1 = The FRG
            								clock is divided by 2 before use by the USART function. 2 = The FRG
            								clock is divided by 3 before use by the USART function. ... 0xFFFF =
            								The FRG clock is divided by 65,536 before use by the USART
            								function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently
        						enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input
            								is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error Interrupt flag.</description>
            <name>ABERRINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous
        						communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5
            								peripheral clocks are used to transmit and receive each data bit.
            								0x5 = 6 peripheral clocks are used to transmit and receive each data
            								bit. ... 0xF= 16 peripheral clocks are used to transmit and receive
            								each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used
            								when address detection is enabled (ADDRDET in CTL = 1) and automatic
            								address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40090000</baseAddress>
    <derivedFrom>USART0</derivedFrom>
    <description>USART3</description>
    <groupName>USART0</groupName>
    <interrupts>
      <interrupt>
        <name>UART3</name>
        <value>0x14</value>
      </interrupt>
    </interrupts>
    <name>USART3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings
        						that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal
                										state machine and counters are reset. While Enable = 0, all
                										USART interrupts and DMA transfers are disabled. When Enable
                										is set again, CFG and most other control bits remain
                										unchanged. For instance, when re-enabled, the USART will
                										immediately generate a TxRdy interrupt (if enabled in the
                										INTENSET register) or a DMA transfer request because the
                										transmitter has been reset and is therefore
                										available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for
                										operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for
                										addressing in multidrop mode. See the ADDRDET bit in the CTL
                										register.</description>
                <name>9_BIT_DATA_LENGTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the
            								USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is even, and the
                										number of 1s in a received character is expected to be
                										even.</description>
                <name>EVEN_PARITY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that
                										the number of 1s in a transmitted character is odd, and the
                										number of 1s in a received character is expected to be
                										odd.</description>
                <name>ODD_PARITY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a
            								single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for
                										asynchronous communication.</description>
                <name>2_STOP_BITS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects standard or 32 kHz clocking mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART uses standard
                										clocking.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART uses the 32 kHz clock from the RTC
                										oscillator as the clock source to the BRG, and uses a
                										special bit clocking scheme.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE32K</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN break mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Break detect and generate is configured
                										for normal operation.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Break detect and generate is configured
                										for LIN bus operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LINMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow
            								control. CTS can be from the input pin, or from the USART's own RTS
            								if loopback mode is enabled.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive
                										any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses the CTS
                										input (or RTS output in loopback mode) for flow control
                										purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode.</description>
                <name>ASYNCHRONOUS_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode.</description>
                <name>SYNCHRONOUS_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received
            								data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge
                										of SCLK.</description>
                <name>FALLING_EDGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge
                										of SCLK.</description>
                <name>RISING_EDGE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART
                										is a slave.</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART
                										is a master.</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform
                										diagnostic loopback testing for USART data. Serial data from
                										the transmitter (Un_TXD) is connected internally to serial
                										input of the receive (Un_RXD). Un_TXD and Un_RTS activity
                										will also appear on external pins if these functions are
                										configured to appear on device pins. The receiver RTS signal
                										is also looped back to CTS and performs flow control if
                										enabled by CTSEN.</description>
                <name>LOOPBACK_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I/O output mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. USART output and input operate in
                										standard fashion.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IrDA. USART output and input operate in IrDA
                										mode.</description>
                <name>IRDA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Turnaround time enable for RS-485
            								operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. If selected by OESEL, the Output Enable
                										signal deasserted at the end of the last stop bit of a
                										transmission.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. If selected by OESEL, the Output Enable
                										signal remains asserted for one character time after the end
                										of the last stop bit of a transmission. OE will also remain
                										asserted if another transmit begins before it is
                										deasserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OETA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Address matching enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. When addressing is enabled by ADDRDET,
                										address matching is done by software. This provides the
                										possibility of versatile addressing (e.g. respond to more
                										than one address).</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. When addressing is enabled by ADDRDET,
                										address matching is done by hardware, using the value in the
                										ADDR register as the address to match.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RTS signal is used as the standard
                										flow control function.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RS-485. The RTS signal configured to provide an
                										output enable signal to control an RS-485
                										transceiver.</description>
                <name>RS_485</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output Enable Polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. If selected by OESEL, the output enable is
                										active low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. If selected by OESEL, the output enable is
                										active high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OEPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The RX signal is used as it arrives from
                										the pin. This means that the RX rest value is 1, start bit
                										is 0, data is not inverted, and the stop bit is
                										1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The RX signal is inverted before being
                										used by the USART. This means that the RX rest value is 0,
                										start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit data polarity.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. The TX signal is sent out without change.
                										This means that the TX rest value is 1, start bit is 0, data
                										is not inverted, and the stop bit is 1.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted. The TX signal is inverted by the USART
                										before being sent out. This means that the TX rest value is
                										0, start bit is 1, data is inverted, and the stop bit is
                										0.</description>
                <name>INVERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely
        						to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break. Continuous break is sent
                										immediately when this bit is set, and remains until this bit
                										is cleared. A break may be sent without danger of corrupting
                										any currently transmitting character if the transmitter is
                										first disabled (TXDIS in CTL is set) and then waiting for
                										the transmitter to be disabled (TXDISINT in STAT = 1) before
                										writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART presents all incoming
                										data.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver ignores incoming data
                										that does not have the most significant bit of the data
                										(typically the 9th bit) = 1. When the data MSB bit = 1, the
                										receiver treats the incoming data normally, generating a
                										received data interrupt. Software can then check the data to
                										see if this is an address that should be handled. If it is,
                										the ADDRDET bit is cleared by software and further incoming
                										data is handled normally.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not
                										disabled.</description>
                <name>NOT_DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any
                										character currently being transmitted is complete. This
                										feature can be used to facilitate software flow
                										control.</description>
                <name>DISABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only
            								output while data is being transmitted in synchronous
            								mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK
                										cycles only when characters are being sent on Un_TXD or to
                										complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in
                										synchronous mode, allowing characters to be received on
                										Un_RxD independently from transmission on
                										Un_TXD).</description>
                <name>CONTINUOUS_CLOCK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. No effect on the CC bit.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared
                										when a complete character has been received. This bit is
                										cleared at the same time.</description>
                <name>AUTO_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCCONRX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Autobaud enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART is in normal operating
                										mode.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. USART is in autobaud mode. This bit should
                										only be set when the USART receiver is idle. The first start
                										bit of RX is measured and used the update the BRG register
                										to match the received data rate. AUTOBAUD is cleared once
                										this process is complete, or if there is an
                										AERR.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AUTOBAUD</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here.
        						Writing ones clears some bits in the register. Some bits can be cleared by
        						writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is
            								available to be read from the receiver buffer. Cleared after a read
            								of the RXDAT or RXDATSTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is
            								currently in the process of receiving data. When 1, indicates that
            								the receiver is not currently in the process of receiving
            								data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that
            								data may be written to the transmit buffer. Previous data may still
            								be in the process of being transmitted. Cleared when data is written
            								to TXDAT. Set when the data is moved from the transmit buffer to the
            								transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is
            								currently in the process of sending data.When 1, indicate that the
            								transmitter is not currently in the process of sending
            								data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal,
            								regardless of the setting of the CTSEN bit in the CFG register. This
            								will be the value of the CTS input pin unless loopback mode is
            								enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for
            								the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Status flag. When 1, this bit
            								indicates that the USART transmitter is fully idle after being
            								disabled via the TXDIS bit in the CFG register (TXDIS =
            								1).</description>
            <name>TXDISSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new
            								character is received while the receiver buffer is still in use. If
            								this occurs, the newly received character in the shift register is
            								lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the
            								receiver break detection logic. It is set when the Un_RXD pin
            								remains low for 16 bit times. Note that FRAMERRINT will also be set
            								when this condition occurs because the stop bit(s) for the character
            								would be missing. RXBRK is cleared when the Un_RXD pin goes
            								high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input. Its purpose is primarily to allow wake-up from Deep-sleep or
            								Power-down mode immediately when a start is detected. Cleared by
            								software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a
            								character is received with a missing stop bit at the expected
            								location. This could be an indication of a baud rate or
            								configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity
            								error is detected in a received character..</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. Three samples of received
            								data are taken in order to determine the value of each received data
            								bit, except in synchronous mode. This acts as a noise filter if one
            								sample disagrees. This flag is set when a received data bit contains
            								one disagreeing sample. This could indicate line noise, a baud rate
            								or character format mismatch, or loss of synchronization during data
            								reception.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error. An auto baud error can occur if the BRG
            								counts to its limit before the end of the start bit that is being
            								measured, essentially an auto baud time-out.</description>
            <name>ABERR</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual
        						interrupt enable bit for each potential USART interrupt. A complete value
        						may be read from this register. Writing a 1 to any implemented bit position
        						causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received
            								character available to be read from the RXDAT
            								register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDAT register is
            								available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter becomes
            								idle (TXIDLE = 1).</description>
            <name>TXIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the
            								state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully
            								disabled as indicated by the TXDISINT flag in STAT. See description
            								of the TXDISINT bit for details.</description>
            <name>TXDISEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error
            								occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has
            								occurred in the detection of a received break condition (break
            								condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has
            								been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been
            								detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been
            								detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected. See
            								description of the RXNOISEINT bit in Table 311.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an auto baud error
            								occurs.</description>
            <name>ABERREN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of
        						bits in the INTENSET register. Writing a 1 to any implemented bit position
        						causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>TXDISCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET
            								register.</description>
            <name>ABERRCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character
        						received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character
        						received with the current USART receive status. Allows DMA or software to
        						recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received
            								character. The number of bits that are relevant depends on the USART
            								configuration settings.</description>
            <name>RXDATA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is
            								a character to be read in the RXDAT register and reflects the status
            								of that character. This bit will set when the character in RXDAT was
            								received with a missing stop bit at the expected location. This
            								could be an indication of a baud rate or configuration mismatch with
            								the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a
            								character to be read in the RXDAT register and reflects the status
            								of that character. This bit will be set when a parity error is
            								detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RxNoiseInt bit
            								in Table 311.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATSTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written
        						here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data
            								to be transmitted as soon as the transmit shift register is
            								available and any conditions for transmitting data are met: CTS low
            								(if CTSEN bit = 1), TXDIS bit = 0.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor
        						value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to
            								determine the baud rate, based on the input clock from the FRG. 0 =
            								The FRG clock is used directly by the USART function. 1 = The FRG
            								clock is divided by 2 before use by the USART function. 2 = The FRG
            								clock is divided by 3 before use by the USART function. ... 0xFFFF =
            								The FRG clock is divided by 65,536 before use by the USART
            								function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently
        						enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle status.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input
            								is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver
            								break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver
            								input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto baud Error Interrupt flag.</description>
            <name>ABERRINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Oversample selection register for asynchronous
        						communication.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Oversample Selection Value. 0 to 3 = not supported 0x4 = 5
            								peripheral clocks are used to transmit and receive each data bit.
            								0x5 = 6 peripheral clocks are used to transmit and receive each data
            								bit. ... 0xF= 16 peripheral clocks are used to transmit and receive
            								each data bit.</description>
            <name>OSRVAL</name>
          </field>
        </fields>
        <name>OSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Address register for automatic address matching.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit address used with automatic address matching. Used
            								when address detection is enabled (ADDRDET in CTL = 1) and automatic
            								address matching is enabled (AUTOADDR in CFG = 1).</description>
            <name>ADDRESS</name>
          </field>
        </fields>
        <name>ADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40094000</baseAddress>
    <description>I2C-bus interface 0</description>
    <groupName>I2C0</groupName>
    <interrupts>
      <interrupt>
        <name>I2C0</name>
        <value>0x15</value>
      </interrupt>
    </interrupts>
    <name>I2C0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Configuration for shared functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Enable. When disabled, configurations settings for
            								the Master function are not changed, but the Master function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C Master function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C Master function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Enable. When disabled, configurations settings for
            								the Slave function are not changed, but the Slave function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C slave function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C slave function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Enable. When disabled, configurations settings for
            								the Monitor function are not changed, but the Monitor function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C monitor function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C monitor function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus Time-out Enable. When disabled, the time-out
            								function is internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Time-out function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Time-out function is enabled. Both types
                										of time-out flags will be generated and will cause
                										interrupts if they are enabled. Typically, only one time-out
                										will be used in a system.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor function Clock Stretching.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The monitor function will not perform
                										clock stretching. Software or DMA may not always be able to
                										read data provided by the monitor function before it is
                										overwritten. This mode may be used when non-invasive
                										monitoring is critical.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The monitor function will perform clock
                										stretching in order to ensure that software or DMA can read
                										all incoming data supplied by the monitor
                										function.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONCLKSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>High-speed mode Capable enable. Since High Speed mode
            								alters the way I2C pins drive and filter, as well as the timing for
            								certain I2C signalling, enabling High-speed mode applies to all
            								functions: master, slave, and monitor.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast-mode plus. The I2C block will support
                										Standard-mode, Fast-mode, and Fast-mode Plus, to the extent
                										that the pin electronics support these modes. Any changes
                										that need to be made to the pin controls, such as changing
                										the drive strength or filtering, must be made by software
                										via the IOCON register associated with each I2C
                										pin,</description>
                <name>FAST_MODE_PLUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High-speed. In addition to Standard-mode,
                										Fast-mode, and Fast-mode Plus, the I 2C block will support
                										High-speed mode to the extent that the pin electronics
                										support these modes. See Section 23.7.1.2 for more
                										information.</description>
                <name>HIGH_SPEED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HSCAPABLE</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Status register for Master, Slave, and Monitor
        						functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending. Indicates that the Master is waiting to
            								continue communication on the I2C-bus (pending) or is idle. When the
            								master is pending, the MSTSTATE bits indicate what type of software
            								service if any the master expects. This flag will cause an interrupt
            								when set if, enabled via the INTENSET register. The MSTPENDING flag
            								is not set when the DMA is handling an event (if the MSTDMA bit in
            								the MSTCTL register is set). If the master is in the idle state, and
            								no communication is needed, mask this interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>In progress. Communication is in progress and the
                										Master function is busy and cannot currently accept a
                										command.</description>
                <name>IN_PROGRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. The Master function needs software service
                										or is in the idle state. If the master is not in the idle
                										state, it is waiting to receive or transmit data or the NACK
                										bit.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master State code. The master state code reflects the
            								master state when the MSTPENDING bit is set, that is the master is
            								pending or in the idle state. Each value of this field indicates a
            								specific required service for the Master function. All other values
            								are reserved. See Table 346 for details of state values and
            								appropriate responses.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The Master function is available to be used
                										for a new transaction.</description>
                <name>IDLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Receive ready. Received data available (Master
                										Receiver mode). Address plus Read was previously sent and
                										Acknowledged by slave.</description>
                <name>RECEIVE_READY</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transmit ready. Data can be transmitted (Master
                										Transmitter mode). Address plus Write was previously sent
                										and Acknowledged by slave.</description>
                <name>TRANSMIT_READY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK Address. Slave NACKed address.</description>
                <name>NACK_ADDRESS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK Data. Slave NACKed transmitted
                										data.</description>
                <name>NACK_DATA</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag. This flag can be cleared by
            								software writing a 1 to this bit. It is also cleared automatically a
            								1 is written to MSTCONTINUE.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No Arbitration Loss has occurred.</description>
                <name>NO_ARBITRATION_LOSS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Arbitration loss. The Master function has
                										experienced an Arbitration Loss. At this point, the Master
                										function has already stopped driving the bus and gone to an
                										idle state. Software can respond by doing nothing, or by
                										sending a Start in order to attempt to gain control of the
                										bus when it next becomes idle.</description>
                <name>ARBITRATION_LOSS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag. This flag can be cleared by
            								software writing a 1 to this bit. It is also cleared automatically a
            								1 is written to MSTCONTINUE.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No Start/Stop Error has occurred.</description>
                <name>NO_STARTSTOP_ERROR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Master function has experienced a Start/Stop
                										Error. A Start or Stop was detected at a time when it is not
                										allowed by the I2C specification. The Master interface has
                										stopped driving the bus and gone to an idle state, no action
                										is required. A request for a Start could be made, or
                										software could attempt to insure that the bus has not
                										stalled.</description>
                <name>THE_MASTER_FUNCTION</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending. Indicates that the Slave function is waiting
            								to continue communication on the I2C-bus and needs software service.
            								This flag will cause an interrupt when set if enabled via INTENSET.
            								The SLVPENDING flag is not set when the DMA is handling an event (if
            								the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag
            								is read-only and is automatically cleared when a 1 is written to the
            								SLVCONTINUE bit in the MSTCTL register. The point in time when
            								SlvPending is set depends on whether the I2C block is in HSCAPABLE
            								mode. See Section 23.7.1.2.2. When the I2C block is configured to be
            								HSCAPABLE, HS master codes are detected automatically. Due to the
            								requirements of the HS I2C specification, slave addresses must also
            								be detected automatically, since the address must be acknowledged
            								before the clock can be stretched.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>In progress. The Slave function does not currently
                										need service.</description>
                <name>IN_PROGRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. The Slave function needs service.
                										Information on what is needed can be found in the adjacent
                										SLVSTATE field.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave State code. Each value of this field indicates a
            								specific required service for the Slave function. All other values
            								are reserved. See Table 347 for state values and
            								actions.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave address. Address plus R/W received. At least
                										one of the four slave addresses has been matched by
                										hardware.</description>
                <name>SLAVE_ADDRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave receive. Received data is available (Slave
                										Receiver mode).</description>
                <name>SLAVE_RECEIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave transmit. Data can be transmitted (Slave
                										Transmitter mode).</description>
                <name>SLAVE_TRANSMIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching. Indicates when the slave function is
            								stretching the I2C clock. This is needed in order to gracefully
            								invoke Deep Sleep or Power-down modes during slave operation. This
            								read-only flag reflects the slave function status in real
            								time.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stretching. The slave function is currently
                										stretching the I2C bus clock. Deep-Sleep or Power-down mode
                										cannot be entered at this time.</description>
                <name>STRETCHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not stretching. The slave function is not currently
                										stretching the I 2C bus clock. Deep-sleep or Power-down mode
                										could be entered at this time.</description>
                <name>NOT_STRETCHING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave address match Index. This field is valid when the I2C
            								slave function has been selected by receiving an address that
            								matches one of the slave addresses defined by any enabled slave
            								address registers, and provides an identification of the address
            								that was matched. It is possible that more than one address could be
            								matched, but only one match can be reported here.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 0. Slave address 0 was
                										matched.</description>
                <name>ADDRESS_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 1. Slave address 1 was
                										matched.</description>
                <name>ADDRESS_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 2. Slave address 2 was
                										matched.</description>
                <name>ADDRESS_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 3. Slave address 3 was
                										matched.</description>
                <name>ADDRESS_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVIDX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave selected flag. SLVSEL is set after an address match
            								when software tells the Slave function to acknowledge the address.
            								It is cleared when another address cycle presents an address that
            								does not match an enabled address on the Slave function, when slave
            								software decides to NACK a matched address, or when there is a Stop
            								detected on the bus. SLVSEL is not cleared if software NACKs
            								data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not selected. The Slave function is not currently
                										selected.</description>
                <name>NOT_SELECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selected. The Slave function is currently
                										selected.</description>
                <name>SELECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag. This flag will cause an interrupt
            								when set if enabled via INTENSET. This flag can be cleared by
            								writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not deselected. The Slave function has not become
                										deselected. This does not mean that it is currently
                										selected. That information can be found in the SLVSEL
                										flag.</description>
                <name>NOT_DESELECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deselected. The Slave function has become
                										deselected. This is specifically caused by the SLVSEL flag
                										changing from 1 to 0. See the description of SLVSEL for
                										details on when that event occurs.</description>
                <name>DESELECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready. This flag is cleared when the MONRXDAT
            								register is read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No data. The Monitor function does not currently
                										have data available.</description>
                <name>NO_DATA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data waiting. The Monitor function has data waiting
                										to be read.</description>
                <name>DATA_WAITING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No overrun. Monitor data has not
                										overrun.</description>
                <name>NO_OVERRUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Overrun. A Monitor data overrun has occurred. This
                										can only happen when Monitor clock stretching not enabled
                										via the MONCLKSTR bit in the CFG register. Writing 1 to this
                										bit clears the flag.</description>
                <name>OVERRUN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Active flag. Indicates when the Monitor function
            								considers the I 2C bus to be active. Active is defined here as when
            								some Master is on the bus: a bus Start has occurred more recently
            								than a bus Stop.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. The Monitor function considers the I2C
                										bus to be inactive.</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active. The Monitor function considers the I2C bus
                										to be active.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag. This flag is set when the Monitor
            								function sees the I2C bus change from active to inactive. This can
            								be used by software to decide when to process data accumulated by
            								the Monitor function. This flag will cause an interrupt when set if
            								enabled via the INTENSET register. The flag can be cleared by
            								writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not idle. The I2C bus is not idle, or this flag has
                										been cleared by software.</description>
                <name>NOT_IDLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The I2C bus has gone idle at least once since
                										the last time this flag was cleared by
                										software.</description>
                <name>IDLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event Time-out Interrupt flag. Indicates when the time
            								between events has been longer than the time specified by the
            								TIMEOUT register. Events include Start, Stop, and clock edges. The
            								flag is cleared by writing a 1 to this bit. No time-out is created
            								when the I2C-bus is idle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. I2C bus events have not caused a
                										time-out.</description>
                <name>NO_TIME_OUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event time-out. The time between I2C bus events has
                										been longer than the time specified by the I2C TIMEOUT
                										register.</description>
                <name>EVENT_TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL Time-out Interrupt flag. Indicates when SCL has
            								remained low longer than the time specific by the TIMEOUT register.
            								The flag is cleared by writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. SCL low time has not caused a
                										time-out.</description>
                <name>NO_TIME_OUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Time-out. SCL low time has caused a
                										time-out.</description>
                <name>TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x801</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Interrupt Enable Set and read register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstPending interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstPending interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstArbLoss interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstArbLoss interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstStStpErr interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstStStpErr interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvPending interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvPending interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvNotStr interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvNotStr interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvDeSel interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvDeSel interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESELEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonRdy interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonRdy interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonOv interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonOv interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonIdle interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonIdle interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The Event time-out interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Event time-out interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SCL time-out interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SCL time-out interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUTEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable Clear register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt clear. Writing 1 to this bit
            								clears the corresponding bit in the INTENSET register if
            								implemented.</description>
            <name>MSTPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt clear.</description>
            <name>MSTARBLOSSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt clear.</description>
            <name>MSTSTSTPERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt clear.</description>
            <name>SLVPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt clear.</description>
            <name>SLVNOTSTRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt clear.</description>
            <name>SLVDESELCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt clear.</description>
            <name>MONRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt clear.</description>
            <name>MONOVCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt clear.</description>
            <name>MONIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out interrupt clear.</description>
            <name>EVENTTIMEOUTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out interrupt clear.</description>
            <name>SCLTIMEOUTCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Time-out value register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Time-out time value, bottom four bits. These are hard-wired
            								to 0xF. This gives a minimum time-out of 16 I2C function clocks and
            								also a time-out resolution of 16 I2C function clocks.</description>
            <name>TOMIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Time-out time value. Specifies the time-out interval value
            								in increments of 16 I2C function clocks, as defined by the CLKDIV
            								register. To change this value while I 2C is in operation, disable
            								all time-outs, write a new value to TIMEOUT, then re-enable
            								time-outs. 0x000 = A time-out will occur after 16 counts of the I2C
            								function clock. 0x001 = A time-out will occur after 32 counts of the
            								I2C function clock. ... 0xFFF = A time-out will occur after 65,536
            								counts of the I2C function clock.</description>
            <name>TO</name>
          </field>
        </fields>
        <name>TIMEOUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Clock pre-divider for the entire I2C block. This determines what
        						time increments are used for the MSTTIME register, and controls some timing
        						of the Slave function.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This field controls how the clock (PCLK) is used by the I2C
            								functions that need an internal clock in order to operate. 0x0000 =
            								PCLK is used directly by the I2C. 0x0001 = PCLK is divided by 2
            								before use. 0x0002 = PCLK is divided by 3 before use. ... 0xFFFF =
            								PCLK is divided by 65,536 before use.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Status register for Master, Slave, and Monitor
        						functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending.</description>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag.</description>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag.</description>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending.</description>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching status.</description>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag.</description>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready.</description>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag.</description>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out Interrupt flag.</description>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out Interrupt flag.</description>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Master control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Continue. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Master function to continue
                										to the next operation. This must done after writing transmit
                										data, reading received data, or any other housekeeping
                										related to the next bus operation.</description>
                <name>CONTINUE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTCONTINUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start. A Start will be generated on the I2C bus at
                										the next allowed time.</description>
                <name>START</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Stop control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stop. A Stop will be generated on the I2C bus at
                										the next allowed time, preceded by a NACK to the slave if
                										the master is receiving data from the slave (Master Receiver
                										mode).</description>
                <name>STOP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master DMA enable. Data operations of the I2C can be
            								performed with DMA. Protocol type operations such as Start, address,
            								Stop, and address match must always be done with software, typically
            								via an interrupt. When a DMA data transfer is complete, MSTDMA must
            								be cleared prior to beginning the next operation, typically a Start
            								or Stop.This bit is read/write.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. No DMA requests are generated for master
                										operation.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. A DMA request is generated for I2C master
                										data operations. When this I2C master is generating
                										Acknowledge bits in Master Receiver mode, the acknowledge is
                										generated automatically.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTDMA</name>
          </field>
        </fields>
        <name>MSTCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Master timing configuration.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL Low time. Specifies the minimum low time that
            								will be asserted by this master on SCL. Other devices on the bus
            								(masters or slaves) could lengthen this time. This corresponds to
            								the parameter tLOW in the I2C bus specification. I2C bus
            								specification parameters tBUF and t SU;STA have the same values and
            								are also controlled by MSTSCLLOW.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL low time is 2 clocks of the
                										I2C clock pre-divider.</description>
                <name>2_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL low time is 3 clocks of the
                										I2C clock pre-divider.</description>
                <name>3_CLOCKS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL low time is 4 clocks of the
                										I2C clock pre-divider.</description>
                <name>4_CLOCKS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL low time is 5 clocks of the
                										I2C clock pre-divider.</description>
                <name>5_CLOCKS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL low time is 6 clocks of the
                										I2C clock pre-divider.</description>
                <name>6_CLOCKS</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL low time is 7 clocks of the
                										I2C clock pre-divider.</description>
                <name>7_CLOCKS</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL low time is 8 clocks of the
                										I2C clock pre-divider.</description>
                <name>8_CLOCKS</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL low time is 9 clocks of the
                										I2C clock pre-divider.</description>
                <name>9_CLOCKS</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL High time. Specifies the minimum high time that
            								will be asserted by this master on SCL. Other masters in a
            								multi-master system could shorten this time. This corresponds to the
            								parameter tHIGH in the I2C bus specification. I2C bus specification
            								parameters tSU;STO and tHD;STA have the same values and are also
            								controlled by MSTSCLHIGH.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL high time is 2 clock of the
                										I2C clock pre-divider.</description>
                <name>2_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL high time is 3 clocks of the
                										I2C clock pre-divider .</description>
                <name>3_CLOCKS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL high time is 4 clock of the
                										I2C clock pre-divider.</description>
                <name>4_CLOCKS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL high time is 5 clock of the
                										I2C clock pre-divider.</description>
                <name>5_CLOCKS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL high time is 6 clock of the
                										I2C clock pre-divider.</description>
                <name>6_CLOCKS</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL high time is 7 clock of the
                										I2C clock pre-divider.</description>
                <name>7_CLOCKS</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL high time is 8 clock of the
                										I2C clock pre-divider.</description>
                <name>8_CLOCKS</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL high time is 9 clocks of the
                										I2C clock pre-divider.</description>
                <name>9_CLOCKS</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLHIGH</name>
          </field>
        </fields>
        <name>MSTTIME</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x77</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Combined Master receiver and transmitter data
        						register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Master function data register. Read: read the most recently
            								received data for the Master function. Write: transmit data using
            								the Master function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>MSTDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Slave control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Continue.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Slave function to continue to
                										the next operation. This must be done after writing transmit
                										data, reading received data, or any other housekeeping
                										related to the next bus operation.</description>
                <name>CONTINUE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVCONTINUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave NACK.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK. Causes the Slave function to NACK the master
                										when the slave is receiving data from the master (Slave
                										Receiver mode).</description>
                <name>NACK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave DMA enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No DMA requests are issued for Slave mode
                										operation.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. DMA requests are issued for I2C slave data
                										transmission and reception.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDMA</name>
          </field>
        </fields>
        <name>SLVCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Combined Slave receiver and transmitter data
        						register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave function data register. Read: read the most recently
            								received data for the Slave function. Write: transmit data using the
            								Slave function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>SLVDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Slave Qualification for address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Qualify mode for slave address 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mask. The SLVQUAL0 field is used as a logical mask
                										for matching address 0.</description>
                <name>MASK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Extend. The SLVQUAL0 field is used to extend
                										address 0 matching in a range of addresses.</description>
                <name>EXTEND</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>QUALMODE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave address Qualifier for address 0. A value of 0 causes
            								the address in SLVADR0 to be used as-is, assuming that it is
            								enabled. If QUALMODE0 = 0, any bit in this field which is set to 1
            								will cause an automatic match of the corresponding bit of the
            								received address when it is compared to the SLVADR0 register. If
            								QUALMODE0 = 1, an address range is matched for address 0. This range
            								extends from the value defined by SLVADR0 to the address defined by
            								SLVQUAL0 (address matches when SLVADR0[7:1] &lt;= received address
            								&lt;= SLVQUAL0[7:1]).</description>
            <name>SLVQUAL0</name>
          </field>
        </fields>
        <name>SLVQUAL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>Monitor receiver data register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Monitor function Receiver Data. This reflects every data
            								byte that passes on the I2C pins.</description>
            <name>MONRXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No start detected. The monitor function has not
                										detected a Start event on the I2C bus.</description>
                <name>NO_START_DETECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start detected. The monitor function has detected a
                										Start event on the I2C bus.</description>
                <name>START_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Repeated Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No repeated start detected. The monitor function
                										has not detected a Repeated Start event on the I2C
                										bus.</description>
                <name>NO_REPEATED_START_DE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeated start detected. The monitor function has
                										detected a Repeated Start event on the I2C
                										bus.</description>
                <name>REPEATED_START_DETEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRESTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received NACK.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Acknowledged. The data currently being provided by
                										the monitor function was acknowledged by at least one master
                										or slave receiver.</description>
                <name>ACKNOWLEDGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not acknowledged. The data currently being provided
                										by the monitor function was not acknowledged by any
                										receiver.</description>
                <name>NOT_ACKNOWLEDGED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONNACK</name>
          </field>
        </fields>
        <name>MONRXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40098000</baseAddress>
    <derivedFrom>I2C0</derivedFrom>
    <description>I2C-bus interface 1</description>
    <groupName>I2C0</groupName>
    <interrupts>
      <interrupt>
        <name>I2C1</name>
        <value>0x16</value>
      </interrupt>
    </interrupts>
    <name>I2C1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Configuration for shared functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Enable. When disabled, configurations settings for
            								the Master function are not changed, but the Master function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C Master function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C Master function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Enable. When disabled, configurations settings for
            								the Slave function are not changed, but the Slave function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C slave function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C slave function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Enable. When disabled, configurations settings for
            								the Monitor function are not changed, but the Monitor function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C monitor function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C monitor function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus Time-out Enable. When disabled, the time-out
            								function is internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Time-out function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Time-out function is enabled. Both types
                										of time-out flags will be generated and will cause
                										interrupts if they are enabled. Typically, only one time-out
                										will be used in a system.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor function Clock Stretching.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The monitor function will not perform
                										clock stretching. Software or DMA may not always be able to
                										read data provided by the monitor function before it is
                										overwritten. This mode may be used when non-invasive
                										monitoring is critical.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The monitor function will perform clock
                										stretching in order to ensure that software or DMA can read
                										all incoming data supplied by the monitor
                										function.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONCLKSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>High-speed mode Capable enable. Since High Speed mode
            								alters the way I2C pins drive and filter, as well as the timing for
            								certain I2C signalling, enabling High-speed mode applies to all
            								functions: master, slave, and monitor.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast-mode plus. The I2C block will support
                										Standard-mode, Fast-mode, and Fast-mode Plus, to the extent
                										that the pin electronics support these modes. Any changes
                										that need to be made to the pin controls, such as changing
                										the drive strength or filtering, must be made by software
                										via the IOCON register associated with each I2C
                										pin,</description>
                <name>FAST_MODE_PLUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High-speed. In addition to Standard-mode,
                										Fast-mode, and Fast-mode Plus, the I 2C block will support
                										High-speed mode to the extent that the pin electronics
                										support these modes. See Section 23.7.1.2 for more
                										information.</description>
                <name>HIGH_SPEED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HSCAPABLE</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Status register for Master, Slave, and Monitor
        						functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending. Indicates that the Master is waiting to
            								continue communication on the I2C-bus (pending) or is idle. When the
            								master is pending, the MSTSTATE bits indicate what type of software
            								service if any the master expects. This flag will cause an interrupt
            								when set if, enabled via the INTENSET register. The MSTPENDING flag
            								is not set when the DMA is handling an event (if the MSTDMA bit in
            								the MSTCTL register is set). If the master is in the idle state, and
            								no communication is needed, mask this interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>In progress. Communication is in progress and the
                										Master function is busy and cannot currently accept a
                										command.</description>
                <name>IN_PROGRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. The Master function needs software service
                										or is in the idle state. If the master is not in the idle
                										state, it is waiting to receive or transmit data or the NACK
                										bit.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master State code. The master state code reflects the
            								master state when the MSTPENDING bit is set, that is the master is
            								pending or in the idle state. Each value of this field indicates a
            								specific required service for the Master function. All other values
            								are reserved. See Table 346 for details of state values and
            								appropriate responses.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The Master function is available to be used
                										for a new transaction.</description>
                <name>IDLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Receive ready. Received data available (Master
                										Receiver mode). Address plus Read was previously sent and
                										Acknowledged by slave.</description>
                <name>RECEIVE_READY</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transmit ready. Data can be transmitted (Master
                										Transmitter mode). Address plus Write was previously sent
                										and Acknowledged by slave.</description>
                <name>TRANSMIT_READY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK Address. Slave NACKed address.</description>
                <name>NACK_ADDRESS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK Data. Slave NACKed transmitted
                										data.</description>
                <name>NACK_DATA</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag. This flag can be cleared by
            								software writing a 1 to this bit. It is also cleared automatically a
            								1 is written to MSTCONTINUE.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No Arbitration Loss has occurred.</description>
                <name>NO_ARBITRATION_LOSS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Arbitration loss. The Master function has
                										experienced an Arbitration Loss. At this point, the Master
                										function has already stopped driving the bus and gone to an
                										idle state. Software can respond by doing nothing, or by
                										sending a Start in order to attempt to gain control of the
                										bus when it next becomes idle.</description>
                <name>ARBITRATION_LOSS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag. This flag can be cleared by
            								software writing a 1 to this bit. It is also cleared automatically a
            								1 is written to MSTCONTINUE.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No Start/Stop Error has occurred.</description>
                <name>NO_STARTSTOP_ERROR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Master function has experienced a Start/Stop
                										Error. A Start or Stop was detected at a time when it is not
                										allowed by the I2C specification. The Master interface has
                										stopped driving the bus and gone to an idle state, no action
                										is required. A request for a Start could be made, or
                										software could attempt to insure that the bus has not
                										stalled.</description>
                <name>THE_MASTER_FUNCTION</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending. Indicates that the Slave function is waiting
            								to continue communication on the I2C-bus and needs software service.
            								This flag will cause an interrupt when set if enabled via INTENSET.
            								The SLVPENDING flag is not set when the DMA is handling an event (if
            								the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag
            								is read-only and is automatically cleared when a 1 is written to the
            								SLVCONTINUE bit in the MSTCTL register. The point in time when
            								SlvPending is set depends on whether the I2C block is in HSCAPABLE
            								mode. See Section 23.7.1.2.2. When the I2C block is configured to be
            								HSCAPABLE, HS master codes are detected automatically. Due to the
            								requirements of the HS I2C specification, slave addresses must also
            								be detected automatically, since the address must be acknowledged
            								before the clock can be stretched.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>In progress. The Slave function does not currently
                										need service.</description>
                <name>IN_PROGRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. The Slave function needs service.
                										Information on what is needed can be found in the adjacent
                										SLVSTATE field.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave State code. Each value of this field indicates a
            								specific required service for the Slave function. All other values
            								are reserved. See Table 347 for state values and
            								actions.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave address. Address plus R/W received. At least
                										one of the four slave addresses has been matched by
                										hardware.</description>
                <name>SLAVE_ADDRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave receive. Received data is available (Slave
                										Receiver mode).</description>
                <name>SLAVE_RECEIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave transmit. Data can be transmitted (Slave
                										Transmitter mode).</description>
                <name>SLAVE_TRANSMIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching. Indicates when the slave function is
            								stretching the I2C clock. This is needed in order to gracefully
            								invoke Deep Sleep or Power-down modes during slave operation. This
            								read-only flag reflects the slave function status in real
            								time.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stretching. The slave function is currently
                										stretching the I2C bus clock. Deep-Sleep or Power-down mode
                										cannot be entered at this time.</description>
                <name>STRETCHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not stretching. The slave function is not currently
                										stretching the I 2C bus clock. Deep-sleep or Power-down mode
                										could be entered at this time.</description>
                <name>NOT_STRETCHING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave address match Index. This field is valid when the I2C
            								slave function has been selected by receiving an address that
            								matches one of the slave addresses defined by any enabled slave
            								address registers, and provides an identification of the address
            								that was matched. It is possible that more than one address could be
            								matched, but only one match can be reported here.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 0. Slave address 0 was
                										matched.</description>
                <name>ADDRESS_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 1. Slave address 1 was
                										matched.</description>
                <name>ADDRESS_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 2. Slave address 2 was
                										matched.</description>
                <name>ADDRESS_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 3. Slave address 3 was
                										matched.</description>
                <name>ADDRESS_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVIDX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave selected flag. SLVSEL is set after an address match
            								when software tells the Slave function to acknowledge the address.
            								It is cleared when another address cycle presents an address that
            								does not match an enabled address on the Slave function, when slave
            								software decides to NACK a matched address, or when there is a Stop
            								detected on the bus. SLVSEL is not cleared if software NACKs
            								data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not selected. The Slave function is not currently
                										selected.</description>
                <name>NOT_SELECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selected. The Slave function is currently
                										selected.</description>
                <name>SELECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag. This flag will cause an interrupt
            								when set if enabled via INTENSET. This flag can be cleared by
            								writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not deselected. The Slave function has not become
                										deselected. This does not mean that it is currently
                										selected. That information can be found in the SLVSEL
                										flag.</description>
                <name>NOT_DESELECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deselected. The Slave function has become
                										deselected. This is specifically caused by the SLVSEL flag
                										changing from 1 to 0. See the description of SLVSEL for
                										details on when that event occurs.</description>
                <name>DESELECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready. This flag is cleared when the MONRXDAT
            								register is read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No data. The Monitor function does not currently
                										have data available.</description>
                <name>NO_DATA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data waiting. The Monitor function has data waiting
                										to be read.</description>
                <name>DATA_WAITING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No overrun. Monitor data has not
                										overrun.</description>
                <name>NO_OVERRUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Overrun. A Monitor data overrun has occurred. This
                										can only happen when Monitor clock stretching not enabled
                										via the MONCLKSTR bit in the CFG register. Writing 1 to this
                										bit clears the flag.</description>
                <name>OVERRUN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Active flag. Indicates when the Monitor function
            								considers the I 2C bus to be active. Active is defined here as when
            								some Master is on the bus: a bus Start has occurred more recently
            								than a bus Stop.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. The Monitor function considers the I2C
                										bus to be inactive.</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active. The Monitor function considers the I2C bus
                										to be active.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag. This flag is set when the Monitor
            								function sees the I2C bus change from active to inactive. This can
            								be used by software to decide when to process data accumulated by
            								the Monitor function. This flag will cause an interrupt when set if
            								enabled via the INTENSET register. The flag can be cleared by
            								writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not idle. The I2C bus is not idle, or this flag has
                										been cleared by software.</description>
                <name>NOT_IDLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The I2C bus has gone idle at least once since
                										the last time this flag was cleared by
                										software.</description>
                <name>IDLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event Time-out Interrupt flag. Indicates when the time
            								between events has been longer than the time specified by the
            								TIMEOUT register. Events include Start, Stop, and clock edges. The
            								flag is cleared by writing a 1 to this bit. No time-out is created
            								when the I2C-bus is idle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. I2C bus events have not caused a
                										time-out.</description>
                <name>NO_TIME_OUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event time-out. The time between I2C bus events has
                										been longer than the time specified by the I2C TIMEOUT
                										register.</description>
                <name>EVENT_TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL Time-out Interrupt flag. Indicates when SCL has
            								remained low longer than the time specific by the TIMEOUT register.
            								The flag is cleared by writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. SCL low time has not caused a
                										time-out.</description>
                <name>NO_TIME_OUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Time-out. SCL low time has caused a
                										time-out.</description>
                <name>TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x801</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Interrupt Enable Set and read register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstPending interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstPending interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstArbLoss interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstArbLoss interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstStStpErr interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstStStpErr interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvPending interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvPending interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvNotStr interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvNotStr interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvDeSel interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvDeSel interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESELEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonRdy interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonRdy interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonOv interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonOv interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonIdle interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonIdle interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The Event time-out interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Event time-out interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SCL time-out interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SCL time-out interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUTEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable Clear register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt clear. Writing 1 to this bit
            								clears the corresponding bit in the INTENSET register if
            								implemented.</description>
            <name>MSTPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt clear.</description>
            <name>MSTARBLOSSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt clear.</description>
            <name>MSTSTSTPERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt clear.</description>
            <name>SLVPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt clear.</description>
            <name>SLVNOTSTRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt clear.</description>
            <name>SLVDESELCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt clear.</description>
            <name>MONRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt clear.</description>
            <name>MONOVCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt clear.</description>
            <name>MONIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out interrupt clear.</description>
            <name>EVENTTIMEOUTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out interrupt clear.</description>
            <name>SCLTIMEOUTCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Time-out value register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Time-out time value, bottom four bits. These are hard-wired
            								to 0xF. This gives a minimum time-out of 16 I2C function clocks and
            								also a time-out resolution of 16 I2C function clocks.</description>
            <name>TOMIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Time-out time value. Specifies the time-out interval value
            								in increments of 16 I2C function clocks, as defined by the CLKDIV
            								register. To change this value while I 2C is in operation, disable
            								all time-outs, write a new value to TIMEOUT, then re-enable
            								time-outs. 0x000 = A time-out will occur after 16 counts of the I2C
            								function clock. 0x001 = A time-out will occur after 32 counts of the
            								I2C function clock. ... 0xFFF = A time-out will occur after 65,536
            								counts of the I2C function clock.</description>
            <name>TO</name>
          </field>
        </fields>
        <name>TIMEOUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Clock pre-divider for the entire I2C block. This determines what
        						time increments are used for the MSTTIME register, and controls some timing
        						of the Slave function.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This field controls how the clock (PCLK) is used by the I2C
            								functions that need an internal clock in order to operate. 0x0000 =
            								PCLK is used directly by the I2C. 0x0001 = PCLK is divided by 2
            								before use. 0x0002 = PCLK is divided by 3 before use. ... 0xFFFF =
            								PCLK is divided by 65,536 before use.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Status register for Master, Slave, and Monitor
        						functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending.</description>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag.</description>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag.</description>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending.</description>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching status.</description>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag.</description>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready.</description>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag.</description>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out Interrupt flag.</description>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out Interrupt flag.</description>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Master control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Continue. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Master function to continue
                										to the next operation. This must done after writing transmit
                										data, reading received data, or any other housekeeping
                										related to the next bus operation.</description>
                <name>CONTINUE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTCONTINUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start. A Start will be generated on the I2C bus at
                										the next allowed time.</description>
                <name>START</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Stop control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stop. A Stop will be generated on the I2C bus at
                										the next allowed time, preceded by a NACK to the slave if
                										the master is receiving data from the slave (Master Receiver
                										mode).</description>
                <name>STOP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master DMA enable. Data operations of the I2C can be
            								performed with DMA. Protocol type operations such as Start, address,
            								Stop, and address match must always be done with software, typically
            								via an interrupt. When a DMA data transfer is complete, MSTDMA must
            								be cleared prior to beginning the next operation, typically a Start
            								or Stop.This bit is read/write.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. No DMA requests are generated for master
                										operation.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. A DMA request is generated for I2C master
                										data operations. When this I2C master is generating
                										Acknowledge bits in Master Receiver mode, the acknowledge is
                										generated automatically.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTDMA</name>
          </field>
        </fields>
        <name>MSTCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Master timing configuration.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL Low time. Specifies the minimum low time that
            								will be asserted by this master on SCL. Other devices on the bus
            								(masters or slaves) could lengthen this time. This corresponds to
            								the parameter tLOW in the I2C bus specification. I2C bus
            								specification parameters tBUF and t SU;STA have the same values and
            								are also controlled by MSTSCLLOW.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL low time is 2 clocks of the
                										I2C clock pre-divider.</description>
                <name>2_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL low time is 3 clocks of the
                										I2C clock pre-divider.</description>
                <name>3_CLOCKS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL low time is 4 clocks of the
                										I2C clock pre-divider.</description>
                <name>4_CLOCKS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL low time is 5 clocks of the
                										I2C clock pre-divider.</description>
                <name>5_CLOCKS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL low time is 6 clocks of the
                										I2C clock pre-divider.</description>
                <name>6_CLOCKS</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL low time is 7 clocks of the
                										I2C clock pre-divider.</description>
                <name>7_CLOCKS</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL low time is 8 clocks of the
                										I2C clock pre-divider.</description>
                <name>8_CLOCKS</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL low time is 9 clocks of the
                										I2C clock pre-divider.</description>
                <name>9_CLOCKS</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL High time. Specifies the minimum high time that
            								will be asserted by this master on SCL. Other masters in a
            								multi-master system could shorten this time. This corresponds to the
            								parameter tHIGH in the I2C bus specification. I2C bus specification
            								parameters tSU;STO and tHD;STA have the same values and are also
            								controlled by MSTSCLHIGH.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL high time is 2 clock of the
                										I2C clock pre-divider.</description>
                <name>2_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL high time is 3 clocks of the
                										I2C clock pre-divider .</description>
                <name>3_CLOCKS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL high time is 4 clock of the
                										I2C clock pre-divider.</description>
                <name>4_CLOCKS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL high time is 5 clock of the
                										I2C clock pre-divider.</description>
                <name>5_CLOCKS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL high time is 6 clock of the
                										I2C clock pre-divider.</description>
                <name>6_CLOCKS</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL high time is 7 clock of the
                										I2C clock pre-divider.</description>
                <name>7_CLOCKS</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL high time is 8 clock of the
                										I2C clock pre-divider.</description>
                <name>8_CLOCKS</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL high time is 9 clocks of the
                										I2C clock pre-divider.</description>
                <name>9_CLOCKS</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLHIGH</name>
          </field>
        </fields>
        <name>MSTTIME</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x77</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Combined Master receiver and transmitter data
        						register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Master function data register. Read: read the most recently
            								received data for the Master function. Write: transmit data using
            								the Master function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>MSTDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Slave control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Continue.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Slave function to continue to
                										the next operation. This must be done after writing transmit
                										data, reading received data, or any other housekeeping
                										related to the next bus operation.</description>
                <name>CONTINUE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVCONTINUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave NACK.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK. Causes the Slave function to NACK the master
                										when the slave is receiving data from the master (Slave
                										Receiver mode).</description>
                <name>NACK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave DMA enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No DMA requests are issued for Slave mode
                										operation.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. DMA requests are issued for I2C slave data
                										transmission and reception.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDMA</name>
          </field>
        </fields>
        <name>SLVCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Combined Slave receiver and transmitter data
        						register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave function data register. Read: read the most recently
            								received data for the Slave function. Write: transmit data using the
            								Slave function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>SLVDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Slave Qualification for address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Qualify mode for slave address 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mask. The SLVQUAL0 field is used as a logical mask
                										for matching address 0.</description>
                <name>MASK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Extend. The SLVQUAL0 field is used to extend
                										address 0 matching in a range of addresses.</description>
                <name>EXTEND</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>QUALMODE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave address Qualifier for address 0. A value of 0 causes
            								the address in SLVADR0 to be used as-is, assuming that it is
            								enabled. If QUALMODE0 = 0, any bit in this field which is set to 1
            								will cause an automatic match of the corresponding bit of the
            								received address when it is compared to the SLVADR0 register. If
            								QUALMODE0 = 1, an address range is matched for address 0. This range
            								extends from the value defined by SLVADR0 to the address defined by
            								SLVQUAL0 (address matches when SLVADR0[7:1] &lt;= received address
            								&lt;= SLVQUAL0[7:1]).</description>
            <name>SLVQUAL0</name>
          </field>
        </fields>
        <name>SLVQUAL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>Monitor receiver data register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Monitor function Receiver Data. This reflects every data
            								byte that passes on the I2C pins.</description>
            <name>MONRXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No start detected. The monitor function has not
                										detected a Start event on the I2C bus.</description>
                <name>NO_START_DETECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start detected. The monitor function has detected a
                										Start event on the I2C bus.</description>
                <name>START_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Repeated Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No repeated start detected. The monitor function
                										has not detected a Repeated Start event on the I2C
                										bus.</description>
                <name>NO_REPEATED_START_DE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeated start detected. The monitor function has
                										detected a Repeated Start event on the I2C
                										bus.</description>
                <name>REPEATED_START_DETEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRESTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received NACK.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Acknowledged. The data currently being provided by
                										the monitor function was acknowledged by at least one master
                										or slave receiver.</description>
                <name>ACKNOWLEDGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not acknowledged. The data currently being provided
                										by the monitor function was not acknowledged by any
                										receiver.</description>
                <name>NOT_ACKNOWLEDGED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONNACK</name>
          </field>
        </fields>
        <name>MONRXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4009C000</baseAddress>
    <derivedFrom>I2C0</derivedFrom>
    <description>I2C-bus interface 2</description>
    <groupName>I2C0</groupName>
    <interrupts>
      <interrupt>
        <name>I2C2</name>
        <value>0x17</value>
      </interrupt>
    </interrupts>
    <name>I2C2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Configuration for shared functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Enable. When disabled, configurations settings for
            								the Master function are not changed, but the Master function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C Master function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C Master function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Enable. When disabled, configurations settings for
            								the Slave function are not changed, but the Slave function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C slave function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C slave function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Enable. When disabled, configurations settings for
            								the Monitor function are not changed, but the Monitor function is
            								internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C monitor function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C monitor function is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus Time-out Enable. When disabled, the time-out
            								function is internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Time-out function is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Time-out function is enabled. Both types
                										of time-out flags will be generated and will cause
                										interrupts if they are enabled. Typically, only one time-out
                										will be used in a system.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor function Clock Stretching.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The monitor function will not perform
                										clock stretching. Software or DMA may not always be able to
                										read data provided by the monitor function before it is
                										overwritten. This mode may be used when non-invasive
                										monitoring is critical.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The monitor function will perform clock
                										stretching in order to ensure that software or DMA can read
                										all incoming data supplied by the monitor
                										function.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONCLKSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>High-speed mode Capable enable. Since High Speed mode
            								alters the way I2C pins drive and filter, as well as the timing for
            								certain I2C signalling, enabling High-speed mode applies to all
            								functions: master, slave, and monitor.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast-mode plus. The I2C block will support
                										Standard-mode, Fast-mode, and Fast-mode Plus, to the extent
                										that the pin electronics support these modes. Any changes
                										that need to be made to the pin controls, such as changing
                										the drive strength or filtering, must be made by software
                										via the IOCON register associated with each I2C
                										pin,</description>
                <name>FAST_MODE_PLUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High-speed. In addition to Standard-mode,
                										Fast-mode, and Fast-mode Plus, the I 2C block will support
                										High-speed mode to the extent that the pin electronics
                										support these modes. See Section 23.7.1.2 for more
                										information.</description>
                <name>HIGH_SPEED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HSCAPABLE</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Status register for Master, Slave, and Monitor
        						functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending. Indicates that the Master is waiting to
            								continue communication on the I2C-bus (pending) or is idle. When the
            								master is pending, the MSTSTATE bits indicate what type of software
            								service if any the master expects. This flag will cause an interrupt
            								when set if, enabled via the INTENSET register. The MSTPENDING flag
            								is not set when the DMA is handling an event (if the MSTDMA bit in
            								the MSTCTL register is set). If the master is in the idle state, and
            								no communication is needed, mask this interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>In progress. Communication is in progress and the
                										Master function is busy and cannot currently accept a
                										command.</description>
                <name>IN_PROGRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. The Master function needs software service
                										or is in the idle state. If the master is not in the idle
                										state, it is waiting to receive or transmit data or the NACK
                										bit.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master State code. The master state code reflects the
            								master state when the MSTPENDING bit is set, that is the master is
            								pending or in the idle state. Each value of this field indicates a
            								specific required service for the Master function. All other values
            								are reserved. See Table 346 for details of state values and
            								appropriate responses.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The Master function is available to be used
                										for a new transaction.</description>
                <name>IDLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Receive ready. Received data available (Master
                										Receiver mode). Address plus Read was previously sent and
                										Acknowledged by slave.</description>
                <name>RECEIVE_READY</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transmit ready. Data can be transmitted (Master
                										Transmitter mode). Address plus Write was previously sent
                										and Acknowledged by slave.</description>
                <name>TRANSMIT_READY</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK Address. Slave NACKed address.</description>
                <name>NACK_ADDRESS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK Data. Slave NACKed transmitted
                										data.</description>
                <name>NACK_DATA</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag. This flag can be cleared by
            								software writing a 1 to this bit. It is also cleared automatically a
            								1 is written to MSTCONTINUE.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No Arbitration Loss has occurred.</description>
                <name>NO_ARBITRATION_LOSS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Arbitration loss. The Master function has
                										experienced an Arbitration Loss. At this point, the Master
                										function has already stopped driving the bus and gone to an
                										idle state. Software can respond by doing nothing, or by
                										sending a Start in order to attempt to gain control of the
                										bus when it next becomes idle.</description>
                <name>ARBITRATION_LOSS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag. This flag can be cleared by
            								software writing a 1 to this bit. It is also cleared automatically a
            								1 is written to MSTCONTINUE.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No Start/Stop Error has occurred.</description>
                <name>NO_STARTSTOP_ERROR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Master function has experienced a Start/Stop
                										Error. A Start or Stop was detected at a time when it is not
                										allowed by the I2C specification. The Master interface has
                										stopped driving the bus and gone to an idle state, no action
                										is required. A request for a Start could be made, or
                										software could attempt to insure that the bus has not
                										stalled.</description>
                <name>THE_MASTER_FUNCTION</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending. Indicates that the Slave function is waiting
            								to continue communication on the I2C-bus and needs software service.
            								This flag will cause an interrupt when set if enabled via INTENSET.
            								The SLVPENDING flag is not set when the DMA is handling an event (if
            								the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag
            								is read-only and is automatically cleared when a 1 is written to the
            								SLVCONTINUE bit in the MSTCTL register. The point in time when
            								SlvPending is set depends on whether the I2C block is in HSCAPABLE
            								mode. See Section 23.7.1.2.2. When the I2C block is configured to be
            								HSCAPABLE, HS master codes are detected automatically. Due to the
            								requirements of the HS I2C specification, slave addresses must also
            								be detected automatically, since the address must be acknowledged
            								before the clock can be stretched.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>In progress. The Slave function does not currently
                										need service.</description>
                <name>IN_PROGRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending. The Slave function needs service.
                										Information on what is needed can be found in the adjacent
                										SLVSTATE field.</description>
                <name>PENDING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave State code. Each value of this field indicates a
            								specific required service for the Slave function. All other values
            								are reserved. See Table 347 for state values and
            								actions.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave address. Address plus R/W received. At least
                										one of the four slave addresses has been matched by
                										hardware.</description>
                <name>SLAVE_ADDRESS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave receive. Received data is available (Slave
                										Receiver mode).</description>
                <name>SLAVE_RECEIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave transmit. Data can be transmitted (Slave
                										Transmitter mode).</description>
                <name>SLAVE_TRANSMIT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching. Indicates when the slave function is
            								stretching the I2C clock. This is needed in order to gracefully
            								invoke Deep Sleep or Power-down modes during slave operation. This
            								read-only flag reflects the slave function status in real
            								time.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stretching. The slave function is currently
                										stretching the I2C bus clock. Deep-Sleep or Power-down mode
                										cannot be entered at this time.</description>
                <name>STRETCHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not stretching. The slave function is not currently
                										stretching the I 2C bus clock. Deep-sleep or Power-down mode
                										could be entered at this time.</description>
                <name>NOT_STRETCHING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave address match Index. This field is valid when the I2C
            								slave function has been selected by receiving an address that
            								matches one of the slave addresses defined by any enabled slave
            								address registers, and provides an identification of the address
            								that was matched. It is possible that more than one address could be
            								matched, but only one match can be reported here.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 0. Slave address 0 was
                										matched.</description>
                <name>ADDRESS_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 1. Slave address 1 was
                										matched.</description>
                <name>ADDRESS_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 2. Slave address 2 was
                										matched.</description>
                <name>ADDRESS_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address 3. Slave address 3 was
                										matched.</description>
                <name>ADDRESS_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVIDX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave selected flag. SLVSEL is set after an address match
            								when software tells the Slave function to acknowledge the address.
            								It is cleared when another address cycle presents an address that
            								does not match an enabled address on the Slave function, when slave
            								software decides to NACK a matched address, or when there is a Stop
            								detected on the bus. SLVSEL is not cleared if software NACKs
            								data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not selected. The Slave function is not currently
                										selected.</description>
                <name>NOT_SELECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selected. The Slave function is currently
                										selected.</description>
                <name>SELECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag. This flag will cause an interrupt
            								when set if enabled via INTENSET. This flag can be cleared by
            								writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not deselected. The Slave function has not become
                										deselected. This does not mean that it is currently
                										selected. That information can be found in the SLVSEL
                										flag.</description>
                <name>NOT_DESELECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deselected. The Slave function has become
                										deselected. This is specifically caused by the SLVSEL flag
                										changing from 1 to 0. See the description of SLVSEL for
                										details on when that event occurs.</description>
                <name>DESELECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready. This flag is cleared when the MONRXDAT
            								register is read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No data. The Monitor function does not currently
                										have data available.</description>
                <name>NO_DATA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data waiting. The Monitor function has data waiting
                										to be read.</description>
                <name>DATA_WAITING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No overrun. Monitor data has not
                										overrun.</description>
                <name>NO_OVERRUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Overrun. A Monitor data overrun has occurred. This
                										can only happen when Monitor clock stretching not enabled
                										via the MONCLKSTR bit in the CFG register. Writing 1 to this
                										bit clears the flag.</description>
                <name>OVERRUN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Active flag. Indicates when the Monitor function
            								considers the I 2C bus to be active. Active is defined here as when
            								some Master is on the bus: a bus Start has occurred more recently
            								than a bus Stop.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. The Monitor function considers the I2C
                										bus to be inactive.</description>
                <name>INACTIVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active. The Monitor function considers the I2C bus
                										to be active.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag. This flag is set when the Monitor
            								function sees the I2C bus change from active to inactive. This can
            								be used by software to decide when to process data accumulated by
            								the Monitor function. This flag will cause an interrupt when set if
            								enabled via the INTENSET register. The flag can be cleared by
            								writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not idle. The I2C bus is not idle, or this flag has
                										been cleared by software.</description>
                <name>NOT_IDLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The I2C bus has gone idle at least once since
                										the last time this flag was cleared by
                										software.</description>
                <name>IDLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event Time-out Interrupt flag. Indicates when the time
            								between events has been longer than the time specified by the
            								TIMEOUT register. Events include Start, Stop, and clock edges. The
            								flag is cleared by writing a 1 to this bit. No time-out is created
            								when the I2C-bus is idle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. I2C bus events have not caused a
                										time-out.</description>
                <name>NO_TIME_OUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event time-out. The time between I2C bus events has
                										been longer than the time specified by the I2C TIMEOUT
                										register.</description>
                <name>EVENT_TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL Time-out Interrupt flag. Indicates when SCL has
            								remained low longer than the time specific by the TIMEOUT register.
            								The flag is cleared by writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. SCL low time has not caused a
                										time-out.</description>
                <name>NO_TIME_OUT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Time-out. SCL low time has caused a
                										time-out.</description>
                <name>TIME_OUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x801</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Interrupt Enable Set and read register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstPending interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstPending interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstArbLoss interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstArbLoss interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MstStStpErr interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MstStStpErr interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvPending interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvPending interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvNotStr interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvNotStr interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SlvDeSel interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SlvDeSel interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESELEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonRdy interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonRdy interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonOv interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonOv interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The MonIdle interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The MonIdle interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The Event time-out interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Event time-out interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SCL time-out interrupt is
                										disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SCL time-out interrupt is
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUTEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable Clear register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt clear. Writing 1 to this bit
            								clears the corresponding bit in the INTENSET register if
            								implemented.</description>
            <name>MSTPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt clear.</description>
            <name>MSTARBLOSSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt clear.</description>
            <name>MSTSTSTPERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt clear.</description>
            <name>SLVPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt clear.</description>
            <name>SLVNOTSTRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt clear.</description>
            <name>SLVDESELCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt clear.</description>
            <name>MONRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt clear.</description>
            <name>MONOVCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt clear.</description>
            <name>MONIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out interrupt clear.</description>
            <name>EVENTTIMEOUTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out interrupt clear.</description>
            <name>SCLTIMEOUTCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Time-out value register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Time-out time value, bottom four bits. These are hard-wired
            								to 0xF. This gives a minimum time-out of 16 I2C function clocks and
            								also a time-out resolution of 16 I2C function clocks.</description>
            <name>TOMIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Time-out time value. Specifies the time-out interval value
            								in increments of 16 I2C function clocks, as defined by the CLKDIV
            								register. To change this value while I 2C is in operation, disable
            								all time-outs, write a new value to TIMEOUT, then re-enable
            								time-outs. 0x000 = A time-out will occur after 16 counts of the I2C
            								function clock. 0x001 = A time-out will occur after 32 counts of the
            								I2C function clock. ... 0xFFF = A time-out will occur after 65,536
            								counts of the I2C function clock.</description>
            <name>TO</name>
          </field>
        </fields>
        <name>TIMEOUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Clock pre-divider for the entire I2C block. This determines what
        						time increments are used for the MSTTIME register, and controls some timing
        						of the Slave function.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This field controls how the clock (PCLK) is used by the I2C
            								functions that need an internal clock in order to operate. 0x0000 =
            								PCLK is used directly by the I2C. 0x0001 = PCLK is divided by 2
            								before use. 0x0002 = PCLK is divided by 3 before use. ... 0xFFFF =
            								PCLK is divided by 65,536 before use.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Status register for Master, Slave, and Monitor
        						functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending.</description>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag.</description>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag.</description>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending.</description>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching status.</description>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag.</description>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready.</description>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag.</description>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event time-out Interrupt flag.</description>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL time-out Interrupt flag.</description>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Master control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Continue. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Master function to continue
                										to the next operation. This must done after writing transmit
                										data, reading received data, or any other housekeeping
                										related to the next bus operation.</description>
                <name>CONTINUE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTCONTINUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start. A Start will be generated on the I2C bus at
                										the next allowed time.</description>
                <name>START</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Stop control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stop. A Stop will be generated on the I2C bus at
                										the next allowed time, preceded by a NACK to the slave if
                										the master is receiving data from the slave (Master Receiver
                										mode).</description>
                <name>STOP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master DMA enable. Data operations of the I2C can be
            								performed with DMA. Protocol type operations such as Start, address,
            								Stop, and address match must always be done with software, typically
            								via an interrupt. When a DMA data transfer is complete, MSTDMA must
            								be cleared prior to beginning the next operation, typically a Start
            								or Stop.This bit is read/write.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable. No DMA requests are generated for master
                										operation.</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable. A DMA request is generated for I2C master
                										data operations. When this I2C master is generating
                										Acknowledge bits in Master Receiver mode, the acknowledge is
                										generated automatically.</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTDMA</name>
          </field>
        </fields>
        <name>MSTCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Master timing configuration.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL Low time. Specifies the minimum low time that
            								will be asserted by this master on SCL. Other devices on the bus
            								(masters or slaves) could lengthen this time. This corresponds to
            								the parameter tLOW in the I2C bus specification. I2C bus
            								specification parameters tBUF and t SU;STA have the same values and
            								are also controlled by MSTSCLLOW.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL low time is 2 clocks of the
                										I2C clock pre-divider.</description>
                <name>2_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL low time is 3 clocks of the
                										I2C clock pre-divider.</description>
                <name>3_CLOCKS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL low time is 4 clocks of the
                										I2C clock pre-divider.</description>
                <name>4_CLOCKS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL low time is 5 clocks of the
                										I2C clock pre-divider.</description>
                <name>5_CLOCKS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL low time is 6 clocks of the
                										I2C clock pre-divider.</description>
                <name>6_CLOCKS</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL low time is 7 clocks of the
                										I2C clock pre-divider.</description>
                <name>7_CLOCKS</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL low time is 8 clocks of the
                										I2C clock pre-divider.</description>
                <name>8_CLOCKS</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL low time is 9 clocks of the
                										I2C clock pre-divider.</description>
                <name>9_CLOCKS</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL High time. Specifies the minimum high time that
            								will be asserted by this master on SCL. Other masters in a
            								multi-master system could shorten this time. This corresponds to the
            								parameter tHIGH in the I2C bus specification. I2C bus specification
            								parameters tSU;STO and tHD;STA have the same values and are also
            								controlled by MSTSCLHIGH.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL high time is 2 clock of the
                										I2C clock pre-divider.</description>
                <name>2_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL high time is 3 clocks of the
                										I2C clock pre-divider .</description>
                <name>3_CLOCKS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL high time is 4 clock of the
                										I2C clock pre-divider.</description>
                <name>4_CLOCKS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL high time is 5 clock of the
                										I2C clock pre-divider.</description>
                <name>5_CLOCKS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL high time is 6 clock of the
                										I2C clock pre-divider.</description>
                <name>6_CLOCKS</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL high time is 7 clock of the
                										I2C clock pre-divider.</description>
                <name>7_CLOCKS</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL high time is 8 clock of the
                										I2C clock pre-divider.</description>
                <name>8_CLOCKS</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL high time is 9 clocks of the
                										I2C clock pre-divider.</description>
                <name>9_CLOCKS</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLHIGH</name>
          </field>
        </fields>
        <name>MSTTIME</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x77</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Combined Master receiver and transmitter data
        						register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Master function data register. Read: read the most recently
            								received data for the Master function. Write: transmit data using
            								the Master function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>MSTDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Slave control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Continue.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Slave function to continue to
                										the next operation. This must be done after writing transmit
                										data, reading received data, or any other housekeeping
                										related to the next bus operation.</description>
                <name>CONTINUE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVCONTINUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave NACK.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NACK. Causes the Slave function to NACK the master
                										when the slave is receiving data from the master (Slave
                										Receiver mode).</description>
                <name>NACK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave DMA enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No DMA requests are issued for Slave mode
                										operation.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. DMA requests are issued for I2C slave data
                										transmission and reception.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDMA</name>
          </field>
        </fields>
        <name>SLVCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Combined Slave receiver and transmitter data
        						register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave function data register. Read: read the most recently
            								received data for the Slave function. Write: transmit data using the
            								Slave function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>SLVDAT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Slave Qualification for address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Qualify mode for slave address 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mask. The SLVQUAL0 field is used as a logical mask
                										for matching address 0.</description>
                <name>MASK</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Extend. The SLVQUAL0 field is used to extend
                										address 0 matching in a range of addresses.</description>
                <name>EXTEND</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>QUALMODE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave address Qualifier for address 0. A value of 0 causes
            								the address in SLVADR0 to be used as-is, assuming that it is
            								enabled. If QUALMODE0 = 0, any bit in this field which is set to 1
            								will cause an automatic match of the corresponding bit of the
            								received address when it is compared to the SLVADR0 register. If
            								QUALMODE0 = 1, an address range is matched for address 0. This range
            								extends from the value defined by SLVADR0 to the address defined by
            								SLVQUAL0 (address matches when SLVADR0[7:1] &lt;= received address
            								&lt;= SLVQUAL0[7:1]).</description>
            <name>SLVQUAL0</name>
          </field>
        </fields>
        <name>SLVQUAL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>Monitor receiver data register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Monitor function Receiver Data. This reflects every data
            								byte that passes on the I2C pins.</description>
            <name>MONRXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No start detected. The monitor function has not
                										detected a Start event on the I2C bus.</description>
                <name>NO_START_DETECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start detected. The monitor function has detected a
                										Start event on the I2C bus.</description>
                <name>START_DETECTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Repeated Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No repeated start detected. The monitor function
                										has not detected a Repeated Start event on the I2C
                										bus.</description>
                <name>NO_REPEATED_START_DE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeated start detected. The monitor function has
                										detected a Repeated Start event on the I2C
                										bus.</description>
                <name>REPEATED_START_DETEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRESTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received NACK.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Acknowledged. The data currently being provided by
                										the monitor function was acknowledged by at least one master
                										or slave receiver.</description>
                <name>ACKNOWLEDGED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not acknowledged. The data currently being provided
                										by the monitor function was not acknowledged by any
                										receiver.</description>
                <name>NOT_ACKNOWLEDGED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONNACK</name>
          </field>
        </fields>
        <name>MONRXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled.</description>
                <name>ENABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave Address. Seven bit slave address that is compared to
            								received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x400A4000</baseAddress>
    <description>SPI0</description>
    <groupName>SPI0</groupName>
    <interrupts>
      <interrupt>
        <name>SPI0</name>
        <value>0x18</value>
      </interrupt>
    </interrupts>
    <name>SPI0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SPI Configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SPI is disabled and the internal
                										state machine and counters are reset.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SPI is enabled for
                										operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master mode select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave mode. The SPI will operate in slave mode.
                										SCK, MOSI, and the SSEL signals are inputs, MISO is an
                										output.</description>
                <name>SLAVE_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master mode. The SPI will operate in master mode.
                										SCK, MOSI, and the SSEL signals are outputs, MISO is an
                										input.</description>
                <name>MASTER_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MASTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. Data is transmitted and received in
                										standard MSB first order.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reverse. Data is transmitted and received in
                										reverse order (LSB first).</description>
                <name>REVERSE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LSBF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Phase select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Change. The SPI captures serial data on the first
                										clock transition of the transfer (when the clock changes
                										away from the rest state). Data is changed on the following
                										edge.</description>
                <name>CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture. The SPI changes serial data on the first
                										clock transition of the transfer (when the clock changes
                										away from the rest state). Data is captured on the following
                										edge.</description>
                <name>CAPTURE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The rest state of the clock (between
                										transfers) is low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The rest state of the clock (between
                										transfers) is high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loopback mode enable. Loopback mode applies only to Master
            								mode, and connects transmit and receive data connected together to
            								allow simple software testing.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL0 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL0 pin is active low. The value in the
                										SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL0 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL0 pin is active high. The value in
                										the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL0 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL1 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL1 pin is active low. The value in the
                										SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL1 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL1 pin is active high. The value in
                										the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL1 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL2 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL2 pin is active low. The value in the
                										SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL2 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL2 pin is active high. The value in
                										the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL2 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL3 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL3 pin is active low. The value in the
                										SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL3 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL3 pin is active high. The value in
                										the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL3 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL3</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SPI Delay register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between SSEL assertion and the
            								beginning of a data transfer. There is always one SPI clock time
            								between SSEL assertion and the first clock edge. This is not
            								considered part of the pre-delay. 0x0 = No additional time is
            								inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock
            								times are inserted. ... 0xF = 15 SPI clock times are
            								inserted.</description>
            <name>PRE_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between the end of a data
            								transfer and SSEL deassertion. 0x0 = No additional time is inserted.
            								0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are
            								inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>POST_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>If the EOF flag is set, controls the minimum amount of time
            								between the current frame and the next frame (or SSEL deassertion if
            								EOT). 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time
            								is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI
            								clock times are inserted.</description>
            <name>FRAME_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the minimum amount of time that the SSEL is
            								deasserted between transfers. 0x0 = The minimum time that SSEL is
            								deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum
            								time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum
            								time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The
            								minimum time that SSEL is deasserted is 16 SPI clock
            								times.</description>
            <name>TRANSFER_DELAY</name>
          </field>
        </fields>
        <name>DLY</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SPI Status. Some status flags can be cleared by writing a 1 to that
        						bit position</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is
            								available to be read from the receiver buffer. Cleared after a read
            								of the RXDAT register.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that
            								data may be written to the transmit buffer. Previous data may still
            								be in the process of being transmitted. Cleared when data is written
            								to TXDAT or TXDATCTL until the data is moved to the transmit shift
            								register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag. This flag applies only to
            								slave mode (Master = 0). This flag is set when the beginning of a
            								received character is detected while the receiver buffer is still in
            								use. If this occurs, the receiver buffer contents are preserved, and
            								the incoming data is lost. Data received by the SPI should be
            								considered undefined if RxOv is set.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag. This flag applies only
            								to slave mode (Master = 0). In this case, the transmitter must begin
            								sending new data on the next input clock if the transmitter is idle.
            								If that data is not available in the transmitter holding register at
            								that point, there is no data to transmit and the TXUR flag is set.
            								Data transmitted by the SPI should be considered undefined if TXUR
            								is set.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert. This flag is set whenever any slave
            								select transitions from deasserted to asserted, in both master and
            								slave modes. This allows determining when the SPI transmit/receive
            								functions become busy, and allows waking up the device from reduced
            								power modes when a slave mode access begins. This flag is cleared by
            								software.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert. This flag is set whenever any
            								asserted slave selects transition to deasserted, in both master and
            								slave modes. This allows determining when the SPI transmit/receive
            								functions become idle. This flag is cleared by
            								software.</description>
            <name>SSD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stalled status flag. This indicates whether the SPI is
            								currently in a stall condition.</description>
            <name>STALLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End Transfer control bit. Software can set this bit to
            								force an end to the current transfer when the transmitter finishes
            								any activity already in progress, as if the EOT flag had been set
            								prior to the last transmission. This capability is included to
            								support cases where it is not known when transmit data is written
            								that it will be the end of a transfer. The bit is cleared when the
            								transmitter becomes idle as the transfer comes to an end. Forcing an
            								end of transfer in this manner causes any specified FRAME_DELAY and
            								TRANSFER_DELAY to be inserted.</description>
            <name>ENDTRANSFER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master idle status flag. This bit is 1 whenever the SPI
            								master function is fully idle. This means that the transmit holding
            								register is empty and the transmitter is not in the process of
            								sending data.</description>
            <name>MSTIDLE</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x102</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SPI Interrupt Enable read and Set. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX ready interrupt enable. Determines whether an interrupt
            								occurs when receiver data is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when
                										receiver data is available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when
                										receiver data is available in the RXDAT
                										register.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX ready interrupt enable. Determines whether an interrupt
            								occurs when the transmitter holding register is
            								available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when the
                										transmitter holding register is available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when data
                										may be written to TXDAT.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX overrun interrupt enable. Determines whether an
            								interrupt occurs when a receiver overrun occurs. This happens in
            								slave mode when there is a need for the receiver to move newly
            								received data to the RXDAT register when it is already in use. The
            								interface prevents receiver overrun in Master mode by not allowing a
            								new transmission to begin when a receiver overrun would otherwise
            								occur.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when a
                										receiver overrun occurs.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated if a
                										receiver overrun occurs.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX underrun interrupt enable. Determines whether an
            								interrupt occurs when a transmitter underrun occurs. This happens in
            								slave mode when there is a need to transmit data when none is
            								available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when the
                										transmitter underruns.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated if the
                										transmitter underruns.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave select assert interrupt enable. Determines whether an
            								interrupt occurs when the Slave Select is asserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when any
                										Slave Select transitions from deasserted to
                										asserted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when any
                										Slave Select transitions from deasserted to
                										asserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave select deassert interrupt enable. Determines whether
            								an interrupt occurs when the Slave Select is
            								deasserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when all
                										asserted Slave Selects transition to
                										deasserted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when all
                										asserted Slave Selects transition to
                										deasserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSDEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master idle interrupt enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when the
                										SPI master function is idle.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when the
                										SPI master function is idle.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTIDLEEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>SPI Interrupt Enable Clear. Writing a 1 to any implemented bit
        						position causes the corresponding bit in INTENSET to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>SSDEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the MSTIDLE
            								register.</description>
            <name>MSTIDLE</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>SPI Receive Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Receiver Data. This contains the next piece of received
            								data. The number of bits that are used depends on the LEN setting in
            								TXCTL / TXDATCTL.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL0 pin to be saved along with received data. The value will
            								reflect the SSEL0 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL1 pin to be saved along with received data. The value will
            								reflect the SSEL1 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL2 pin to be saved along with received data. The value will
            								reflect the SSEL2 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL3 pin to be saved along with received data. The value will
            								reflect the SSEL3 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start of Transfer flag. This flag will be 1 if this is the
            								first data after the SSELs went from deasserted to asserted (i.e.,
            								any previous transfer has ended). This information can be used to
            								identify the first piece of data in cases where the transfer length
            								is greater than 16 bit.</description>
            <name>SOT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>SPI Transmit Data with Control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 1 to 16 bits of
            								data to be transmitted.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL0 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL0 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL0 asserted.</description>
                <name>SSEL0_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL0 not asserted.</description>
                <name>SSEL0_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL1 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL1 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL1 asserted.</description>
                <name>SSEL1_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL1 not asserted.</description>
                <name>SSEL1_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL2 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL2 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL2 asserted.</description>
                <name>SSEL2_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL2 not asserted.</description>
                <name>SSEL2_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL3 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL3 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL3 asserted.</description>
                <name>SSEL3_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL3 not asserted.</description>
                <name>SSEL3_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer. The asserted SSEL will be deasserted at
            								the end of a transfer, and remain so for at least the time specified
            								by the Transfer_delay value in the DLY register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL not deasserted. This piece of data is not
                										treated as the end of a transfer. SSEL will not be
                										deasserted at the end of this data.</description>
                <name>SSEL_NOT_DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL deasserted. This piece of data is treated as
                										the end of a transfer. SSEL will be deasserted at the end of
                										this piece of data.</description>
                <name>SSEL_DEASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame. Between frames, a delay may be inserted, as
            								defined by the FRAME_DELAY value in the DLY register. The end of a
            								frame may not be particularly meaningful if the FRAME_DELAY value =
            								0. This control can be used as part of the support for frame lengths
            								greater than 16 bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data not EOF. This piece of data transmitted is not
                										treated as the end of a frame.</description>
                <name>DATA_NOT_EOF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data EOF. This piece of data is treated as the end
                										of a frame, causing the FRAME_DELAY time to be inserted
                										before subsequent data is transmitted.</description>
                <name>DATA_EOF</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore. This allows data to be transmitted using
            								the SPI without the need to read unneeded data from the
            								receiver.Setting this bit simplifies the transmit process and can be
            								used with the DMA.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read received data. Received data must be read in
                										order to allow transmission to progress. In slave mode, an
                										overrun error will occur if received data is not read before
                										new data is received.</description>
                <name>READ_RECEIVED_DATA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignore received data. Received data is ignored,
                										allowing transmission without reading unneeded received
                										data. No receiver flags are generated.</description>
                <name>IGNORE_RECEIVED_DATA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Length. Specifies the data length from 1 to 16 bits.
            								Note that transfer lengths greater than 16 bits are supported by
            								implementing multiple sequential transmits. 0x0 = Data transfer is 1
            								bit in length. 0x1 = Data transfer is 2 bits in length. 0x2 = Data
            								transfer is 3 bits in length. ... 0xF = Data transfer is 16 bits in
            								length.</description>
            <name>LEN</name>
          </field>
        </fields>
        <name>TXDATCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>SPI Transmit Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 4 to 16 bits of
            								data to be transmitted.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI Transmit Control</description>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 0.</description>
            <name>TXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 1.</description>
            <name>TXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 2.</description>
            <name>TXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 3.</description>
            <name>TXSSEL3_n</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer.</description>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame.</description>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore.</description>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data transfer Length.</description>
            <name>LEN</name>
          </field>
        </fields>
        <name>TXCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI clock Divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Rate divider value. Specifies how the PCLK for the SPI is
            								divided to produce the SPI clock rate in master mode. DIVVAL is -1
            								encoded such that the value 0 results in PCLK/1, the value 1 results
            								in PCLK/2, up to the maximum possible divide value of 0xFFFF, which
            								results in PCLK/65536.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>DIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>SPI Interrupt Status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert.</description>
            <name>SSD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Idle status flag.</description>
            <name>MSTIDLE</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x400A8000</baseAddress>
    <derivedFrom>SPI0</derivedFrom>
    <description>SPI1</description>
    <groupName>SPI0</groupName>
    <interrupts>
      <interrupt>
        <name>SPI1</name>
        <value>0x19</value>
      </interrupt>
    </interrupts>
    <name>SPI1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SPI Configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SPI is disabled and the internal
                										state machine and counters are reset.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SPI is enabled for
                										operation.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master mode select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave mode. The SPI will operate in slave mode.
                										SCK, MOSI, and the SSEL signals are inputs, MISO is an
                										output.</description>
                <name>SLAVE_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master mode. The SPI will operate in master mode.
                										SCK, MOSI, and the SSEL signals are outputs, MISO is an
                										input.</description>
                <name>MASTER_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MASTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. Data is transmitted and received in
                										standard MSB first order.</description>
                <name>STANDARD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reverse. Data is transmitted and received in
                										reverse order (LSB first).</description>
                <name>REVERSE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LSBF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Phase select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Change. The SPI captures serial data on the first
                										clock transition of the transfer (when the clock changes
                										away from the rest state). Data is changed on the following
                										edge.</description>
                <name>CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture. The SPI changes serial data on the first
                										clock transition of the transfer (when the clock changes
                										away from the rest state). Data is captured on the following
                										edge.</description>
                <name>CAPTURE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The rest state of the clock (between
                										transfers) is low.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The rest state of the clock (between
                										transfers) is high.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loopback mode enable. Loopback mode applies only to Master
            								mode, and connects transmit and receive data connected together to
            								allow simple software testing.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL0 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL0 pin is active low. The value in the
                										SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL0 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL0 pin is active high. The value in
                										the SSEL0 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL0 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL1 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL1 pin is active low. The value in the
                										SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL1 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL1 pin is active high. The value in
                										the SSEL1 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL1 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL2 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL2 pin is active low. The value in the
                										SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL2 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL2 pin is active high. The value in
                										the SSEL2 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL2 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL3 Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL3 pin is active low. The value in the
                										SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL3 is not inverted relative to the
                										pins.</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL3 pin is active high. The value in
                										the SSEL3 fields of the RXDAT, TXDATCTL, and TXCTL registers
                										related to SSEL3 is inverted relative to the
                										pins.</description>
                <name>HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL3</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SPI Delay register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between SSEL assertion and the
            								beginning of a data transfer. There is always one SPI clock time
            								between SSEL assertion and the first clock edge. This is not
            								considered part of the pre-delay. 0x0 = No additional time is
            								inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock
            								times are inserted. ... 0xF = 15 SPI clock times are
            								inserted.</description>
            <name>PRE_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between the end of a data
            								transfer and SSEL deassertion. 0x0 = No additional time is inserted.
            								0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are
            								inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>POST_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>If the EOF flag is set, controls the minimum amount of time
            								between the current frame and the next frame (or SSEL deassertion if
            								EOT). 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time
            								is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI
            								clock times are inserted.</description>
            <name>FRAME_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the minimum amount of time that the SSEL is
            								deasserted between transfers. 0x0 = The minimum time that SSEL is
            								deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum
            								time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum
            								time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The
            								minimum time that SSEL is deasserted is 16 SPI clock
            								times.</description>
            <name>TRANSFER_DELAY</name>
          </field>
        </fields>
        <name>DLY</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SPI Status. Some status flags can be cleared by writing a 1 to that
        						bit position</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is
            								available to be read from the receiver buffer. Cleared after a read
            								of the RXDAT register.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that
            								data may be written to the transmit buffer. Previous data may still
            								be in the process of being transmitted. Cleared when data is written
            								to TXDAT or TXDATCTL until the data is moved to the transmit shift
            								register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag. This flag applies only to
            								slave mode (Master = 0). This flag is set when the beginning of a
            								received character is detected while the receiver buffer is still in
            								use. If this occurs, the receiver buffer contents are preserved, and
            								the incoming data is lost. Data received by the SPI should be
            								considered undefined if RxOv is set.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag. This flag applies only
            								to slave mode (Master = 0). In this case, the transmitter must begin
            								sending new data on the next input clock if the transmitter is idle.
            								If that data is not available in the transmitter holding register at
            								that point, there is no data to transmit and the TXUR flag is set.
            								Data transmitted by the SPI should be considered undefined if TXUR
            								is set.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert. This flag is set whenever any slave
            								select transitions from deasserted to asserted, in both master and
            								slave modes. This allows determining when the SPI transmit/receive
            								functions become busy, and allows waking up the device from reduced
            								power modes when a slave mode access begins. This flag is cleared by
            								software.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert. This flag is set whenever any
            								asserted slave selects transition to deasserted, in both master and
            								slave modes. This allows determining when the SPI transmit/receive
            								functions become idle. This flag is cleared by
            								software.</description>
            <name>SSD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stalled status flag. This indicates whether the SPI is
            								currently in a stall condition.</description>
            <name>STALLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End Transfer control bit. Software can set this bit to
            								force an end to the current transfer when the transmitter finishes
            								any activity already in progress, as if the EOT flag had been set
            								prior to the last transmission. This capability is included to
            								support cases where it is not known when transmit data is written
            								that it will be the end of a transfer. The bit is cleared when the
            								transmitter becomes idle as the transfer comes to an end. Forcing an
            								end of transfer in this manner causes any specified FRAME_DELAY and
            								TRANSFER_DELAY to be inserted.</description>
            <name>ENDTRANSFER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master idle status flag. This bit is 1 whenever the SPI
            								master function is fully idle. This means that the transmit holding
            								register is empty and the transmitter is not in the process of
            								sending data.</description>
            <name>MSTIDLE</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x102</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SPI Interrupt Enable read and Set. A complete value may be read
        						from this register. Writing a 1 to any implemented bit position causes that
        						bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX ready interrupt enable. Determines whether an interrupt
            								occurs when receiver data is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when
                										receiver data is available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when
                										receiver data is available in the RXDAT
                										register.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX ready interrupt enable. Determines whether an interrupt
            								occurs when the transmitter holding register is
            								available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when the
                										transmitter holding register is available.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when data
                										may be written to TXDAT.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX overrun interrupt enable. Determines whether an
            								interrupt occurs when a receiver overrun occurs. This happens in
            								slave mode when there is a need for the receiver to move newly
            								received data to the RXDAT register when it is already in use. The
            								interface prevents receiver overrun in Master mode by not allowing a
            								new transmission to begin when a receiver overrun would otherwise
            								occur.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when a
                										receiver overrun occurs.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated if a
                										receiver overrun occurs.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX underrun interrupt enable. Determines whether an
            								interrupt occurs when a transmitter underrun occurs. This happens in
            								slave mode when there is a need to transmit data when none is
            								available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when the
                										transmitter underruns.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated if the
                										transmitter underruns.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave select assert interrupt enable. Determines whether an
            								interrupt occurs when the Slave Select is asserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when any
                										Slave Select transitions from deasserted to
                										asserted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when any
                										Slave Select transitions from deasserted to
                										asserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave select deassert interrupt enable. Determines whether
            								an interrupt occurs when the Slave Select is
            								deasserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when all
                										asserted Slave Selects transition to
                										deasserted.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when all
                										asserted Slave Selects transition to
                										deasserted.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSDEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master idle interrupt enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. No interrupt will be generated when the
                										SPI master function is idle.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. An interrupt will be generated when the
                										SPI master function is idle.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTIDLEEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>SPI Interrupt Enable Clear. Writing a 1 to any implemented bit
        						position causes the corresponding bit in INTENSET to be
        						cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET
            								register.</description>
            <name>SSDEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the MSTIDLE
            								register.</description>
            <name>MSTIDLE</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>SPI Receive Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Receiver Data. This contains the next piece of received
            								data. The number of bits that are used depends on the LEN setting in
            								TXCTL / TXDATCTL.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL0 pin to be saved along with received data. The value will
            								reflect the SSEL0 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL1 pin to be saved along with received data. The value will
            								reflect the SSEL1 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL2 pin to be saved along with received data. The value will
            								reflect the SSEL2 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of
            								the SSEL3 pin to be saved along with received data. The value will
            								reflect the SSEL3 pin for both master and slave operation. A zero
            								indicates that a slave select is active. The actual polarity of each
            								slave select pin is configured by the related SPOL bit in
            								CFG.</description>
            <name>RXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start of Transfer flag. This flag will be 1 if this is the
            								first data after the SSELs went from deasserted to asserted (i.e.,
            								any previous transfer has ended). This information can be used to
            								identify the first piece of data in cases where the transfer length
            								is greater than 16 bit.</description>
            <name>SOT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>SPI Transmit Data with Control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 1 to 16 bits of
            								data to be transmitted.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL0 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL0 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL0 asserted.</description>
                <name>SSEL0_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL0 not asserted.</description>
                <name>SSEL0_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL1 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL1 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL1 asserted.</description>
                <name>SSEL1_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL1 not asserted.</description>
                <name>SSEL1_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL2 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL2 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL2 asserted.</description>
                <name>SSEL2_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL2 not asserted.</description>
                <name>SSEL2_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select. This field asserts SSEL3 in master
            								mode. The output on the pin is active LOW by default. The active
            								state of the SSEL3 pin is configured by bits in the CFG
            								register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL3 asserted.</description>
                <name>SSEL3_ASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL3 not asserted.</description>
                <name>SSEL3_NOT_ASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSEL3_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer. The asserted SSEL will be deasserted at
            								the end of a transfer, and remain so for at least the time specified
            								by the Transfer_delay value in the DLY register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL not deasserted. This piece of data is not
                										treated as the end of a transfer. SSEL will not be
                										deasserted at the end of this data.</description>
                <name>SSEL_NOT_DEASSERTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL deasserted. This piece of data is treated as
                										the end of a transfer. SSEL will be deasserted at the end of
                										this piece of data.</description>
                <name>SSEL_DEASSERTED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame. Between frames, a delay may be inserted, as
            								defined by the FRAME_DELAY value in the DLY register. The end of a
            								frame may not be particularly meaningful if the FRAME_DELAY value =
            								0. This control can be used as part of the support for frame lengths
            								greater than 16 bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data not EOF. This piece of data transmitted is not
                										treated as the end of a frame.</description>
                <name>DATA_NOT_EOF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data EOF. This piece of data is treated as the end
                										of a frame, causing the FRAME_DELAY time to be inserted
                										before subsequent data is transmitted.</description>
                <name>DATA_EOF</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore. This allows data to be transmitted using
            								the SPI without the need to read unneeded data from the
            								receiver.Setting this bit simplifies the transmit process and can be
            								used with the DMA.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read received data. Received data must be read in
                										order to allow transmission to progress. In slave mode, an
                										overrun error will occur if received data is not read before
                										new data is received.</description>
                <name>READ_RECEIVED_DATA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignore received data. Received data is ignored,
                										allowing transmission without reading unneeded received
                										data. No receiver flags are generated.</description>
                <name>IGNORE_RECEIVED_DATA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Length. Specifies the data length from 1 to 16 bits.
            								Note that transfer lengths greater than 16 bits are supported by
            								implementing multiple sequential transmits. 0x0 = Data transfer is 1
            								bit in length. 0x1 = Data transfer is 2 bits in length. 0x2 = Data
            								transfer is 3 bits in length. ... 0xF = Data transfer is 16 bits in
            								length.</description>
            <name>LEN</name>
          </field>
        </fields>
        <name>TXDATCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>SPI Transmit Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 4 to 16 bits of
            								data to be transmitted.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI Transmit Control</description>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 0.</description>
            <name>TXSSEL0_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 1.</description>
            <name>TXSSEL1_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 2.</description>
            <name>TXSSEL2_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select 3.</description>
            <name>TXSSEL3_n</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer.</description>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame.</description>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore.</description>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data transfer Length.</description>
            <name>LEN</name>
          </field>
        </fields>
        <name>TXCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI clock Divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Rate divider value. Specifies how the PCLK for the SPI is
            								divided to produce the SPI clock rate in master mode. DIVVAL is -1
            								encoded such that the value 0 results in PCLK/1, the value 1 results
            								in PCLK/2, up to the maximum possible divide value of 0xFFFF, which
            								results in PCLK/65536.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>DIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>SPI Interrupt Status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert.</description>
            <name>SSD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Idle status flag.</description>
            <name>MSTIDLE</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x400B4000</baseAddress>
    <derivedFrom>CT32B2</derivedFrom>
    <description>Standard counter/timer 0 </description>
    <groupName>CT32B0</groupName>
    <interrupts>
      <interrupt>
        <name>CT32B0</name>
        <value>0xB</value>
      </interrupt>
    </interrupts>
    <name>CT32B0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The
        						IR can be read to identify which of eight possible interrupt sources are
        						pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 3 event.</description>
            <name>CR3INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer
        						Counter functions. The Timer Counter can be disabled or reset through the
        						TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and Prescale Counter are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do nothing.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and the Prescale Counter
                										are synchronously reset on the next positive edge of PCLK.
                										The counters remain reset until TCR[1] is returned to
                										zero.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 32 bit TC is incremented every PR+1 cycles of
        						PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (PC) is equal to this
        						value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PRVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 32 bit PC is a counter which is incremented
        						to the value stored in PR. When the value in PR is reached, the TC is
        						incremented and the PC is cleared. The PC is observable and controllable
        						through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt
        						is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR0 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1
            								matches the value in the TC. 0 = disabled. 1 = enabled. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR1 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR2 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR3 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the
        						capture inputs are used to load the Capture Registers and whether or not an
        						interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0: a sequence of 0 then 1
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0: a sequence of 1 then 0
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load
            								generates an interrupt.</description>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1: a sequence of 0 then 1
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1: a sequence of 1 then 0
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load
            								generates an interrupt.</description>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2: a sequence of 0 then 1
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load
            								generates an interrupt.</description>
            <name>CAP2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 3: a sequence of 0 then 1
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 3: a sequence of 1 then 0
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 3 capture event: a CR3 load
            								generates an interrupt.</description>
            <name>CAP3I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and
        						the external match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output
            								MAT0, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR0, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output
            								MAT1, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR1, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of output
            								MAT2, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR2, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output
            								MAT3, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR3, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of
            								External Match 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT0 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT0 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of
            								External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT1 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT1 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of
            								External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT2 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT2 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of
            								External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT3 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT3 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter
        						mode, and in Counter mode selects the signal and edge(s) for
        						counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode This field selects which rising PCLK
            								edges can increment Timer's Prescale Counter (PC), or clear PC and
            								increment Timer Counter (TC). Timer Mode: the TC is incremented when
            								the Prescale Counter matches the Prescale Register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode. Incremented every rising PCLK
                										edge.</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode rising edge. TC is incremented on
                										rising edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge. TC is incremented on
                										falling edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge. TC is incremented on both
                										edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_DUAL_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select When bits 1:0 in this register are not
            								00, these bits select which CAP pin is sampled for clocking. Note:
            								If Counter mode is selected for a particular CAPn input in the CTCR,
            								the 3 bits for that input in the Capture Control Register (CCR) must
            								be programmed as 000. However, capture and/or interrupt can be
            								selected for the other 3 CAPn inputs in the same
            								timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0. CAPn.0 for TIMERn</description>
                <name>CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1. CAPn.1 for TIMERn</description>
                <name>CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2. CAPn.2 for TIMERn</description>
                <name>CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 3. CAPn.3 for TIMERn</description>
                <name>CHANNEL_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CINSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the
            								prescaler when the capture-edge event specified in bits 7:5
            								occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which
            								capture input edge will cause the timer and prescaler to be cleared.
            								These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and
            								0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Rising Edge. Rising edge of the signal on
                										capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_RISING_EDG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Falling Edge. Falling edge of the signal
                										on capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_FALLING_ED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Rising Edge. Rising edge of the signal on
                										capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_RISING_EDG</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Falling Edge. Falling edge of the signal
                										on capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Rising Edge. Rising edge of the signal on
                										capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_RISING_EDG</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Falling Edge. Falling edge of the signal
                										on capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_FALLING_ED</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external
        						match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT0 is controlled by
                										EM0.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT01 is controlled by
                										EM1.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT2 is controlled by
                										EM2.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3. Note: It is recommended to
            								use match channel 3 to set the PWM cycle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT3 is controlled by
                										EM3.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT132Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x400B8000</baseAddress>
    <derivedFrom>CT32B2</derivedFrom>
    <description>Standard counter/timer 1 </description>
    <interrupts>
      <interrupt>
        <name>CT32B1</name>
        <value>0xC</value>
      </interrupt>
    </interrupts>
    <name>CT32B1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Register. The IR can be written to clear interrupts. The
        						IR can be read to identify which of eight possible interrupt sources are
        						pending.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 0.</description>
            <name>MR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 1.</description>
            <name>MR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 2.</description>
            <name>MR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for match channel 3.</description>
            <name>MR3INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 0 event.</description>
            <name>CR0INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 1 event.</description>
            <name>CR1INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 2 event.</description>
            <name>CR2INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt flag for capture channel 3 event.</description>
            <name>CR3INT</name>
          </field>
        </fields>
        <name>IR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer Control Register. The TCR is used to control the Timer
        						Counter functions. The Timer Counter can be disabled or reset through the
        						TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.The counters are disabled.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and Prescale Counter are
                										enabled.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Do nothing.</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The Timer Counter and the Prescale Counter
                										are synchronously reset on the next positive edge of PCLK.
                										The counters remain reset until TCR[1] is returned to
                										zero.</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRST</name>
          </field>
        </fields>
        <name>TCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer Counter. The 32 bit TC is incremented every PR+1 cycles of
        						PCLK. The TC is controlled through the TCR.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter value.</description>
            <name>TCVAL</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Prescale Register. When the Prescale Counter (PC) is equal to this
        						value, the next clock increments the TC and clears the PC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PRVAL</name>
          </field>
        </fields>
        <name>PR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Prescale Counter. The 32 bit PC is a counter which is incremented
        						to the value stored in PR. When the value in PR is reached, the TC is
        						incremented and the PC is cleared. The PC is observable and controllable
        						through the bus interface.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Prescale counter value.</description>
            <name>PCVAL</name>
          </field>
        </fields>
        <name>PC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Match Control Register. The MCR is used to control if an interrupt
        						is generated and if the TC is reset when a Match occurs.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR0: an interrupt is generated when MR0
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR0: the TC will be reset if MR0 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR0R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR0 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR0S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR1: an interrupt is generated when MR1
            								matches the value in the TC. 0 = disabled. 1 = enabled. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR1: the TC will be reset if MR1 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR1R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR1 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR1S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR2: an interrupt is generated when MR2
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR2: the TC will be reset if MR2 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR2R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR2 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR2S</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt on MR3: an interrupt is generated when MR3
            								matches the value in the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset on MR3: the TC will be reset if MR3 matches it. 0 =
            								disabled. 1 = enabled.</description>
            <name>MR3R</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will
            								be set to 0 if MR3 matches the TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>MR3S</name>
          </field>
        </fields>
        <name>MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Capture Control Register. The CCR controls which edges of the
        						capture inputs are used to load the Capture Registers and whether or not an
        						interrupt is generated when a capture takes place.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 0: a sequence of 0 then 1
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 0: a sequence of 1 then 0
            								causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP0FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 0 capture event: a CR0 load
            								generates an interrupt.</description>
            <name>CAP0I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 1: a sequence of 0 then 1
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 1: a sequence of 1 then 0
            								causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP1FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 1 capture event: a CR1 load
            								generates an interrupt.</description>
            <name>CAP1I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 2: a sequence of 0 then 1
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 2: a sequence of 1 then 0
            								causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP2FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 2 capture event: a CR2 load
            								generates an interrupt.</description>
            <name>CAP2I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rising edge of capture channel 3: a sequence of 0 then 1
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3RE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Falling edge of capture channel 3: a sequence of 1 then 0
            								causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
            								enabled.</description>
            <name>CAP3FE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Generate interrupt on channel 3 capture event: a CR3 load
            								generates an interrupt.</description>
            <name>CAP3I</name>
          </field>
        </fields>
        <name>CCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>External Match Register. The EMR controls the match function and
        						the external match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 0. This bit reflects the state of output
            								MAT0, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR0, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 1. This bit reflects the state of output
            								MAT1, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR1, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 2. This bit reflects the state of output
            								MAT2, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR2, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Match 3. This bit reflects the state of output
            								MAT3, whether or not this output is connected to a pin. When a match
            								occurs between the TC and MR3, this bit can either toggle, go LOW,
            								go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven
            								to the MAT pins if the match function is selected via IOCON. 0 =
            								LOW. 1 = HIGH.</description>
            <name>EM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 0. Determines the functionality of
            								External Match 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT0 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT0 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 1. Determines the functionality of
            								External Match 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT1 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT1 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 2. Determines the functionality of
            								External Match 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT2 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT2 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Match Control 3. Determines the functionality of
            								External Match 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Do Nothing.</description>
                <name>DO_NOTHING</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear. Clear the corresponding External Match
                										bit/output to 0 (MAT3 pin is LOW if pinned
                										out).</description>
                <name>CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set. Set the corresponding External Match
                										bit/output to 1 (MAT3 pin is HIGH if pinned
                										out).</description>
                <name>SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle. Toggle the corresponding External Match
                										bit/output.</description>
                <name>TOGGLE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EMC3</name>
          </field>
        </fields>
        <name>EMR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Count Control Register. The CTCR selects between Timer and Counter
        						mode, and in Counter mode selects the signal and edge(s) for
        						counting.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Counter/Timer Mode This field selects which rising PCLK
            								edges can increment Timer's Prescale Counter (PC), or clear PC and
            								increment Timer Counter (TC). Timer Mode: the TC is incremented when
            								the Prescale Counter matches the Prescale Register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer Mode. Incremented every rising PCLK
                										edge.</description>
                <name>TIMER_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode rising edge. TC is incremented on
                										rising edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode falling edge. TC is incremented on
                										falling edges on the CAP input selected by bits
                										3:2.</description>
                <name>COUNTER_MODE_FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counter Mode dual edge. TC is incremented on both
                										edges on the CAP input selected by bits 3:2.</description>
                <name>COUNTER_MODE_DUAL_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Count Input Select When bits 1:0 in this register are not
            								00, these bits select which CAP pin is sampled for clocking. Note:
            								If Counter mode is selected for a particular CAPn input in the CTCR,
            								the 3 bits for that input in the Capture Control Register (CCR) must
            								be programmed as 000. However, capture and/or interrupt can be
            								selected for the other 3 CAPn inputs in the same
            								timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0. CAPn.0 for TIMERn</description>
                <name>CHANNEL_0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1. CAPn.1 for TIMERn</description>
                <name>CHANNEL_1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2. CAPn.2 for TIMERn</description>
                <name>CHANNEL_2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 3. CAPn.3 for TIMERn</description>
                <name>CHANNEL_3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CINSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit to 1 enables clearing of the timer and the
            								prescaler when the capture-edge event specified in bits 7:5
            								occurs.</description>
            <name>ENCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Edge select. When bit 4 is 1, these bits select which
            								capture input edge will cause the timer and prescaler to be cleared.
            								These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and
            								0x6 to 0x7 are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Rising Edge. Rising edge of the signal on
                										capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_RISING_EDG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 0 Falling Edge. Falling edge of the signal
                										on capture channel 0 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_0_FALLING_ED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Rising Edge. Rising edge of the signal on
                										capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_RISING_EDG</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 1 Falling Edge. Falling edge of the signal
                										on capture channel 1 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_1_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Rising Edge. Rising edge of the signal on
                										capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_RISING_EDG</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel 2 Falling Edge. Falling edge of the signal
                										on capture channel 2 clears the timer (if bit 4 is
                										set).</description>
                <name>CHANNEL_2_FALLING_ED</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SELCC</name>
          </field>
        </fields>
        <name>CTCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>PWM Control Register. The PWMCON enables PWM mode for the external
        						match pins.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT0 is controlled by
                										EM0.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT0.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT01 is controlled by
                										EM1.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT1.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT2 is controlled by
                										EM2.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT32Bn_MAT2.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM mode enable for channel3. Note: It is recommended to
            								use match channel 3 to set the PWM cycle.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Match. CT32Bn_MAT3 is controlled by
                										EM3.</description>
                <name>MATCH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM. PWM mode is enabled for
                										CT132Bn_MAT3.</description>
                <name>PWM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWMEN3</name>
          </field>
        </fields>
        <name>PWMC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Match Register 0. MR0 can be enabled through the MCR to reset the
        						TC, stop both the TC and PC, and/or generate an interrupt every time MR0
        						matches the TC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter match value.</description>
            <name>MATCH</name>
          </field>
        </fields>
        <name>MR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Capture Register 0. CR0 is loaded with the value of TC when there
        						is an event on the CAPn.0 input.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Timer counter capture value.</description>
            <name>CAP</name>
          </field>
        </fields>
        <name>CR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<size>0x20</size>
<version>0.4</version>
<width>0x20</width></device>